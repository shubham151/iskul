[
    {
        "title": "4.9 Longest Common Subsequence (LCS)  - Recursion and Dynamic Programming",
        "link": "https://www.youtube.com/watch?v=sSno9rV8Rhg",
        "transcript": "hi the topic is longest common sub sequence in short lcs in this video I will explain what is the problem (LCS problem) then I will solve it using recursion I will write an algorithm and show you how it can be solved using recursion Then Recursion are time consuming So to save the time We can use memoisation                                                                                                 'e' has appeared here then 'c' should be following that 'e' not at that backside of 'e'                 instead of starting from 'e', I will start from 'c' yes, matching. 'd'- yes matching. 'g' and 'i' - yes. c-d-g-i is also there         sub-sequence I'll take one more example and show you                                             which are the same length yes there can be multiple sub-sequences of the same length also so that's it- the problem is finding whether the set of characters in these two strings are matching or not                                                                         and 'A'         This is one call where       Otherwise- one more is                                                         trace the other nodes also they are not the same                                                                                                     A[1] and B[3] and this is d,d and here it is 1 + A[2] and B[4]                     exponential time-taking algorithm         this is a top-down approach   here- there is an overlapping problem                   to improve recursion you can take the help of memoization   overlapping, but if a problem is big with a lot of branches will be overlapping. So let us finally understand how memoization can make this algorithm faster. I will not change the code a table and show you how memoization can help this one.     for memoization     and I have taken the indexes from 0, onwards. Now let us see how this algorithm can utilize this table to work faster. So first we will start from [0,0], then [1,0], then [2,1]                                                                                                                                                                         no- they are not matching so take the maximum of these two. This condition. So- that is 0,0 is 0 Then B is matching with this one. Yes- matching. 0 + 1 ... 1 then         B and D they are not matching so previous column with previous row- here - maximum of this that is 1 only. Now next row           maximum of these two                                                                                                                                                 and the maximum of these two is 2.   N is matching here     add one two so when there's a match, take the diagonal add one then E   previous column, previous row - two. previous column, previous row - two. Now here, E is matching with this one                                                       LCS algorithm using dynamic programming is m cross n that's it the matching characters need not be continuous and you can reduce its time. D A Not matching. E is matching here "
    },
    {
        "title": "Longest Common Subsequence - Dynamic Programming - Leetcode 1143",
        "link": "https://www.youtube.com/watch?v=Ua0GhsJSlWM",
        "transcript": "hey everyone welcome back and let's write some more neat code today so today let's solve longest common subsequence a dynamic programming problem and this is pretty much one of the most popular dynamic programming problems so we are given two strings text 1 and text 2 and we just want to return the length of the longest common subsequence between these two strings and you might remember from my last video where we learned basically what a sub sequence is it's basically uh you take a string right like this string a b c d e and you just you know you choose a few characters from it while you maintain the order so one sub sequence from this string could be a b right you take the first two characters from and you can take any characters you can choose to remove any characters you can do whatever you want and so we're looking for the longest common subsequence so a subsequence that is in both of the strings so in this example we have two strings right a b c d e and a c e so what is the longest common subsequence between these well when you take a look at the first string you see that hey they both have an a right they both have an a in the first spot so that's good so now let's look at the second character b and c well this has a b but the second string does not have a b but the second string does have a c and we also have a c over here but the second string does not have a d right so we can't include the d from the first string but then we see the last character is an e the last character and the other string is also an e so we get the longest common subsequence to just be the original second string right ace because ace can be found in the first string all we have to do is remove a couple characters right remove the b and remove the d then we get a subsequence that matches the second string so the length of the longest common subsequence is three so how can we solve this problem well as i mentioned dynamic programming is the most efficient way to solve this problem but before we even get into the dynamic programming solution which is going to be a two dimensional dynamic programming solution before we get into that let's just notice one thing do you so let's say these are our two strings right string one and string two does it at least make sense to you that okay like we would want to start let's say at the beginning of both strings right like we're looking for the longest common sub sequence it might just be that both of the strings are actually equal right that could be a possible way so let's look at the first character in each string and in this case they match each other right they're the same character so does it at least make sense to you that if both of the characters match each other right the first characters that the longest common subsequence then we can break it into a sub problem right now the new problem we're looking at is finding the longest common subsequence between the remainder of both strings right plus one plus one because we see that the first two characters are equal right that's where our one comes from right because we know that the longest common subsequence is at least going to be one because we found a matching pair of characters right and then we have a sub problem right and you you might know that that's what dynamic programming is all about finding the sub problem now what if this character was a b right and this is an a so clearly they're not the same character what would we do then well we can't do what we just did we can't add one and then find the longest common subsequence between uh the the remainder of the two strings we can't do that but but we can break it into a different sub problem we can say well it's possible that the longest common subsequence could be between these two strings right or it could be between this string and this string so this is just a little bit of an explanation before i show you the actual dynamic programming solution right basically what we found out is that based on comparing the first two characters whether they're equal or not equal we can break up the problem into sub problems and then solve those sub problems so take a look what i just did i took the two input strings right string one and string two and i wrote them in a different way right i said that this is a two dimensional dynamic programming problem and you might know that a grid a 2d grid like this is commonly used to solve these types of dynamic programming problems so notice that for each character in both strings there's a square right a position a cell that we can put a value in we're going to put a value in each of these cells and so let's just start at the beginning like we did right so let's start at the first characters right what we're trying to do is for these strings find the longest common subsequence between the entire strings right so what we're going to do is put that value right here that's what's going to be the entire longest common subsequence so we want to compute the value that goes here but what you're going to find is to do that we need to solve some sub problems and then you know continue to do that and then work our way back up to this position so what do we notice we let's look at these two characters right they're equal a and a right so okay so now we want to find the value that goes here how can we find that value well like i mentioned right now we're trying to solve a sub problem we want to find the longest common subsequence between these two substrings right we don't have to check these a's anymore because we know they match each other so now i want to find this new sub problem right and so basically what i'm saying is i'm going to go here i'm i want to solve the sub problem that goes here so now we're here right we're comparing this b with this c we see that they're not equal this time right that means we're not going to be going diagonally we're not going to look at this sub problem we're going to look at a different sub problem since these characters do not equal each other we have to check two different sub problems it means that the longest common subsurface between these two substrings is going to be found in either of these two positions right so let's look at this position first with this position tells us we're trying to find the longest common subsequence between this string and this string right so basically we're not looking at this c anymore right and this position tells us that we're looking at the longest common subsequence between this string and this string so basically when we remove this b right and just by looking at it right you can tell that this is going to these two strings are going to lead to a longest common subsequence of one just by looking at it right because you can see that this has one character it's an e it only matches this e so that's going to be a one but when you look at this string and this string right corresponding to this position we see that this has a ce this has a ce so this is n this is going to end up being a two but let me actually solve the rest of it a little bit so mainly looking at these two strings right in this position we see that the c's match each other right so since remember when the characters match each other the first characters of both strings match each other that's when we go diagonally and the reason we go diagonally is because then we know we can look at the remainder of both of the strings right we we know that this c matches this c so we want to look diagonally we want to look at these two substrings so what's the longest common substring between these two okay so what are we gonna do let's compare the first character right so d and and e so these characters are not equal so remember what we do when the first characters are not equal then we can't go diagonally so what do we decide to do we go to the right and we go down and we take whatever the max of these two is and then put it in this value that's what we're gonna do so first let's check this right position so what does this right position even mean it means we're taking this substring and finding the longest common subsequence with this substring but this is an empty string so what's going to be in this cell remember this is actually out of bounds anyway right so what default value are we gonna give ourselves if we go out of bounds to the right clearly the the longest come sub sequence between a string and an empty string like this is gonna be zero right so really what we're gonna initialize is we're gonna say every value in this column is going to be 0. similarly this is an empty substring if it were to if we were trying to find the lcs the longest common subsequence between this and an empty substring we would also get zero so what we're gonna do is put a zero in these positions right that's just how we're gonna initialize our 2d matrix when we start the problem okay so remember what we were doing we were at this position we were going right and we were going down trying to find the maximum value well clearly to the right we get a zero so that's not the max so let's go down okay now we're down so what are we doing we're finding the lcs between this substring and this substring well they're the exact same right e matches e okay great and remember when characters match each other that's when we look diagonally right so we came down here and now we're looking diagonally clearly we get a zero here right so zero plus one the reason we're doing a plus one here is because we found matching characters when characters match we add one because clearly the lcs between these is going to at least be one right at least one of these characters matches so now i'm basically gonna go here and then take us back along the path that we came from and then show you what the solution is so we had a one here right and so from this position we went down so since we were going down that means that this character and this character did not match each other so what we're gonna do is just take the one and put it up here right so there's gonna be a one here because the lcs between these two is one but now we're gonna go back over here diagonally right diagonally means that this character matched this character right so we're going to take the value that we got up here put it over here and add one because remember these match each other so we're adding one that means we're going to end up putting a two in this position and now we're we we're going up right we're going up because that's where we came from and remember when you go up that means the characters did not match each other the c and the b don't match each other so we're going to put a 2 here right we're just taking this 2 and putting it over here and lastly we're going back here that's where we came from right diagonally that means the characters were matching each other so we can add at least one character so two plus one that's going to be three this is how we got the result right so we got a three meaning that the lcs between these two strings is three right and that's what we learned from the problem explanation so right what we're going to do is return 3 that's our result but you can see that the way i did it was basically intuitive right i used this picture and basically solved this problem by hand using a little intuition and stuff right but the way we're gonna have to solve this with code is gonna be brute force ish right so it's dynamic programming but what we're gonna have to do is for every value in this cell right so we are gonna initialize these zeros right but with this matrix right this 2d matrix we want the value that goes up here right and to do that we have to compute the value that goes here that goes here that goes here and basically for all these and then finally we'll be able to have the value that goes here which is the result that we're going to return and so basically what i'm saying is this is going to be a bottom up dynamic programming solution right bottom up meaning we're going gonna solve it in reverse order we're gonna first get every value we're gonna get the value that goes here and then work our way up until we get to the result and you might have noticed see i have an i that tells us the column i have a j that tells us actually the column and the i tells us what the row is and so when we're working our way starting at the bottom and then working our way up how are we going to determine what value goes in each cell basically what i went over earlier right so we're going to look at the characters and if they match each other what we're going to do is say one plus the value that's diagonal right and we know when we go out of bounds there's a zero right there's an implicit zero when we go out of bounds and we're going to do that with every single cell right so when you look at these two we get an e and a c right and when characters don't match each other right that's important what we're going to do is we're going to look down right we see a zero down here and we're gonna go right right to the right side and we see a one here on the right side and what we're gonna do is take the max of those two values and we see that the max is of course one right one is bigger than zero and then we're going to put that max value in the cell so that's really it there are two choices right if the characters don't match each other right in this case or if their characters do match each other in this case right that's basically how we're going to solve this problem it'll make a little more sense when i show you the code so remember we're going to have a 2d grid so i'm going to call that dp for dynamic programming it's going to be a 2d grid and what i'm initially going to do is set it to all zeros right so and i'm just gonna do a little bit of uh python stuff so list comprehension in python so we're gonna go through every single value in the length of text two plus one right plus one because we we know that we need at least one more column to have all the zeros in it and so we're remember we're gonna put a zero for every value in that so length plus one and we're going to have this row for every value in the length of string one so text one plus one as well right so we're basically uh if you're not familiar with python this looks complicated but basically we're getting a 2d grid of dimensions length 2 plus 1 times a length string 1 plus 1 and initializing it to all zeros and then we're just going to have a nested loop and what we're going to do is iterate through this 2d grid in reverse order so in python you can do it like this and basically what i'm doing is starting at the bottom right of the matrix and then working our way up so this is how you do it in python negative one negative one and let's do the same thing for text two and so remember so we're going through every cell in our 2d grid and remember there were two conditions one condition is if the characters in both strings match each other so if text one of i matches text two at position j if they match each other we're going to do something and if they don't match each other we're going to do something different so remember if they do match each other then what we can say is at this position dp of i j because remember we're trying to fill in every single cell what we can do is then just simply take one plus the diagonal how do we find the diagonal well we can say i plus one and j plus one right that gives us the diagonal and remember we're adding one to it because these characters match that means we add a one and if they don't match that's the else case right so we're doing something different here we're going to put a different value for dp of ij and in this case what we're doing is we're finding the maximum of two values what are the two values the value to the right of this position so we can say dp of i j plus one we can say that's the right value and the value below the bottom value so we can say i plus one and j for that right so we're finding the maximum of these two we're not adding one we're not adding one because the characters did not match each other but basically literally these are the two cases we're just filling in a different value depending on what the case is and that's it so literally with these two nested loops and with these two conditions we're filling in the entire dp matrix and so once that matrix is filled in we know that the result is going to be at the top left of that matrix so the dp the matrix at index 0 0. that's going to have our result so all we have to do now is return the result and clearly you can see that the time complexity of this is the length of the strings multiplied by each other so if the length of string one was n and the length of string two was m we'd just multiply them together so this would be the time complexity that's also the memory complexity because we need extra memory for our 2d dynamic programming grid oops i had just one little bug i added one to the inside of that function but i needed to add one here but other than that you can see that the code does work and it is pretty efficient because the dynamic programming solution is the most efficient for this problem so i hope that this was helpful if it was please like and subscribe it supports the channel a lot and i'll hopefully see you pretty [Music] soon "
    },
    {
        "title": "Longest Common Subsequence (2 Strings) - Dynamic Programming & Competing Subproblems",
        "link": "https://www.youtube.com/watch?v=ASoaQq66foQ",
        "transcript": "okay so welcome back to the channel and today we have another dynamic programming question the longest common subsequence and this is going to be dynamic programming this is a pretty famous problem so I'm not afraid to say it off the bat because you probably already know that that's the approach for this okay so how does this problem work so we're looking for the longest common subsequence when you see subsequence that means that what we are looking for does not have to be contiguous what does contiguous look like what I just underlined is a contiguous sequence that is all together there's no gaps what can I do to make it non contiguous that sequence right there is not contiguous so this is a subsequence a F is a subsequence a subsequence does not have to be contiguous but it can be contiguous a sub sequence can be contiguous and might be broken up like this it could be both of them all right so our job here is to return to our caller the length of the longest common subsequence between two strings so what is the longest common subsequence here so we see that they share ace and we also see that these strings share these and we also see that these strings share ages so the longest common subsequence the longest subsequence that these strings have in common is ADH ADH how long is that three so what we return to our caller is three so looking at this example what is the longest common subsequence so the longest common subsequence is we see they share G's but we're gonna underline this G we see that they share T's we see that they share ace and we see that they share B's so what is the length of the longest common subsequence for these two strings it's going to be four okay so you see here that this is contiguous but again this guy right here is not contiguous these are sub sequences they don't have to be contiguous so this is our job and as I said what we're uses dynamic programming for this problem we could try to brute-force this problem we could try to generate all sub sequences this would be exponential in time so what we're going to do is we're going to use dynamic programming and I'll explain why or how we would get to this in an interview because most of the time you probably wouldn't and these are difficult problems to do but we'll see how we can wrap our mind around this question so I created a little example here and I want to help you wrap your mind around this problem and gain a deep understanding of what we're gonna do later we'll get into our DP table we'll do all of that stuff but what am I really doing what are the subproblems whenever I do dynamic programming I care about subproblems remembering the answer to subproblems and things like that so what we have here is two strings so my job is my job is to find the longest common subsequence of these two strings so what I'm going to do is I'm gonna break this down into a call recursion tree so what I'm gonna do here is I'm gonna break this down into what each call looks like and what decisions we make at each point based on what we see so stay with me so watch what happens okay so we have a longest common subsequence called on these two strings this is just pseudocode or like this isn't even a real function but let's just imagine this is our function so what we have is string 1 and string 2 so what I'm gonna do is I cut this up into subproblems this is the hardest part about solving dynamic programming problems so I'm gonna look at the last character that is all I care about okay I have my eyes on the last character and what do you see are these characters the same or are they different so we see they're the same so what does that mean that means I have a lengthening of my longest common subsequence by one value so what happens is this is what happens so do you see what happened I broke it down into subproblems my eyes were on the last character and what I'm doing now is I said what's the answer to him the answer to him is one plus the answer to this guy right here and you see we broke it down we cut off the last character we cut off the last character so the answer to this is we chop off the B's and now what is the longest common subsequence problem what is the answer to the sub problem for these guys and where do my eyes go my eyes go to the last character are these characters the same they are not the same so my job now is is to see if I delete either of these characters if I delete either of those characters which which sub problem is going to yield me a better longest common subsequence so stay with me stay with me it's it's confusing let me draw this out so that you can see okay so can you see this now so you can see how I broke this sub problem down into if I remove this a and I take the longest common subsequence between these two strings and then I remove the Z and then I take the longest common subsequence between these two strings whichever of these yield a bigger longest common subsequence whichever of these calls yield a larger answer I'm going to take that as the longest common subsequence given this sub-problem and then I'm gonna add one to this in the stack frame but the key here is the best answer to this sub problem when we have mismatching characters is I try removing this character I solve it I try removing this character and I solve it so this is confusing and we'll see it's less confusing when we get to the DP table but what we're trying to do is we're trying to find the best sort of path to take and decomposing the string so that we can yield to the longest common subsequence and we're chopping off character by character by character by character we're cutting off characters and we want to see which combinations of chopping off characters is going to yield us the longest common subsequence so how do these problems decompose so this problem we look at the last character are those a match and we see that these guys are not a match so this decomposes into the max of ripping this character off and ripping this character off so this is what it looks like okay so that's how that decomposes and then let's decompose him let's look at the last characters and then we see that they're a match so what this means is from this subproblem this is a problem alone this subproblem has no idea what's going on up here what we can do is we can do the same thing one plus removing this last character because these guys were a match there's no competition that needs to happen we don't need to compete about whether we need to remove this guy or this guy we can just remove both because it's a match okay so this is where our subproblems now stand and you can see that this is kind of recursive in nature so what we're gonna do is what we're gonna do is evaluate this guy if I have the empty string and I'll have another string if either of my strings are empty what does that mean that means that there's not going to be a longest common subsequence I can't have anything in common with an empty string if that makes sense I can't have anything in common between empty string and AZ so the answer the length of the longest common subsequence is zero this is there's no magic here it just makes common sense that nothing versus something we'll have nothing in common so we're going to put zero here we've found a base case so we can evaluate this to zero the longest common subsequence between these two guys is zero okay and then we can decompose this guy and now what we can do is we can go downwards and again what do we do we look at the last character and it's a match so we do 1 plus removing both of these guys remember no competition needs to happen I don't need to do a max competition between removing him and him I know that I found a match so these characters can both be removed so I can do more work and I can evaluate against without these characters so what happens is I turn this into this ok so we found a match we added one and now we're evaluating against without either character we evaluate against empty string and empty string well empty empty string will have a longest common subsequence of zero because the empty string verses an empty string there's nothing to have in common if either of them are empty we immediately have a longest common subsequence of zero because an empty string cannot relate to anything it cannot have a shared subsequence it has nothing so what we do is that becomes zero so again we're not tracing the recursion exactly because this can be modeled recursively but we have one plus zero and we can evaluate this guy this guy becomes one and notice the longest common subsequence between a and a is 1 the length is 1 and notice that's true a and a are a shared common subsequence it's 1 so that makes sense so what is the max of 0 & 1 it's 1 so do you see here do you see how we're drilling down sub-problem until we get to solid answers so our solid answer here is 1 so do you see this subproblem a versus a Z the answer to the subproblem is 1 is that true and it is true a and a are matching they match and that is the longest common subsequence a and a the answer to the subproblem is 1 so let's materialize that so what's happening is this sub-problem is still being worked on down here we've materialized this guy so let's work over here so what is the longest common subsequence between an empty string and a character remember if I have an empty string I can't relate to anything so what happens is this becomes 0 1 plus 0 is 1 and is this true the longest common subsequence we've seen a a and a is it 1 and yes it is 1 do you see we either can match those days or we can either match a to a we were limited by 1 a so it can only be 1 so what we see here is what we do is we evaluate that to 1 that is the answer to the subproblem right here so we have our competition our competition is finished we tried removing him we tried removing him the yielded answer from removing him was one the remote the answer yielded from removing him was one or I may have swapped that but do you see we're competing and the competition is won by whichever sub-problem is going to yield a longer common subsequence based on who we chopped off because these guys didn't match if they did match we would chop both of them off but because they did not match we had to do a competition so what we see here is 1 & 1 what's the max of 1 & 1 it's just going to be 1 so what is the length of the longest common subsequence between a a and a Z do you see how it's 1 do you see how we can match this a to that a or we can match the final a in the first string to this a all we have is this aid to play with over here so the answer to this subproblem is 1 the subproblems answer is 1 and what is 1 plus 1 2 and this is the magical thing about this our answers - is that true am i right so look at these strings a a B and a ZB so what we see here is a a B so we can see we can match the A's and then we see the B's match and what is our output our output is right there the answer to this overarching subproblem is - and i want you to know that when I did this walkthrough I did not look at any code I did not premeditate this I literally just wrote this on the board and from my understanding of how this problem fundamentally decomposes I just wrote the recursion how the recursion to pan out and we got our answer so this is what I want to communicate to you yes we can memorize problems we can memorize how to do certain things but if you have a real deep understanding of how these subproblems caught up into each other then you can do this problem without needing to see the code and then it becomes easier to go into implementation with understanding so what we're going to do now is we're going to look at the dynamic programming table to really reinforce what this idea of subproblem decomposition is all about so let's look at that table right now okay so what I'm going to you here is we're gonna walk through the dynamic programming table and how we would do this to cache subproblems so this problem is very similar to the levenshtein distance I have a video on that and I really feel bad because I was not completely clear about what each of these cells meant it is very very simple what does this cell mean that cell right there means this so do you see that right there do you see how it is a function call all each of these cells means is a different substring chopping that we call this function on their subproblems what I'm doing here is not different at all from what I just did in the walkthrough that I showed you it's just we're formalizing this because our code will have to iterate and store stuff in a table so this is what that cell right there means what does this cell mean what does that cell right there mean it means this it means the sub-problem a G a G and just the G just the G so that is what it means when I'm breaking these into subproblems they're separate function calls they're separate function calls were breaking things down into so the key here is to understand our subproblems so let's define our base cases here this is not how the code would do it but code is in the description if you want to see the concrete implementation I have put it there the code is in the description but I'm going to walk you through this just as but you know you would normally think about it so let's see how that goes so we have a versus an empty string what is the longest common subsequence remember what I said if either is an empty string they cannot have anything in common an empty string cannot share anything it does not matter what string you give me if I have an empty string I cannot find any common subsequence between them because it's an empty string so this is going to be 0 and then a G a G versus an empty string again 0 and then a G G versus an empty string zero and then a GG T versus an empty string that's going to be zero and then again we're going to compare against an empty string we're gonna call that LCS function on an empty string zero and zero okay I just realized I forgot a column right there my bad so yeah empty string versus an empty string that's going to be zero okay so now we're back to normal so G versus an empty string anytime I'm comparing against an empty string what is the answer to the longest common subsequence problem zero g x versus the empty string zero GX t versus the empty string zero G X T X versus the empty string nothing in common so the rest of these guys compared against an empty string are zero okay so now the work begins so what we're going to do is what I'm gonna do is I'm gonna see are these characters equivalent I'm gonna do a normal iteration row by row column by column like that and what I'm gonna see is at this cell are these characters the same a ng remember how we cared about the last character we're caring about the last character here these characters are not the same so what I do is I compete I remove the a if I cut the a off I'm going this way if I cut the G off I'm going upwards if that makes sense if you really understand what's happening in terms of our substring matching here we see that we're comparing A to G if I want to remove G I just go up and cut it out if I want to remove a I just go this way and cut it out so what I do is what is the max of 0 & 0 so the answer is 0 so the answer to the subproblem of a compared to G is 0 so what we do is we continue our iteration G versus G we have a winner so G is the same thing as G so we do 1 plus removing both of these characters how do I remove this G go up how do I remove that G go to the left and now our sub problem is the g-string and a so we do one plus the answer to this subproblem and that is the answer to this subproblem remember what we're doing right now is not different at all from what we did in the beginning the beginning was the understanding now this is just how we would implement it and do comparisons in a bottom-up manner so what we do is we compare g and g it's a match we go here 1 plus 0 is 1 G and T that's a mismatch what is the maximum item 1 and the reason I'm speeding up here is because the understandings were nailed down in that initial portion where we talked about the recursion and I talked about the subproblem e now we're just worried about implementing this and getting things going in terms of filling this table out so now a versus g mismatch i want to compete subproblems what's the max of these two guys one ok so now i have b and g they're not the same thing we compete subproblems the max is 1 ok so we're just gonna continue like this and our answer to the grand subproblem will be down there so it's very straightforward X and a mismatch we put 0 here the max of these two guys is zero X and G these are mismatches the max of these two guys is 1g and X mismatch the max is 1 T and X mismatch the max is 1 and X mismatch the max is 1 between these two cells and then B and X the max between these two cells is 1 and again we did that because that was a mismatch so on to the next row we see that mismatch mismatches happen all the way up to the T so we're gonna take a max here the max between 0 & 0 is 0 the max between 1 & 0 is 1 again G is a mismatch against T 1 and 1 the maximum is 1 and then T and T we have a match we can extend the longest common subsequence between the T's removed if we remove the T's so to remove this T I go up to remove that T I go to the left and I have a subproblem answer of 1 1 plus this problem answer here with the t's removed is 1 plus 1 which is 2 so the longest common subsequence between AGG T and G X T what is the length of the longest common subsequence it's 2 and as you can see for a fact it is 2 right there you see there's the longest common subsequence is that match up there so the tiene it's a mismatch we need to do a competition who's the winner the max of 2 in 1 is 2 so T and B is a mismatch the max of 2 in 1 is 2 on to the next row a and X mismatch so what we need to do is max of 0 and 0 is 0 G + X mismatch the max of 0 + 1 is 1 G + X again mismatch 1 in 1 the maximum is 1 T and X it's a mismatch the max is 2 between 2 and 1 the max is to a and X a mismatch the max between 2 & 2 is 2 so B and X it's a mismatch so 2 into the max is 2 a and a we have a match what we do is remove the a remove the a the answer to the subproblem with the A's removed is 0 0 + 1 because I just got a match and I can extend the longest common subsequence at the subproblem right here so it becomes 0 plus 1 is 1 a and G mismatch the max of 1 in 1 is 1 a and G mismatch the max of 1 + 1 is 1 T and a mismatch the max of 2 in 1 is 2 so a and a is a match so what we do is 2 plus 1 is 3 so B and a is a mismatch so what we do is compete 3 vs 2 3 is the max so y so what we see here is why does not match any of these guys so y is just gonna have max operations happen the max of 0 + 1 is 1 the max of 1 + 1 is 1 the max of 1 + 1 is 1 the max of 2 in 1 is going to be to the max of 2 + 3 is 3 the max of 3 M 3 is 3 and why did I just rush through that and do these maxes why does not match any of them so we would never do an operation where we do a plus we don't extend any longest common subsequence subproblems so what we're gonna do is be and we see that we do have a match be at the final position so every position up to that we're going to be doing max comparisons so max of 0 & 1 is 1 max of 1 & 1 is 1 the max of 1 in 1 is 1 the max of 2 in 1 is 2 the max of 3 & 2 is 3 and we see that the B's match here B's match so what I do is I come over here and what I do is I do 3 plus 1 I remove both of the B's 3 plus 1 it becomes 4 and the final answer for this problem is 4 and is that true am i right am I wrong I don't know whether I did this right so let's see what these strings actually look like okay so do you see them so what is the common subsequence between them what's the longest common subsequence and you see that our answer is correct the answer of 4 is correct and what we have here is the concrete answer of what this looks like so here's our dynamic programming table I don't want to make it about the table I don't want to make it about memorizing this I want to make it about understanding what is really happening and okay this is not intuitive at all I'm going to be outright and honest this how are you going to get this in an interview the thing is the more you practice problems like this if you know how to do the levenshtein distance then you're going to have a much easier time tackling a problem like this that deals with substring comparisons and decompositions like this so the more problems you do the higher the chance that you have that you can tackle a problem like this and use your algorithm knowledge to solve other problems but it's very difficult and and that's one of those things I have to be honest this is a difficult class of problems so anyway let's continue on and let's talk about time and space complexity very briefly ok so the time and space are pretty straightforward for this one we had M times n time at M times n space so n is the length of string 1 M is the length of string 2 so the time we're going to spend is we're to spend time solving all of these subproblems how many subproblems are there we can upper-bound that amount by this factor M times n so the space can be upper bounded by the amount of subproblems that we're cashing and the amount of subproblems we're cashing is M times n we're upper bounding that asymptotic aliy and again I have a video on asymptotic analysis if you want a deeper understanding of what I mean by that word so that's all for this video if you liked this video hit the like button and subscribe to this channel if you want to see more videos like this so yeah [Music] "
    },
    {
        "title": "Longest Common Subsequence- Dynamic Programming | Data structures and algorithms",
        "link": "https://www.youtube.com/watch?v=jHGgXV27qtk",
        "transcript": "hi guys welcome back in this video I am going to discuss with you how to find out longest common subsequence from the given strengths because sometimes they ask you in net exam they'll give you two strings and they'll ask you find out the common longest subsequence okay see as the name suggests it should be the longest subset budyonny two common common means two obviously two strings would be given or misako commonly Callahan what a subsequence subsequence is basically what you can say it's a sequence of strings or sequence of characters from a string okay and this sequence of characters would be in increasing order with respect to their position C let us take an example simple example suppose we are given one string W and it is having a b c and d these are number of characters in this string this one is one string now we are supposed to find out subsequence of this string okay subsequence you can write number of characters of these strings in increasing of increasing order of their value with respect to their position okay in their increasing value like a be this one is subsequence of this string we can write BD this one is also subsequence of the string subsequent number of characters obviously BD number of characters say in increasing order with respect to their position increasing order means C becomes before D or you can say D comes after D can we write C a no we cannot write this is not the proper subsequence see a CC comes after a though it should be AC this one is not right because this character should be in increasing order with respect to their position okay dope electric about Polly helices eige in the subsequence you can also write ad this one is also write a or D but we cannot write D B D and B we can write B D this one is not true b and b d and b okay d b k bar i got the sequence maybe BK bad he and hid okay also you can write a C and D this is also write a C and D B C D this one is also write ABCD obviously this is also right okay so how many number of sub sequence can be possible that is 2 raised to power n n is here 1 2 3 4 that is 2 raised to power 4 that is 16 number of subsequent SAR possible from this string now suppose one is given this one is w1 and this one is w2 I'm just taking simple example and w2 mayhem re pass here simply BC and D ok and you are supposed to find out the common subsequence longest common subsequence from w1 and w2 ok now this is the simple example so simply by looking at this case you can see BCD would be the longest and common subsequence common that should be common between W 1 and W 2 its key subsequence is ko 16 apke BB ho sucker say you can write down simple one character also bc ho success CD be possible here BD be possible here and CD also possible BCD is also there so common in the autonomous in sorry sub sequences or in Mesa common yoga that would be the longest that is BC and B so sometimes they ask you some come they will give you some complex two strings and they ask you that what is the longest common subsequence of these strings so that at that time it is not possible that you find out all the sub sequences of all the strings and then compare what what is the longest subsequence okay because sometimes they can give you many characters so you can say seven seven characters to raise to power 7 many subsequent season here also maybe seven or eight characters than to raise to power 8 number of sub sequences are possible so it would not be possible for you to calculate all the subsequent of two strings and then compare so I'll give you one simple trick okay let us take one example let us take this example you are given two strings x and y X's ABA ABA and Y is B a B ba a and you are supposed to find out the longest common subsequence from these two strings so the previous method is find out all the sub sequences of these and these and find out the common one but that is not possible because to raise to power one two three four five six six characters are there to raise to power 6 to raised about six number of so you can say the sub sequences would be there and that would be very time-consuming though another method is just to draw a table like this okay to the you know one side will write X and another side will write Y in this example we I have written X the string at this side and Y string this side you can also write X this side and why this side first row and first column would be 0 and 0 that is iid noted with this this this mark that is nothing is there negation or you can say something like that take care this 1 will be 0 and 0 or you can say Phi and Phi okay here I have written X X is what a B a a B a and at this side I have written B a BBA and that is why every character would form one row and this side every character would form one call and you are supposed to fill out these entries now okay we can take this one is I and and this this side we are moving toward this side this one is variable J and this one is I okay now how to fill out these entries check see now you have to fill out this entry till this side check out at this side you know the what is the character corresponding to this row a and here what is the character from this string that is B a and B these characters are different not same a and B are different fine if these characters are different then how you will fill out this entry if these are different then you here you will write maximum of either this one or this one I'll just tell you the formula also after this after discussing this one how to draw the formula a be a poor simple stable minuteness maximum of this one or this one here also we have zero here also we have zero what is the maximum zero okay and whether you have taken this one or this one you have to draw an arrow now here we have zero and zero so you can draw an arrow this side and this side any side I am just drawing an arrow this side because I am taking this zero I am taking this value okay simply next fill out this entry corresponding to this one we have a and corresponding to this we have y is what a here also a here also a both are same characters if same characters are there then how to fill out this entry in that case you will fill out this one one plus one plus this value this diagonal value upper diagonal value here we have 0 then 1 plus 0 is what 1 only and how you have drawn this one from this 0 from this 0 we have taken this 0 and then we have added 1 then you will draw an arrow from this one to this 0 like that ok next one is this one a and B these are also not same other same thing in that case what will you do maximum of this one or this one which value is maximum out of this upon a fill Carnahan through this one and this one a Beck Eric Cooper out of one and zero which one is maximum that is one then you'll right here what one and error would be towards this one because we have taken this value fill out this one a and B these are also not same the same he hang that is what you will write down here maximum of this one with this one maximum is what one and we have taken this one from here only this one next is this a and a now this a and this a both are same in that case how you will fill out this value 1 plus the upper diagonal diagonal may up for the ignore one a diagonal my value K here 0 then 1 plus 0 is what one fine and we have taken this one from this upper side okay now this one a and B these are also not say 'mother same nahi token C value log a maximum of either this one or this one I'll call you half will karna Hathaway scooper yep it yeah Holly Yusuke maximum up core value Lanie a maximum after 1 and 0 which one is maximum one will write one at this place and arrow would be this side because we have taken this value 1 this box I got Apple Year Zero Laney hootie-hoo arrow would be here okay so like this we will fill out this table next is next is this one you have to fill out this box corresponding to this one what is value of X B and what is character of Y that is BB and B are same are same high in that case what you will write 1 plus 1 plus diagonally up tekubi upper is box may yeah well you can 0 here and 1 plus 0 is 1 1 and the error would be APNIC on C value Li hey Cooper Valley then arrow would be like this towards zero our Valley zero yaw Malini next to this one corresponding to this what is B and upper is a both are different other different hand that case what will you take here maximum of either this one or this one a parabola box yes well a box key maximum arc of a linear one and one move each one is maximum or obviously one is maximum don't know same here okay now you can draw arrow either this side of the side I am drawing this arrow this side because this is also one this is also on the maximum of these two is one so you can take this one or this one fine now this place your outer fill out corresponding to this one the roll character is what B and here is we have B both are same if both characters are x and y are same then what you will write here 1 plus what is the value in upper diagonal diagonally up for the ik 9 upper diagonals that is 1 1 plus 1 is what - then you will write here 2 and the arrow would be like this a pod side because we have taken this one okay this one now you have to fill out this one B and B both are same there say my in that case what you will do 1 plus diagonal diagonal up there could be upper side what is value of this books that is 1 then 1 plus 1 is what again - and we have taken this one so arrow would be like this upper side okay now what should be here B and a and B are different different header you will take what maximum of out of this one or this one what is maximum of 2 and 1/2 is maximum then you'll write here 2 and we have taken this 2 then arrow would be like this towards this to whichever value you have taken the arrow would be towards that value here B and B both are same in case same and then 1 plus this diagonal diagonal value is what 1 is my OpCo vinet can have 1 plus 1 is what - and the arrow would be like this diagonally value up neck here here have you'll fill out this place a and corresponding to this place what is value of that character of I string that is B a and B both are different different hey in that case you'll take maximum of either this the maximum of this or this one and zero maximum is what one and we have taken this one so arrow would be upper side this one you have taken okay okay now a and a both are same in case both are same then one plus this value diagonally upper value value 1 plus 1 is what 2 will write 2 at this place and the arrow would be like this we have taken this one okay a and B both are different in case both are different than maximum of this one or this one what is maximum - n - 2 is maximum both are same then we'll write it here - you can write down the arrow like this one or this one because we have taken either this value or this value both are same I am taking this value suppose now arrow would be like this one this side okay like this you will fill out all the locations okay now after filling out all the places this is a table using that form alone okay now check out the last box the intersection of last row and column what is there for then this length of the common subsequence would be for you can find out by using this value last intersection value of this last row and column what is the value for then the length of that common subsequence would be for honest we have already we have find out this found out this length that is 4 but now you have to find out what is that sequence the number of character would before that is you can find out by using this value only but you have to find out now the characters what are those characters for characters for common characters okay in that subsequence now have to find out that place now you have to trace out we are at this place only we are starting from this place only okay now check out the arrows at this place where the arrow goes this side see this side okay now we are at this four only okay now check where the arrow goes to the diagonally diagonally upper side fine in case the arrow goes diagonally to the upper side then we will check what is the value what is the character according to this corresponding to this row a and what is the character corresponding to this column that is a then you'll write a if the arrow goes diagonally upper side when the arrow goes left or right left either this this in this row or either upward then you will not take the you will not write the character if the arrow goes diagonally upward then we will check out the character from the string X and by okay now from here we are going upward now we have reached to this three now check out this arrow this arrow is also going diagonally up or diagonally a poor now check out the character corresponding to this is row is B and column is B then we will write B and will write these characters from right to left from right to left half way other up man now we are going upward we are now at this place now here what where there goes to the here left side fine then in case arrow is going toward this side or toward that apples eye upward side then we will not write down any character now this side here then we'll go here on now we are at this place now the arrow goes upward see upward fine if arrow goes upward through corresponding to that box you have to check out the character in the row I also and the column will so that is a and a will right here now a and then we will jump upward then we are at this place only one and here check out where there goes straight upward will not write down any character because this is not diagonally upward where go we will go here only now the arrow goes diagonally upward see a curve corresponding to this diagonal now check out the character B corresponding to this box what is value of this in X string B what is characterized by string that is also B you'll write here B now you will go here then this one is what we have reached to or you can say here we have 0 no arrow is there because we have reached to that initial row and : then this one is longest common subsequence see the length of this is 1 2 3 4 4 hair length and the longest common subsequence is Bab it is not like that this one is the only longest common subsequence see another one what could be there another one if if suppose example a thing if you have written this arrow not like this you have written this arrow like this upward direction because they see when you fill out this location then you will check out the character corresponding to this row that is a corresponding to this column that is B both are different in case both characters are different then you will take what value maximum of this one or this one either this one or this one maximum is water both are same then we'll write here for and which one you have taken either this one or this one first case we have considered we have taken this value but now we are considering that we have taken this value of poor value fine then to find out the longest common subsequence we would start our tracing algorithm from this place only and we will go upward here only now at this place check out the arrow position arrow can't arrive not diagonally upward diagonally upwards ser o ji we will check out what is the correct character corresponding to this row B and B then we will write here be fine then we'll jump diagonally upward if now we are here only check out the arrow this error is also going diagonally upward then we'll check out the character a and a here we will write a we have reached to at this place only now here arrow goes at the side we have moved to the side now arrow goes this side we have moved to the side now arrows diagonally upward if diagonally upward arrow chaga in that case you have to write down something in that output check out the character a and a will write here a and then we will jump a go in the direction of this arrow diagonally upward we are at one here only now here also arrow goes diagonally upward now check out the character B and corresponding to this what is string in X B and Y may be happy then you'll write here B okay and with my now we have reached to this place and there is no arrow because we have raised to the first row and column so this is also another longest common subsequence be a a B like this you can find out many common subsequences according to these arrow positions okay but length would be whatever the value in the last box corresponding to this last row and call that would be the length okay now this is how you can find out the longest common subsequence now the formula is what how do you fill out these you know these values what is the formula how will fill out fill out I'll write down the formula this is the formula using that formula we have we can you can fill out this table okay see here what is there if X so Phi is equal to Y of J here at their side we have I and this side we have J variable x and y X so Phi X so Phi and X of Y of J if both are same let us take this example a and a both are same then what we have done again in case the new characters same and then we have done what 1 plus 1 plus this value diagonally up or value then we have taken what see this one is goes to Phi J or you can say whatever we have written this here 1 you can say this one is weight or Coast then coast of I and J would be 1 plus diagonally upward 1 plus C of I minus 1 and J minus 1 okay at a stake this one is from 0 we are starting 0 1 2 3 4 5 6 0 1 2 3 4 5 6 so at this at this box what is value Phi I value is 1 and what is value of JJ value is worth J value is what - fine now this is a this is a both are X of I and buy of J are same then 1 coast of this I J cost of 1 to 1 n 2 we got 1 plus I minus 1 1 plus cost of I minus 1 I is got 1 1 minus 1 is 0 cost of 0 and J minus 1 J 0 2 two minus one is one cost of zero and one zero and one that is this one and we have discussed this one also one plus C I IB up cake - whoa check out JB up car - over I - over then we will move to a port and J - over then backward so one plus this one in case they owe same nahi otherwise otherwise what is the cost of C and J let us take this case this one a and B both are different then what we have taken maximum of this one or this one C maximum of this one this is what a got backward our way then I value is same IQ value of Q 1 here I agree but J key value K ho jayegi - 1 which I get a maximum of CO Phi J minus 1 or you can say this one you happy jakey value up get through here Iggy but I here I looking for a gap key one say - one second I will be 0 that is 1 - or you can say C of I minus 1 and J see this is the formula you can draw this formula by looking at the stable only ok so I'll see you in the next video till then bye-bye take care "
    },
    {
        "title": "16. Dynamic Programming, Part 2: LCS, LIS, Coins",
        "link": "https://www.youtube.com/watch?v=KLBCUx1is2c",
        "transcript": "[SQUEAKING] [RUSTLING] [CLICKING] ERIK DEMAINE: All right\nwelcome back to 006, Dynamic Programming. We're now in step\ntwo out of four-- going to see a bunch\nmore examples-- three more examples of\ndynamic programming-- longest common subsequence,\nlongest increasing subsequence, and kind of a made\nup problem from 006, alternating coin game. And through those\nexamples, we're going to explore a\nfew new ideas, things we haven't seen in action\nbefore yet-- dealing with multiple sequences,\ninstead of just one; dealing with substrings\nof sequences, instead of prefixes\nand suffixes; parent pointers so we\ncan recover solutions, like in shortest paths. And a big one, which will\nmostly be fleshed out in the next lecture, is\nsubproblem constraint and expansion. This is all part of\nthe SRTBOT paradigm-- remember, subproblems,\nrelations, topological order, base case, original\nproblem, and time. Here is subproblems\nand relations. I've written down both\nwhat these things are and the key lessons we got from\nthe first dynamic programming lecture. Namely, we want to split up\nour problem into multiple subproblems, and if your\ninput is a sequence-- that's the main case\nwe've seen so far-- like the bowling\nproblem, for example, then the natural\nsubproblems to try are prefixes, suffixes,\nor substrings. Prefixes and suffixes are nice,\nbecause there's few of them. There's only a linear\nnumber of them. In general, we want\na polynomial number. Sometimes you can get\naway with one of these. They're usually about the same. Sometimes you need substrings. There's quadratically\nmany of those. Then, once you set up\nthe subproblems, which-- it's easy to set\nup some problems, but hard to do it right-- to test whether you\ndid it right is, can I write a\nrecurrence relation that relates one subproblem\nsolution to smaller subproblems solutions? And the general\ntrick for doing this is to identify some feature\nof the solution you're looking for. So you're trying to\nsolve some subproblem, and you try to ask a question\nwhose answer would let you reduce to a smaller subproblem. So if you can figure out\nwhat that question is, and that question only has a\npolynomial number of answers, then boom-- and you've\nonly got polynomial number of subproblems, then you will\nget a polynomial running time. So I have, I think,\nanother way to say this. We just locally brute\nforce all possible answers to whatever question\nwe come up with, as long as there's\npolynomially many. And then each of them is going\nto recursively call the smaller subproblems, but\nbecause we memoize, we'll only solve\neach subproblem once. And so on the end,\nthe running time will be, at most, the\nnumber of subproblems times the non-recursive\nwork done in that relation. For that to work, of course, the\nrelations between subproblems must be acyclic, so\nwe'd like to give an explicit topological order. Usually it's a\ncouple of for loops. But this is a topological\norder in the subproblem DAG, which I defined somewhat\ninformally last time. the. Vertices are\nsubproblems, and I want to draw an edge from a smaller\nproblem to a bigger problem, meaning that, if evaluating\nb in this relation calls a, then I'll draw an\narrow from a to b, from the things I need\nto do first to the things I'll do later. So then topological\norder will be ready-- by the time\nI try to compute b, I will have already computed a. And of course, the relation\nalso needs base cases. And then sometimes the original\nproblem we want to solve is just one of\nthose subproblems. Sometimes we need\nto combine multiple. We'll see that today. So that's a review\nof this framework. And let's dive into\nlongest common subsequence. This is kind of a\nclassic problem. It even has\napplications to things like computational biology. You have two DNA sequences. You want to measure\nhow in common they are. One version of that-- might see other\nversions in recitation-- called edit distance-- this is\na simplest, cleanest version, where I give you two sequences-- I have an example here. So for example, it could\nbe a sequence of letters. So my first sequence\nspells hieroglyphology-- study of hieroglyphs. And second sequence\nspells Michelangelo. And what I'd like\nis a subsequence. So remember, substring has\nto be some continuous range, some interval. Subsequence-- you\ncan take any subset of the letters in your\nsequence or any subset of the items in your sequence. So you can have\nblanks in between. You can skip over items. And so what we want is\nthe longest sequence that is a subsequence of\nboth the first string, the first sequence,\nand the second string. And if you stare at\nthis long enough, the longest common subsequence-- I don't think it's\nunique, but there is a longest common sequence,\nwhich is hello hiding in there. And that is a longest\ncommon subsequence. So given that input, the\ngoal is to compute hello, or whatever the longest\ncommon subsequence is. So we're given-- write\nthis down carefully-- given two sequences. Let me name them\nA and B. We want to find the longest\nsequence L that's a subsequence both A and B. So\nthat's the problem definition, and we're going to\nsee how to solve it using dynamic programming. And whereas, in the\nbowling problem, we just had a single\nsequence of numbers-- the values of the bowling pins-- here we have two sequences. And so we need a new trick. Before, we said, OK, if our\nsubproblems-- or sorry-- if our input consists\nof a single sequence, we'll try prefixes,\nsuffixes, or substrings. Now we've got two\nsequences, so somehow we need to combine multiple\ninputs together. And so here's a general trick-- subproblems for multiple inputs. It's a very simple trick. We just take the product,\nmultiply the subproblem spaces. OK. In the sense of cross product\nof sets, and in particular, from a combinatorial\nperspective-- so we have two inputs,\nthe first sequence A and the second sequence\nB. For each of them, there's a natural choice, or\nthere's three natural choices. We could do one of these. I will choose suffixes\nfor A and suffixes for B. You could do some\nother combination, but that would be\nenough for here. And then I want to\nmultiply these spaces, meaning the number\nof subproblems is going to be the product\nof the number of suffixes here times the number\nof suffixes here. And in other words,\nevery subproblem in LCS is going to be a\npair of suffixes. So let me write that down. So for LCS, our\nsubproblems are L of i, j-- this is going to be the\nlongest common subsequence-- of the suffix of A starting\nat i and the suffix of B starting at j. And just to be clear\nhow many there are, I'll give the\nranges for i and j-- not going to assume\nthe sequences are the same length,\nlike in the example. So I'll write lengths of\nA and lengths of B. I like to include the empty suffix. So when j equals the length\nof B that's 0 items in it, because that makes for\nreally easy base cases. So I'd like to include\nthose in my problems. So that was the S in SRTBOT. Now I claim that set subproblems\nis enough to do a relation-- recursive relation among them. So I'd like to solve\nevery subproblems L i, j. Relation is actually\npretty simple, but it's maybe not so obvious. So the idea is, because\nwe're looking at suffixes, we should always\nthink about what happens in the first\nletter, because if we remove that first letter,\nthen we get a smaller suffix. If you're doing prefixes,\nyou should always look at the last letter. Either one would work\nfor this problem. So we're doing suffixes. So we look at A of i\nand we look at B of j. That's the first letter in\nthe suffix A starting at i and the suffix B starting at j. And there are two cases. They could be\nequal or different. I think the easier\ncase to think about is when they're different. So like in hieroglyphology\nand Michelangelo, if we look at the whole\nstring, say, the first letter in the top one is H. The\nfirst letter in the second one is M. Those are\ndifferent letters, so clearly, one of\nthose letters is not in the common subsequence,\nbecause they don't match. I can't start with an H.\nWell, I can start with an H, I could start with an M,\nbut I can't start with both. One of those letters\nis not in the output. In this example, it's M.\nBut I don't know which one, so I have this question. I want to identify\nsome question. And the question is, should I-- do I know that the H is\nnot in the answer or do I know that M is\nnot in the answer-- the final longest\ncommon subsequence? We don't know which,\nso we'll just try both. And then we're\ntrying to maximize the length of our\ncommon subsequence, so we'll take the max of L i\nplus 1 j and L i, j minus 1. So the intuition\nhere is one of-- at least one of Ai and\nBj is not in the LCS. Got this wrong. j plus 1-- sorry-- thinking about\nsubstrings already. Yeah. These are the beginning points,\nso I want exclude the i-th letter-- so if Ai is not in, then I\nwant to look at the suffix starting at i plus 1. If Bj is not in, then I\nwant to look at the suffix starting at j plus 1. So the indices are\nalways increasing in the function calls. And the other case is\nthat they're equal. So this one I have a little\nbit harder time arguing. I'm going to write the\nanswer, and then prove that the answer is correct. Here I claim you don't\nneed to make any choices. There's no question\nyou need to answer. You can actually\nguarantee that Ai and Bj might as well be in the\nlongest common subsequence. And so I get one point for\nthat and then I recurse on all the remaining letters-- so from i plus 1 on\nand from j plus 1 on. Why is this OK? Well, we have A, B. We're\nstarting at position i, and starting at\nposition j for B. Think of some optimal\nsolution, some longest common subsequence. So it pairs up\nletters in some way. This would be some non-crossing\npairing between equal letters. So first case is\nthat maybe i and j aren't paired with anything. Well, that's silly,\nbecause if they're not paired with anything,\nyou have some bearing on the rest of the items. You can add this pair, and that\nwould be a longer subsequence. So that would be\na contradiction. If we're taking-- imagining some\nhypothetical optimal solution, it has to pair one of\nthese with something. Maybe it pairs i with\nsomething else, though. Well, if we have a\nlongest common subsequence that looks like that, I can\njust instead pair i with Bj. If I had this pairing,\nI'm actually not using any of these letters, so why don't\nI just use this letter instead? So you can argue there is the\nlongest common subsequence that matches Ai with\nBj, and so then we can guarantee by\nthat little proof that we get one point\nfor matching them up-- that we don't have to\nmax this with anything. OK, so two cases-- pretty simple formula. And then we're basically done. We just need to fill\nin the rest of SRTBOT. So next is topological order. So this I'll write as for loops. Because I'm dealing\nwith suffixes, we want to start with\nthe empty suffixes, and then work our way to\nlarger and larger suffixes. So this might seem backwards. If you're doing prefixes, it\nwould be an increasing order. There's all sorts of orders. You could flip the i and j. It's very symmetric, so\nit doesn't really matter. But anything that's generally\ndecreasing i and j is good. Then we have base cases. These are when one of\nthe sequences is empty. I don't care how many items are\nin B, but if A has no items, there's no common subsequence. It's empty. And same for no\nmatter how big A is, if I have exhausted\nthe B string-- I start from beyond\nthe last item-- then I should get 0. Then the original problem\nwe want to solve is L 0, 0-- that's just the\nlongest common sequence of the entire A\nand the entire B-- and time. OK, so for time, we need to know\nhow many subproblems there are. It's A plus 1 times B plus 1. I'll just call that theta\nA, B. Assume these are not empty subsequences. So this is the number\nof subproblems. And then what we care about\nis, how much time do we spend for each sub problem\nin evaluating this recurrence relation? So we ignore the cost\nto recursively call these L's, because they\nare smaller subproblems. They're already dealt\nwith when I multiply by the number of subproblems. So I just care about this max\ncomputation and this equality check, and we'll say those\neach cost constant time. So this is quadratic time. If the two strings are\nsize n, this is n squared. In general, it's the product\nof the two string sizes. And that's longest\ncommon substring-- so pretty straightforward. Other than this little\nargument understanding the case when they're\nequal, the easy case where they're unequal, we just try\nthe only two things we could do. One of Ai and Bj is not in the\nlongest common subsequence, so what I like to say is\nwe guess which of those is the correct one that\nis not in the longest common subsequence. And if we guess that\nit's in A, then we'll recurse on that side. If we guess that it's in\nj, then we'll recurse on-- by increasing j. I'd like to assume-- not really-- that we always\nmake the correct guess, that we made the correct\nchoice, whether it's i or j. Now, we don't actually\nknow how to do that, so instead, we brute force. We try both of them, and\nthen, because we're trying to maximize, we take the max-- just another way of\nthinking about it. But overall, very\nstraightforward-- the only added complication here is we\nhad to deal with two sequences simultaneously, and we\njust took the product of those-- pretty easy. In general, if you have some\nconstant number of sequences, you can afford to do this. You'll still get polynomial. But of course, once\nyou go to n sequences, you can't afford this. You would an n to\nthe n behavior, so that's a limit to\nhow far you could go. Two sequences is\nfine, three sequences is fine, but n sequences-- there probably is no\npolynomial time algorithm for this problem. Cool-- I want to\nshow you an example. I have an example here. I didn't want to try\nout hieroglyphology versus Michelangelo, so I\ncame up with another example. Their habit is to say hi. So the longest common\nsubsequence of there and habit is HI. And it's a giant-- well, not that giant-- it looks\nkind of like a grid graph. The base cases are out here,\nbecause those correspond-- each of these nodes\nis a subproblem, and this corresponds to, what is\nthe longest common subsequence between EIR and ABIT? And it should be I. It's\nthe only letter they have in common, and that's\nwhy there's a 1 here to say that the longest\ncommon subsequence has a 1-- has size 1. The base cases are when\neither their has been emptied or when habit has been\nemptied, so those all have 0's on the outside. And then the problem we\ncare about is this one. It's their versus habit. Claim is the length is 2. And what I've drawn in here are\nwhat I'll call parent pointers, like we talked about with BFS,\nand shortest paths, and so on. So we had this choice-- sometimes we had a choice-- on whether we recursed\nhere or recursed here was the best thing to do. I'll draw in red the arrow\nfrom L i, j-- sorry-- to L i, j from one of\nthese in this case. And in this case,\nthere was no choice, but I'll still draw\nin red that arrow. So these diagonal edges\nare exactly the cases where the letters match. Here H equals H.\nI equals I here, so I draw this diagonal edge. That's that first case,\nwhere the letters are equal, and so I recurse by\nincreasing i and j. That's why I get\na diagonal edge. There's also one over\nhere, where T equals T. So for those, we're\ngetting a 1 plus. You see this 1 is 1\nlarger than the 0. This 2 is 1 larger than the 1. This 1 is one larger than the 0. And for every other\nvertex, we are rehearsing this way and this way. We see what those two numbers\nare, and we take the max. So this whole diagram\nis just filled in by-- for each position,\nwhere they're not equal. We look at the guy below. We look at the guy to the right. Those are the slightly\nsmaller substrings. We look at those values. We take the max. As long as you compute\nthis in a generally right-to-left and bottom-up\nfashion, whenever you're trying to compute\na guy, you will have the-- its predecessors\nalready computed. That's the topological\norder of this graph. And then, at the end, we\nget our answer, which is 2. And now, if we pay attention\nto where we came from-- for example, this vertex had\nto come from this direction-- 2 is the max of 2 and 1,\nso I highlight the 2 edge. And if I follow this path,\nthere should be a unique path to some base case. We don't know which one. And in this case,\nthe diagonal edges correspond to my\nmatching letters. So there's the H here,\nfollowed by the I here. And so HI is our longest\ncommon substring. In general, we just\nfollow these pointers backward-- the red pointers--\nand we get our answer. So not only do we compute\nthe length of the LCS, but we actually can find the\nLCS using parent pointers. And this is a concept you can\nuse in most dynamic programs, including all the\nones from today. OK, any questions about LCS? All right-- perfectly clear\nto everyone in the audience. Now we move onto longest\nincreasing subsequence, which-- did I lose a page here? I just disordered them. OK, this problem has\nalmost the same name, but is quite different\nand behavior-- longest increasing subsequence-- LIS, instead of LCS-- both famous problems, examples\nof dynamic programming. Here we're just given one\nsequence, like carbohydrate. So this is a\nsequence of letters, and I want to find the longest\nsubsequence of this sequence that is increasing--\nstrictly increasing, let's say-- so in this\ncase, alphabetically. I could include CR, for\nexample, but not CB. That would be a\ndescending subsequence. In this example,\nthe right answer-- or a right answer is abort. There aren't very many English\nwords that are increasing, but there are some, and I\nlooked through all of them. As I just implemented\nthis dynamic program we're about to write down,\nit took me like two minutes to write down the\nDP, and then more work to read the dictionary\nand look for cool examples. So in general, we're\ngiven some sequence A, and we want to find the longest\nincreasing subsequence of A-- the longest sequence that\nis increasing, strictly. We could use the same thing to\nsolve not strictly increasing, but-- so here things are going\nto be a little trickier. It's easy, in that we just\nhave a single sequence. So again, we think, OK,\nlet's look at our chart here. We could try prefixes,\nsuffixes, or substrings. I personally prefer suffixes. Jason prefers prefixes. Whatever you prefer is fine, but\nalways, generally, start there, because there's nothing\nin this problem that makes me think I need to\ndelete things from both ends. AUDIENCE: I have a question. ERIK DEMAINE: Yeah-- question? AUDIENCE: Isn't the answer\nto this problem always 26? ERIK DEMAINE: Is the\nanswer always, at most, 26? Yes, if you're dealing\nwith English words-- so when I say sequence here,\nthis is a sequence of arbitrary integers-- word size integers. So there you can have\na ton of variety. This is just for the fun of\nexamples, I've drawn this. But even if the answer is\n26, finding that longest common subsequence is-- the obvious algorithm would be\nto take all substrings of size 26, which is n to the 26. We're going to do much\nfaster than that here. N squared time. And then, if you remove\nthe strictly increasing, then it can be\narbitrarily large. OK, so let's try to do this. Maybe I won't be so pessimistic\nto write attempt here. Let's just go for it. So I want some subproblems, and\nI'm going to choose suffixes. So I'm going to define L of i\nto be the longest increasing subsequence of the suffix\nof A starting at i. That's the obvious thing to do. And now I'm going to leave\nmyself a little space, and then I'd like a\nrelation on these. So I'd like to say\nwhat L of i is. And what do I have to work with? Well, I have live\nthings larger than i. Those would be smaller suffixes. But let's go back to, what\nis a question that I could ask about this subproblem\nthat might help me figure out what the longest increasing\nsubsequence looks like? So we're looking at a-- here's A from i on. Longest increasing subsequence\nis some subsequence. And we'd like to\nremove letter i. Now, when we do that,\nthere are two choices. Maybe i is in the longest\nincreasing subsequence, or it's not in. So the question I\nwould like to answer is, is i in the longest\nincreasing subsequence of A-- of A from i onwards? This is a binary question. There are two options-- so again, just like before. And so I can brute\nforce those two options. And then I want the longest one,\nso I'm going to take the max. So I'd like to take the max\nof something like Li plus 1. So in the case that I don't put\ni in the solution, that's fine. Then I just look at i plus 1 on,\nand recursively compute that, and that would be my answer. And the other\noption is that I do put i in the longest increasing\nsubsequence, so I do 1 plus the rest L i plus 1. If I close this\nbrace, this would be a very strange recurrence,\nbecause this is always bigger than this one. There's something wrong\nhere, and the something wrong is I haven't enforced\nincreasing at all. There's no constraints here. It's just saying, well, I'll\ni put in, and then I'll do whatever remains, and I'll\npray that that's increasing-- probably won't be, because\nindeed, if i is a letter-- or is a number that is\nstrictly greater than i plus 1, then this will be wrong. So I really can't\nalways do this. I could check whether i plus\n1 is in the answer, but some-- but I don't. I can check whether the letter\ni is less than letter i plus 1. But maybe I put this in the\nlongest increasing subsequence and then I put this in the\nlongest increasing subsequence, and so I need to\ncompare these two items. But I don't know when\nthat's going to happen. Things seem really hard. And indeed, there's no way,\nfrom this subproblem definition, to write down a relation. But there is a slight\ntweak to this definition that makes it work. So the trouble we have\nhere-- and this is the idea of subproblem constraints\nor conditions-- the trouble we have\nis, when we recursively compute the longest increasing\nsubsequence on the remainder, we don't know the first\nitem in that answer. Maybe it's i plus 1. Maybe it's some guy over here. If we knew who it\nwas, then we could compare that item to item i. And so what we'd like to\ndo is add a constraint to the subproblem that somehow\nlets us know where the longest increasing subsequence starts. So what I would like to say is\nlong as increasing subsequence of that suffix that\nstarts with A of i. So in other words,\nit includes A of i. This was a separate question. OK, this is a bit of\na funny constraint. It changes the problem. It's no longer what\nwe want to solve. If you think about\nthe original problem, before, it was solving L of 0. We just want the longest\nincreasing subsequence of the whole thing. Now it's not necessarily L of 0. L of 0 means, what is the\nlongest increasing sub sequence of the whole sequence A that\nincludes the first letter of A? And maybe we do include\nthe first letter of A, maybe we don't we don't\nknow where the longest increasing subsequence starts. Here, for example, it didn't. It started at the second letter. But conveniently, it's\nOK that we don't know, because that's just\nanother question we could ask is, where do we start? Where might the LIS start? Could start at the first\nletter, second letter, third letter-- there's\nonly n choices, and let's just take\nthe max of all of them. So before I get to the relation,\nlet's solve this problem. I just want the max\nof L of i for all i. I guess we've been\nwriting size of A here. OK, the maximum will\nbe the overall longest increasing subsequence. So if I could find longest\nincreasing sub sequence that includes the first letter, or\nthe longest one that includes the second letter, and so on-- so it starts at\nthe first letter, starts at the second\nletter-- then this max will be the longest overall. This subproblem is not\nwhat I really wanted, but it's still good\nenough, because it lets me solve my original problem. And this is adding an extra\nconstraint to my problem. And doing this is challenging. Thinking about what the right\nconstraint that would let you solve your problem is tricky,\nespecially in the beginning. But for now, let's just take\nthis as a thing that works. Why does it work? Because now I can say-- well, this term was fine, max-- so I'm trying to write longest\nincreasing subsequence starting with the i-th letter, versus-- yeah, actually, no. This is just going\nto be different. OK, so now I get to the\ncentral issue, which is I know, by the definition of L\nof i, that I include letter i. This is going to be in my\nlongest increasing subsequence. That's what I'm looking\nfor, this definition. But I don't know what\nthe second letter is-- could be i plus 1,\ncould be i plus 2, could be anything bigger. Whenever there's\nsomething I don't know, I'll just brute force it. I don't care that I don't know. I'll just take a max over\nall the possible choices. Let's say that the next\nletter included in the longest increasing subsequence i is j. Then I would like\nto look at L of j. Now, I don't know what j is,\nbut I'll just brute force all possible choices for j. So that's going to be\ni strictly less than j, because I don't want include\nthe same letter i again. And otherwise, I would get\nan infinite recursive loop, if I put less than\nor equal to here. And maybe I don't do\nanything else to n. OK, not quite done-- now-- this is the\ninteresting part-- I can enforce increasing,\nbecause I can't just choose any letter j to the right of i. Also, the number-- or letter\nthat's written in here has to be greater than the\nnumber that's written here. That's the strictly\nincreasing property. So I can add as a constraint\nin this max to say A of i am strictly less than A of j. And if you wanted\nnon-strictly increasing, you would add an equal there. This is mathematical notation. In Python, you would say max\nopen paren of this thing for j in this range, if this holds. So I'm just doing for\nloop, but I only do-- I only look at the\npossible choices for j when the strict\nincreasing property holds. And then, when that\nholds, I put-- check this. Now, this set might be empty. I need to define what the\nmax is when it's empty. Oh, I also need a\n1 plus, don't I? Let me just do 1 plus. So we're told that i is in the\nanswer, so we always get 1. And then the remainder\nis this or 0. If there are no Aj's\ngreater than Ai, then we'll default to 0 and\nsay that i is the only item in my increasing subsequence. OK, so there are a few\ndetails to get right, but in general, once you figure\nout what these recurrences look like, they're very simple. This is one line of code, and\nthen all you need in addition to this is the\noriginal subproblem and some other things. We need the base cases, but\nI should do them in order. Topological order is\njust the usual for loop, because I'm doing suffixes. It's going to be i equals\nlength of A down to 0. Base case is going\nto be L of length of A, which is 0,\nbecause there's no letters in that suffix. And we already did\nO, and then time-- is a little different\nfrom the past examples. So number of subproblems,\njust like usual, is linear length\nof A subproblems. It's only one sequence\nwe're thinking about now, unlike the previous example. But the work we're\ndoing in this relation now is non-trivial work. Before we were just guessing\namong two different choices. Now we're guessing among\nup to n different choices. This n here is length of A. And so we have\ntheta length of A, non-recursive work that we're\ndoing in each subproblem. Or you might think of this as\nchoices that we're considering. And for each choice,\nwe're just spending-- I mean, we're just taking a\nmax of those items, adding 1. So that's a constant overhead. And so we just get this\nproduct, which is A squared-- cool. So that's longest\nincreasing subsequence. Make sure I didn't\nmiss anything else-- so we're using this idea\nof asking a question, and guessing or brute\nforcing the answer to that question in two places. One place is we're\npromising-- we're requesting that the longest\nincreasing subsequence starts at i, so then the\nquestion is, well, what is the very\nsecond item that's in the longest increasing\nsubsequence that starts with i? We're calling that\nj, and we're brute forcing all the possible\nchoices that j could be, which conveniently\nlets us check, confirm that it's actually an\nincreasing subsequence locally from i to j. And then L of j will\ntake care of the rest. By induction, the rest\nof the longest increase in subsequence starting at\nj will also be increasing. And so this guarantees, by\ninduction, the whole thing will be increasing. Then we also use this\nlocal brute force to solve the original problem. So we added this constraint\nof starting at i, but we didn't actually know\noverall where to start. But that's fine, because\nthere's only A choices. So I should mention, in\nthe running time analysis-- so they're solving\nthe subproblems. That's fine, but\nthen there's also a plus whatever it costs to\nsolve the original problem. But that's OK. That's length of A. All of this plus length of A\nis still length of A squared. But if you're doing exponential\nwork here, that would be bad. We have to do some\nreasonable amount of work to solve the original problem\nin terms of all the subproblems. I have an example hiding here. This is a little\nharder to stare at. Here I have empathy. And this example is not--\ndoesn't have much empathy, because the longest increasing\nsubsequence of empathy is empty. Empty is one of the few English\nwords that's increasing. And the hard part here\nis drawing the DAG. It's almost the complete\ngraph, but we only draw edges from smaller\nletters to bigger letters. So we draw from E\nto M, from E to P, from E not to A-- there's\nno edge from E to A-- from E to T, not from E to H,\nbut yes from E to Y. And then we also draw\nfrom E to the base case, which is there's\nno more letters. That edge to the base case is-- corresponds to this 0, or I\nguess this n, where we say, oh, let's just recurse. Let's just throw away-- actually, maybe we don't need\nthe union 0 there, in fact, because we include L of n,\nwhich is the empty substring. Then the definition of\nL is a little funny. What does it mean to say\nyou start with A of n? Hm? AUDIENCE: If we define A of n. ERIK DEMAINE: Right,\nA of n is not defined, so that's not so nice. So maybe fix that. n equals case. OK, but I'm still\ngoing to draw an edge there-- conceptually say, oh,\nwe're just done at that point. That's the base case, where\nwe have no string left-- cool. And when I said from to to\nactually, I meant the reverse. All the edges go\nfrom right to left. And then what we're doing\nis looking for the longest path in this DAG. Longest path is maybe a problem\nwe've talked about in problem session, because it's a DAG-- well, longest path is the\nsame thing as shortest path, if you just negate\nall the weights. There are no weights\nin this picture, so if you just put negative\n1 on all these edges and ask for the shortest path\nfrom the base to anywhere-- so single source shortest\npaths from this base-- then we would end up\ngetting this path, which, if you look at it,\nis E-M-P-T-Y, empty. And so that shortest path\nis indeed the right answer. What I've drawn here is\nthe shortest path tree. So also, if you wanted the\nlongest increasing subsequence starting at A, then it is\nA-T-Y, just by following the red arrows here. And how do you get that? You just draw the\nparent pointers, just like we did before. I didn't mention, but\nthis example can also be solved with shortest paths. Once I construct this graph,\nyou can do the shortest path from some base-- I don't know which one-- to here. If you put negative 1 on\nall of the diagonal edges and you put weight\n0 everywhere else, then that corresponds to-- the shortest path\nin that graph will correspond to the longest-- the path with the\nmost diagonal edges. And that makes sense, because\nthe diagonal is where we actually get letters in common. And so in this case, it's 2. So both of these dynamic\nprograms could instead-- instead of writing them\nas a recursive thing with memoization or writing\nthem bottom-up as a for loop and then doing the\ncomputation, you could instead construct\na graph and then run DAG shortest paths on it. But the point is these\nare the same thing. It's actually a lot\nsimpler to just write the dynamic programming\ncode, because it's just a for loop and\nthen a recurrence. So you're just\nupdating an array. Because you already know what\nthe topological order is, you don't have to write a\ngeneric depth for search algorithm, take the\nfinishing order, reverse it, and then run this-- run DAG shortest paths\nwith relaxation-- much simpler to just\nwrite down the recurrence, once you figured it out. But they are the same\nin these examples. In Fibonacci, for example,\nyou cannot write Fibonacci as a single source\nshortest paths problem, but a lot of DPs you can write\nas shortest paths problem-- just a connection to\nthings we've seen. All right, last example,\nlast problem for today-- we'll do more next week. Alternating coin game--\nthis is a two player game. We're going to find the\noptimal strategy in this game. In general, you have\na sequence of coins, and we have two players. They take turns. So given coins of value\nv0 to v n minus 1-- so it's a sequence. They're given in order-- in some order-- for\nexample, 5, 10, 100, 25-- not necessarily\nsorted order. And the rules of the game are\nwe're going to take turns. I'm going to take\nturns with you. I'm going to use I and you\nto refer to the two players. And so in each turn, either\none-- whoever's turn it is, I get to-- we get to choose either the\nfirst coin or the last coin among the coins that remain. So at the beginning,\nI can choose 5 or 25. And I might think,\noh, 25's really good. That's better than 5. I should choose that. But then, of course,\nyou're going next, and you're going to choose\n100, and you'll win the game. You'll get more of the\ntotal value of the coins. So in this is example,\na better strategy is to take the 5, because then\nthe 100 is still in the middle. And so once I take 5, you\nget to choose 10 or 25. At this point, you'd\nprobably prefer 25, because that's better than 10. But whichever you choose,\nI can take the 100. And so I get 105 points, and\nyou're going to get 35 points. OK-- good example for me. So that's easy for\na simple example, but in general, there are\nexponentially many strategies here. At each step, either of us\ncould go left or right-- choose is the leftmost\nor the rightmost. And we're going to give a\ndynamic programming algorithm that just solves this fast. I didn't mention-- so this\nalgorithm is quadratic time, but it can be made n log n time. It's a fun exercise. Using a lot of the data\nstructure augmentation stuff we've done, you can\nmake this n log n. This algorithm, I think, is\ngoing to be n squared time. So I won't right\nthe problem exactly, but I think you know the rules. Choose leftmost or rightmost\ncoin, alternating moves. So I'd like to define\nsome subproblems. And this is a problem that's\nvery naturally a substring problem. If I just looked at suffixes,\nthat would deal great with-- if I'm deleting coins from the\nleft, but as soon as I delete-- and if I delete coins\nonly from the right, that would give me prefixes. But I'll tell you now,\nthere's no dynamic programming where the answer is\nsuffixes and prefixes. You can do suffixes or\nprefixes, but if you need both, you almost certainly need\nsubstring, because as soon as I delete the first\ncoin, and then maybe you take the second coin-- that's exactly the optimal\nstrategy here-- now you have an arbitrary\nsubstring in the middle. But substrings are\nenough, because we're only leading from the ends. We'll look at substrings. So more precisely-- this\nis just the intuition-- we're going to define\nsome generic x of i, j is going to be what is\nthe maximum total value I can get from this game, if we\nplay it on coins of value Vi to Vj. So that's a substring. So this is one way to\nwrite down the subproblems, and it's also a good way. You could write down a\nrelation on this definition of subproblems. But I'm low on time. There's two ways to\nsolve this problem. This is a reasonable\nway, exploiting that the game is zero-sum. But I'd like to change just\na little bit to give you, I think, what's a cleaner way\nto solve the problem, which is to add a third coordinate\nto my subproblems. So now it's parameterized\nby three things. P here is-- only\nhas two choices. It's me or you. And this gets at a point\nthat's maybe not totally clear from this definition-- max total value that I can get\nfrom these-- this substring of coins. But this is not\nobviously what I need. So obviously, at the beginning,\nI want the whole string and I want to know what my\nmaximum value is-- fine. And I go first in this game. I didn't specify, but I do. [INAUDIBLE] But as soon as I do a move-- as\nsoon as I take the first coin, for example-- it's now your turn. And so I don't really want to\nknow the maximum total value that I would get if I go first. I'd like to say, if\nplayer P goes first. I'd really like to\nknow what happens in the case where you go first. So for some of the\nsubstrings, I want to know what happens when you\ngo first, and for some of them, I want to know what\nhappens when I go first, because as soon as I make\na move, it's your turn. And so we're going to flip back\nand forth between P being me and P being you-- P-U. So you don't\nhave to parameterize. There's a way to write\nthe recurrence otherwise, but this is, I think,\na lot more intuitive, because now we can do a\nvery simple relation, which is as follows. So I'm going to\nsplit into two cases. One is x of i, j, me and\nthe other is x of i, j, you. So x of i, j, me-- so I have some\nsubstring from i to j. What could I do? I could take the first coin or\nI could take the second coin. Which should I do? That's my question. What is my first move? Should I take the first\ncoin or the second coin? So this is my question. What is the first move? There are exactly two possible\nanswers to that question, so we can afford to just brute\nforce them and take the max. If we're moving, we\nwant the maximum number of points we can get-- maximum\ntotal value of the two choices. So if I take from the\ni side, the left side, that would be x sub i plus 1, j. Sorry. And now, crucially,\nwe flip players, because then it's your turn. And if I take from the j side,\nthat will make it j minus 1. This is what I\naccidentally wrote at the beginning of lecture. Also flip players. So either I shrink on the i\nside or I shrink on the j side. Oh, I should add on here the\nvalue of the coin that I get, and add on the value\nthe coin that I took. This is an expression\ninside the max. That sum. And if I take the max those\ntwo options, that will give-- that is my local brute force\nthe best choice of how many-- what are the total\nvalue of coins I will get out of the\nremainder, given that you start, plus this coin that I took\nright now in the first step, and for the two possible\nchoices of what that coin is? OK, what remains is, how do\nwe define this x of i, j, you. This is a little bit funnier,\nbut it's conceptually similar. I'm going to write basically the\nsame thing here, but with me, instead of you--\nbecause again, it flips. This is, if you go first, then\nthe very next move will be me. So this is just the\nsymmetric formula here. I can even put the braces in-- so far, the same. Now, I don't put in the plus Vi\nand I don't put in the plus Vj here, because if you're moving,\nI don't get those points. So there's an asymmetry\nin this definition. You could define it\nin different ways, but this is the\nmaximum total value that I would get if you start. So in your first move,\nyou get some points, but I don't get any\npoints out of that. So there's no plus Vi. There's no plus Vj. It's just you either\nchoose the i-th coin or you choose the j-th\ncoin, and then the coins that remain for me\nshrink accordingly. Now, you're kind of\na pain in the ass. You're an adversary\nyou're trying to minimize my score\npotentially because you're trying to maximize your score. This is a 0 sum game. So anything that\nyou get I don't get. If you want to\nmaximize your score, you're trying to\nminimize my score. These are symmetric things. And so if you think for a while,\nthe right thing to put here is min. From our perspective,\nwe're imagining what is the worst case that\ncould happen, no matter what you do. And we don't have\ncontrol over what you do, and so we'd really like\nto see, what score would I get if you chose the i-th coin? What score do you get if\nyou chose the j-th coin? And then what we get is going\nto be the worst of those two possibilities. So when we get to\nchoose, we're maximizing. And this is a general\ntwo player phenomenon that, when you choose,\nwe end up minimizing, because that's the saddest\nthing that could happen to us. OK, this is one way to\nwrite a recurrence relation. We have, of course,\nall of SRTBOT to do, so the topological order\nhere is in increasing length of substance. So the T is\nincreasing j minus i. Start with empty strings. So base case is that\nx of i, i, me is Vi. So here I'm inclusive in\nboth ends in this definition. So there is a coin I\ncan take at the end. But if you move last and\nthere's one coin left, then I don't get it, so it's 0. Then we have the original\nproblem that is x i, j, me-- sorry-- x 0, n. That's the entire coin\nset, starting with me. That was the problem\nI wanted to do. And then the running time we get\nis the number of subproblems-- that's theta n squared, because\nwe're doing substrings-- times the amount of\nnon-recursive work I do here. That's just a max\nof two numbers. Very simple. Constant time. So this is quadratic. Let me show you an example. This is hard to draw, but\nwhat I've described here is called solution\n2 in the notes. So here's our sequence-- 5, 10, 100, 25-- in both directions. And what we're interested\nin is all substrings. So over here I've\nwritten the choice for i. So we start at one of these,\nand if you start here, you can't end\nearlier than there. So that's why we're in the\nupper diagonal of this matrix. And then there's two\nversions of each problem-- the white version\nand the blue version just down and to\nthe right of it. If you can't see\nwhat blue is, this is the version where you start. This is the version\nwhere I start. And I've labeled here all\nof the different numbers. Please admire, because this\ntook a long time to draw. But in particular,\nwe have 105 here, meaning that the maximum\npoints I can get 105. And that's the case because,\nif we look over there, it is the max of these\ntwo incoming values plus the Vi that I get. So either I go to the left and\nI take that item or I go down and I take that item. So the option here is I\nwent to the left and took-- well, that's going to\nbe tricky to do in time. The claim is that\nthe best answer here is to go here with the 100 and\ntake the 5, because going down corresponds to\nremoving the last item. If I went to the left,\nthat corresponds to-- sorry-- the first item. If I went to the\nleft, that corresponds to removing the last\nitem, so my options are 10 plus 25, which is\n35, versus 100 plus 5. 105 wins, so that's why\nthere's a red edge here showing that was my better choice. And in general, if you follow\nthese parent pointers back, it gives you the optimal\nstrategy in what you should do. First, you should take the 5 is\nwhat this is saying, because we just clipped off the 5. We used to start\nhere, and now we start here in this subinterval. Then our opponents, to be\nannoying, will take the 25-- doesn't actually\nmatter, I think. Then we will take the\n100, and then they take the 10, and it's game over. OK, all the numbers\nhere are how many points we get-- doesn't say how many\npoints the opponent gets. Of course, you could\nadd that as well. It's just the total\nsum minus what we get. Now, let me come back\nto high level here. What we're really doing\nis subproblem expansion, and this is an idea that we\nwill expand on next lecture. And the idea is\nthat sometimes you start with the obvious\nsubproblems of prefixes, suffixes, or substrings. Here, the obvious\nversion was substrings, because we were\nmoving from both ends. If you don't know, probably\nsuffixes or prefixes are enough. So we start there,\nbut sometimes that's still not enough subproblems. Here, as soon as we made\na move, our problem almost turned upside-down,\nbecause now it's your turn, instead of my turn. And that was just\nannoying to deal with, and so we could-- whenever you\nrun into a new type of problem, just build more subproblems. As long as it stays\npolynomial number, we'll get polynomial time. And so here we doubled\nthe number of subproblems to just the me case\nand the you case, and that made this recurrence\nreally easy to write. In the notes, you'll see\na messier way to write it, if you don't do that. In the examples we'll\nsee next lecture, we're going to do a\nlot more expansion, maybe multiplying the number\nof problems by n or n squared. And this will give us-- it will let us add more\nconstraints to our subproblems, like we did in longest\nincreasing subsequence. We added this constraint that\nwe start with a particular item. The more subproblems we have, we\ncan consider more constraints, because we'll just brute force\nall the possible constraints that could apply. Well, we'll see more\nof that next time. That's it for today. "
    }
]
[
    {
        "title": "Dynamic Programming - Learn to Solve Algorithmic Problems & Coding Challenges",
        "link": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
        "transcript": "Hey programmers, I'm Alvin l come to our course\non dynamic programming. So dynamic programming is one of my most favorite topics to teach.\nBut unfortunately, I feel like dynamic programming also has a reputation for being a very difficult\ntopic. That being said, I think dynamic programming can be very intuitive. If we actually take\na nice gradual progression through the material, right? A lot of students have this habit of\njust trying to attempt a pretty hard dynamic programming problems, without going through\nthe necessary steps of really understanding the material, right? It goes without saying,\nif you want to do well on those data structure and algorithm interviews, you definitely need\nto know dynamic programming. So I hope to give you all the background knowledge, you\nneed to really crush those types of problems. Now, that being said, What problems are we\ngoing to solve throughout the course? Here are a few examples. So one question I can\nask you is to calculate the fourth number on the Fibonacci sequence seems like a very\neasy problem, can also ask you to count the number of different ways to move through a\nsix by nine grid, or something different, like given a set of coins? How can we make\n27 cents in the least number of coins? A final example would be given a set of substrings?\nWhat are the possible ways to construct a string potent pot? And all of these questions\nreally fall under the umbrella of dynamic programming. And this is really why I think\nthe topic has such a bad reputation or being very difficult, because the problems ranged\nso much, right? It looks like these problems are totally different. And there may not be\nany underlying mechanics that we can use to tackle all of them. But the short answer is,\nwe really can if we have the correct way of thinking about these problems. That being\nsaid, let's go over the overall format of this course, in this course, I think our key\nto victory is going to be to really visualize all of these algorithms, right? So we're going\nto spend a lot of time drawing things on the whiteboard, as well as visualizing things\nwith animations. To me all the heavy lifting on an algorithm interview is really done when\nyou come up with that picture, right? When you describe that process, and then translating\nit into some code is really the easy part. Right? The hard part is designing the algorithm\nin the first place, right? So we're going to draw out of things to make sure we understand\nthe structure of the problem, as well as coming up with a solution. And then once we're really\nhappy with that pen and paper process, then we'll hop into my editor, and we'll solve\nit in some code, we'll probably have to go back and forth, until we end up with an algorithm\nthat runs in an efficient amount of time, right. So it goes without saying, we're also\ngoing to analyze the time and space complexity of all of our solutions. I'll be writing my\ncode in JavaScript, but you'll find it very easy to translate our solutions into the language\nof your choice. So in this course, on dynamic programming, we're going to divide the material\ninto two main parts. Part one is going to be about memoization. And then Part two is\ngoing to be about tabulation. And don't sweat it if you have no idea what those two terms\nrefer to, don't worry, we'll reach all of that material step by step together, I think\nyou're going to realize if we actually learn these things in all very logical progression,\nwe're almost like discovering these algorithms. And I don't just have to tell us what the\nalgorithms are. So in terms of prerequisites, I won't assume you know anything about dynamic\nprogramming, but I will assume that you understand a little basic recursion, as well as some\nbasics of complexity analysis, right. So you're sort of familiar with big O notation. And\nI'm sure that we'll be able to review some of that notation as we move along. So I think\nwith all that out of the way, and no further ado, let's hop into the course. Alright, so\nwhere should we start? Well, I want us to really ease into this new topic. And so what\nwe'll do is we'll start by attacking a problem that you probably seen in the past that is\nI want to solve a Fibonacci problem. And so for us, we'll have a particular phrasing of\nthe Fibonacci problem. What I want to do is write a function fib of n that takes in a\nnumber as an argument, and I need to return the nth number of the Fibonacci sequence.\nAnd just to review, how does the sequence work? Well, the first and second number of\nthe sequence is just one. And then at any point in time to generate the next number\nof the sequence, you can just sum the previous two. So for example, these are the first few\nnumbers of the Fibonacci sequence, right starts 112358, and so on. What I'm saying is your\nnumber needs to take in like a position of the sequence. In other words, if I asked you\nfor the seventh Fibonacci number, you need to return the answer 13, right? Because the\nseventh bonacci number is 13. And how do we actually calculate that 13? Well, logically,\nit's just a sum of the previous two elements, that is five plus eight gives me the 13. So\nvery, very classic function here. And to really get us going for what we do later on in the\nlesson, I'm going to require us to solve this one recursively, right, it's really going\nto be at the heart of a topic for today. Why don't we kick things off by quickly implementing\nthe classic recursive implementation of a Fibonacci function, probably in this function\na few times in your programming career, usually one of the earliest examples of recursion\nthat we face. So we'll just lay out the classical notation here. So I want to take in a number\nand and I want to return the number of the Fibonacci sequence. Like we expect, the base\ncase is just about, you know, the first two numbers of the sequence. In other words, if\nI'm given some n, that's less than or equal to two, then what I should do is just returned\none. And I'm reading this because hey, the first two numbers of Fibonacci sequence are\nexactly one. But in the recursive case, in general, what I can do is just return the\nsum of the Fibonacci number right before the one I'm asking for, as well as the Fibonacci\nnumber two before the one I'm asking for, right? Again, the kind of baked in recursive\nnature Fibonacci is to calculate some Fibonacci number, you can take the sum of the previous\ntwo numbers in the sequence right. Now, of course, we should test our code for some correctness,\nwhat I'll do is call a few examples of this fib function. So I'll try fib of six, seven,\nand eight. And I shouldn't get the answers of 813 and 21, respectively, right. So let's\ngive this a go. I'll run this in some JavaScript. There we have it right. 813 and 21. So this\nis a very, very classic implementation of Fibonacci, you've probably seen this many\ntimes before. And we did solve it recursively. And really, what I want to do is give some\na larger number to this fib function. So what if I asked for, let's say, I don't know, the\n15th Fibonacci numbers seems like something reasonable to ask for. So if I give this code\na shot, it looks like the first three calls of bonacci do work fine, right, I get 813\nand 21. But the fourth call is actually still running, right, my program actually hasn't\nfinished. And this is a big issue with this type of implementation with Fibonacci. So\nobviously, this Fibonacci function needs some work. Let's go ahead and head to the drawing\nboard. Alright, so it's apparent that our Fibonacci function is correct. And that returns\na proper result. However, if we give it a large enough value of n, it's pretty slow.\nThat is our function has correctness but lacks some efficiency. In the long run, we definitely\nwant to improve this implementation of a recursive Fibonacci. But to do that, it's really important\nthat we identify exactly where there's even room for improvement. And to do that, I think\nwe should draw some things. This is something I think students actually need to work on.\nStudents have this habit of trying to like picture everything in their mind. And that\nworks for some easier problems. However, when we want to tackle more complex problems, if\nwe just try to capture all this information, just mentally without drawing it on, like\npen and paper, or marker and whiteboard, or chalk and chalkboard, you're going to really\nlose track of the finer details in these structures. So I want us to be very, very methodical,\nand we're going to draw really how you should visualize a problem like Fibonacci. And so\nover to my drawing, let's say that I wanted to trace through what happens when we call\na fib with the number seven. That is I'm asking for the seventh number in the Fibonacci sequence,\nI know that in the long run, I should get back to 13. Right. 13 is the seventh number\nin the sequence. So I'll keep that goal in mind. But over to my drawing, let's say I\ncalled fib of seven, I'll denote that by really drawing a circle with my value for n inside.\nSo I think about this call to fib of seven, what is it going to do? Well, I know that\nseven is not the base case, right? Seven is not less than or equal to two. So this call\nis going to branch out into some more recursive calls. In particular, on its left hand side,\nI'm going to call n minus one, which is six. On the right hand side, I'm going to do n\nminus two, which is five. And at this point, I carry over the same logic\nfor the other nodes have the structure, right, if I look at the six node, if I'm routed right\nthere, then that will have a left child of minus one, so five, it will also have a right\nchild of minus two. So four, you can start to see a pattern where really this recursive\nstructure just visualizes as a tree, which is really neat. I hop over to this five node,\nit will have some children, right, minus one on slept minus two on its right. And we will\nactually just continue this process for most of these nodes. But let's say we pause right\nhere. So you'll notice that these notes that have pointed to in red, they're actually the\nbase case, right? For those nodes, I have values of two or one. And I know that those\nfunction calls will return immediately. More importantly, that means they don't branch\ninto any further calls. So I don't want to start flushing out the tree of those nodes.\nInstead, I look at things that are not the base case, right? That is these nodes in yellow.\nSo I'll continue to flush out this tree, but not branch out further for the base cases. So at this point, I built out my entire tree,\nand I stopped fleshing out the tree whenever we had a base case scenario. So this is actually\nthe full recursive tree. Remember that the numbers inside of the nodes here represent\nthe end that we passed in. That being said, if we have this visualization, how does this\ntree really calculate the Fibonacci answer? Right, so let's start to break it down over\nhere. Let's say I looked at some note, in particular, this base case note of two, right?\nI know that this note is a base case, so it's going to return the value of one according\nto my base case, when we say return, that really just means return to your caller right\nreturn to your parent. So this note of two is going to return one to its parent of three.\nIn the same way, this node on the right hand side of one is also a base case, two will\nreturn one, both of those values that are returning, they go back to the parent of three,\nand three is actually going to add those two values up. One plus one is two. And this makes\na lot of sense because we know that the third Fibonacci number is two. So we can continue\nthis process. Okay, this node over here. This is also a base case. So it returns one. And\nnow the parent node of four is going to sum up both of its children values. Two plus one\nis three. And that makes sense in itself, because the fourth Fibonacci number is three.\nSo you probably got the picture. Now let's speed things up. For all of these base cases,\nI know that they're going to return one to their parent. And for all parent nodes that\nhave both of their children ready, that is both of their children returned, they're just\ngoing to add up those values. And this process just continues all the way up the tree, right?\nJust adding our left and right children. To get the answer that we should return the very\ntop of our tree at the root of our tree, we get the final result of 13, which makes a\nlot of sense, because at the start, we said that, hey, the seventh Fibonacci number is\nindeed 13. So now that we have a robust understanding of how to visualize this fib function, what\ndo we actually know about its speed? What do we know about time complexity. And so you\nmay have heard offhand people mentioned that a classic recursive implementation of fib\nis going to be two to the n in time complexity. And that is the case however, you really understand\nthe reason why. So hidden in this picture is the reason why Fibonacci for us is going\nto be two to the n in terms of its time complexity. However, something that's kind of unfortunate\nabout this drawing is it's asymmetric. And that's, I think, a big reason why students\nhave a really hard time convincing themselves that a function like this has a two to the\nn power time complexity. So here's what we'll do, why don't we warm up and kind of go through\nsome basic understanding of time complexity? And I promise we'll answer that Fibonacci\nquestion. So let's do a little warm up. Let's say that I gave you this foo function, notice\nthat it's different from our fib function, right? It's similar in that recursive, this\nfunction is kind of arbitrary, it actually doesn't calculate or solve any particular\nproblem. So if I wanted to visualize how this foo function behaves, let's draw it out. Let's\nsay I initially call it the top level foo of five. I know five is not a base case. So\nit's going to call upon n minus one, or it's going to call upon for four calls three, three\ncalls to two calls one, and then here, we've actually bottomed out at a base case. If you\nlook at the number of calls I made, I basically made exactly five function calls. Which makes\nsense, because in terms of our base case, where do we stop once we hit a number less\nthan or equal to one and every recursive step, we just subtract one from our current value\nof n. So overall, I have five calls here. But if I generalize that, for any arbitrary\ninput, I know that in the long run, I'm going to have about n different function calls recursively.\nAnd so for that reason, the time complexity of this is really just O of n time, right?\nI have to evaluate O of n different function calls. While we're at it, why don't we take\na look at the space complexity? Well, you may have heard in past that when we analyze\nthe space complexity of our recursive functions, we should include any of the additional stack\nspace that our function calls take up right, when we make a recursive call, we add that\nto the call stack, and those must be tracked by our computer. And so since we have about\nfive or n different function calls added to the stack, before we hit our base case, you\ncan see that the space complexity of this code is also O of n space, overall, we're\nlooking at O of n time and open space for this function. Pretty straightforward stuff,\nright? Let's look at another more involved function. So let's say I gave you now this\nbar function, it's another arbitrary function, it's very, very similar to foo, what you should\nnotice is, the only difference is when we make a recursive call, we do an n minus two\ninstead of an n minus one. So how does that actually change the time complexity of this\nfunction? So let's say I wanted to trace through this and I made a top level call to bar of\nsix, I know six is gonna call upon four four is gonna call upon to, to call zero and zero\nactually hits a base case. So this is very similar to our last example, except we kind\nof see that from one call to the next, we kind of take a bigger step in time, right.\nAnd so in a way, we can say that we're moving twice as far upon every recursive call. And\nthis would actually half the number of recursive calls we need overall. So I guess we might\nbe tempted to say that the time complexity of this one is N over two time, but a keen\nobserver would note that according to our bego, you know, understanding, we can remove\nany multiplicative constants when we have a time complexity, so N over two is the same\nas one half times n. So this simplifies nicely, it's just an O of n time complexity. Using\nthe same exact argument, we can also say that the space complexity from the stack is also\nopen space. All right, so let's take a lay of the land, I showed you two functions that\nare very similar, they really only differ in how they made their recursive calls, right?\nOne did minus one, the other did minus two. But in the grand scheme of things, we saw\nthat they had an identical complexity class, right? We have O of n time and O of n space\nfor both of these functions. So after these two examples, you may be able to see the reason\nI wanted to bring them up, right, maybe you're actually ready to make the logical leap and\nmake some conclusion about our classic Fibonacci recursive function. That being said, I don't\nwant to skip any steps. I want to be super methodical, I think, if we pay the cost of\nunderstanding fib right now, and I mean, truly, like Absolutely. Understanding fib. It's really\ngoing to pay off later on in the lesson when I slam me with some much harder problems.\nSo let's be nice and methodical over here. Let's take a look at some other functions.\nLet's say I gave you this did function now. very particular Right, we'll pay it no mind.\nWhat do we notice about this did function? Well, it has two recursive calls now right\ninside of every single call. And they both do an n minus one. How should we visualize\nthis one? Well, it's kind of similar to I guess, our initial fib drawing and shape,\nwhere if we start with some initial call, let's say five, five is going to branch to\nexactly two children, right? Because five is not yet the base case. And for this did\nfunction, it does a minus one on its left, and also it's a right child, right. So the\nnext level is just for next levels, just threes than twos, then just ones which would actually\nhit our base case over here. This is a really nice, like, beautifully symmetric tree, right?\nOkay, so this is a visualization for our dib function. But what does it tell us about the\ntime complexity of it? Something you'll hear me say a lot in this lesson is when we tackle\na quote, unquote, new problem, or a new pattern we're really trying to do is just leverage\nour past experience, right? So when I look at this tree structure, I'm trying to notice\nanything familiar, right? Is there some strand over here that I can grasp that to really\nfeel comfortable and kind of extend my previous learnings, right? Where can I find our base\ninside of this drawing? Boop, right here. So if I look at this path, I've highlighted\nin yellow, it's really just the path starting at the root node going down to some base case\nhere, I just designated the leftmost path. And what's really nice about this structure\nis just referring to the notes in yellow. It's a linear structure that we saw before,\nright? If I start at the root, it just goes 5432. And one. And so I know that in general,\nbased on my initial input of n, like the length of this path that has a number of nodes highlighted\nin yellow, there's going to be about n different nodes. If I kind of adapt that language for\nlike the tree, I can also say that the height of this tree is n. So the height of a tree\nis really just the distance from the root node all the way to the far this leaf, in\nthis case, that just means the distance from our top level called Five, all the way down\nto a base case, which is going to be exactly five here. Something you may also hear in\npassing is we can say that the number of levels in this tree is also n, this term is pretty\nstraightforward, right? When we say the number of levels, a level is just a collection of\nnodes that are the same distance away from the root. So for example, here in yellow,\nI have highlighted level zero, this is level one, this is level two, this is level three,\nand so on. But if I rewind things a bit, I look at the very, very top level, there's\none node here, on the next level, there's two nodes. On the next level, there's four\nnodes, then eight nodes, then 16 nodes, see the pattern? So let's try to generalize that. So I know\nno matter what, whenever we call some top level argument for dib, we know that we're\ngoing to have one node at the top level. But to get the number of nodes on the next level,\nwe'll just multiply that by two. And the level after that would also multiply by two and\nmultiply to again further levels after that. And I do this a total of n different times,\nright? Because I know that the height of the tree, or the number of levels in this tree\nis exactly n. And so what conclusion Can we make over here, we're basically saying that\nto get the total number of nodes, or the total number of calls a recursive function would\nmake, you would just take the number two, and multiply it by itself about n times over.\nAnd that is really the definition of an exponent, right? This is the same as two to the nth\npower. So we can say that this tree structure, this recursive function has a two to the N,\ntime complexity. Awesome. So we identified this dip function is having a two to the n\ntime complexity. But what do we know about the space complexity over here, I think a\ncommon mistake I've seen people make is kind of automatically assumed that the space complexity\nof a recursive function will be the same as the time complexity. And that might be a reasonable\ntrap to fall into, because we know that in the long run, we're gonna have to evaluate\ntwo to the n function calls. And so I guess that means you have to put two to the n function\ncalls on the stack. But there's actually some nuance to this, the time complexity of this\nis not the same as space complexity. So let's jump in. Let's say that we made our top level\ncall to dibba five, we know that that is added to the stack in the same way five calls for\nso it's that the stack, we add a stack frame for every call that we make down until just\nthe base case, right. So at this point, I reached a scenario where I have a base case,\nand I'd have about five stack frames on my call stack. And the important insight is when\nwe actually hit this base case that I have highlighted the left one over here, it actually\nwill return when something returns when a function returns, its stack frame is actually\nremoved or popped from the stack. And at this point, only after I have returned from that\nleft one, what I actually add the right one to the stack to be explored. And this process\ncontinues. Notice that any point in time the most number of stack frames that we use up,\nit's exactly five, right, it's not as if we throw all of these function calls on the stack\nat once. And because we have such a nice tree visual, we know that the number of stack frames\nthat we're ever going to use is really just the height of the tree, right, so the height\nof the tree is n like we said before, that means our maximum stack depth is also n. So\nwe have in space complexity coming from the call stack. So overall, for a dip function,\nwe're looking at two to the n time complexity, but only and space complexity. Alright, so\nlet's look at one more function. See, I gave you this very similar lib function. Notice\nthat in its recursive calls, it does an n minus two. So by now you should be able to\nvisualize what structure like this would look like, say we initially called lib with a value\nof eight, what would the full tree look like? Well, it would just look like this. Notice\nthat it's still a tree, right where every node branches to two children. But this time,\nwe go by twos, right, so if I look for some familiar ground here, I've noticed that from\none node to the next, I do one minus two. And this occurs all the way down to a base\ncase. So we already know that, hey, we can identify this tree as having a height of about\nN over two. So I guess that means that the time complexity is going to be two to the\nN over two power, right, because from one level of the tree to the next, we double the\nnumber of nodes. So that's that two times two times two repeating pattern for the number\nof levels and our number of levels is N over two, right? However, we can actually simplify\nthis time complexity, you can take that n over to in the exponent and simplify that\nto just an N. So overall, we're looking at a two to the n time complexity. And using\nour same arguments from last time, we know that the space complexity for this from the\nstack is also going to be N over two, which simplifies nicely to N space complexity. So\nwe see that overall for our loop function, we're looking at a two to the n time, but\nno space complexity. Alright, so now it's time to look at the big\npicture, we looked at two toy functions of dibben lib. And we saw that the only difference\nin how they made the recursive calls, right did did a minus one and lived in a minus two.\nAnd we saw that despite their differences, both functions had an exponential two to the\nn time complexity, and a linear and space complexity. That being said, Where does our\noriginal Fibonacci function fit in this picture? Well, you can imagine that kind of falls right\nin between, we know that for our fib function, it has two recursive calls for the first recursive\ncall, it makes it does n minus one like did did. But its second recursive call this n\nminus two like lib. So in a sense, it's kind of like smack in the middle, right? If you\nlet me abuse the notation a little bit, and just talking about the time complexity, we\ncan kind of say that the complexity of fib is somewhere between dibben lib, but we've\nalready plugged in some values, right? You know, that, hey, the lower bound that as Deb\nhas to to the end, and the upper bound, that is lib has to at the end as well. So that\nmeans that our fib function must have exactly two to the n time complexity as well, right?\nAll three of these functions have an exponential time complexity. Awesome. So that was a really\ncomplete analysis of why we have this fib function, it's evident that it has a two to\nthe n time complexity and an N space complexity. Right now, the bottleneck that we're experiencing\nis, of course, the time complexity, right two to the n overall, is not undesirable complexity.\nBut do we really have a nice feel for what this really implies? So let's take a look\nat this to to the end. So what's the implication of this? Well, you could kind of imagine that,\nhey, if I asked for the 50th Fibonacci number, that would take you know, roughly two to the\nfifth power number of steps. And so if you punch this exponent into a calculator, you're\ngonna end up with a result like this, this is roughly a 16 digit number. So you should\nhave a vi for you know, this being a very, very, very large quantity. But I think that,\nyou know, to really understand the gravity of what we're really saying here, if we expand\nthis number, that quantity is exactly this. That's over one quadrillion 125 trillion,\nwhich is really, really interesting, right? Because we just asked our Fibonacci function\nfor just you know, something relatively modest, right, the 50th Fibonacci number, and it's\ngonna take quite literally a quadrillion steps to do that. And of course, we can probably\ndo better. So let's work on making this faster. So if I recognize that the bottleneck for\nthis fib function is the time complexity, I know that that comes from the number of\nrecursive calls that I make. So what I want to do is look for any patterns that I see\nin the recursive nature of this problem, let's see a quick snapshot of what the recursion\nfor fib of seven would look like, we know that it looks like this tree just like we\nsaw before. So take a moment, look at this tree, do you notice any interesting patterns\nwithin it? Well, one thing that I noticed is I can see\nthis subtree rooted at three, there, I have two on the left and one on the right. And\nif I look at that subtree, I can actually see it in many different places in this tree,\nright? This subtree rooted at three appears in a bunch of different places, it's very\nduplicate. In a similar way, I can look at other sub trees, let's say I root myself at\nfour, and see that duplicate four sub tree all over the place. And it's even carries\nover for larger values of n like fib of five. So I see that this tree has a lot of duplicate\nsub trees, right? And I want to now draw a connection between this diagram and what happens\nin my code. I know that if I route myself in any of these sub trees of five, I know\nthat each sub tree is trying to answer the question. Hey, what's the fifth Fibonacci\nnumber? I know that the Fibonacci number never changes, right? If I calculate it once on\nthe left hand side, then the answer I should get back on the right hand side shouldn't\ndiffer at all. And so what I want to do is possibly reuse these calculations right? If\nI calculate the Fibonacci number over here, then I should just store that because later\non it might be useful when need to recalculate it over here. I would basically get rid of\na lot of the tree, I wouldn't have to travel down this entire recursive tree rooted at\nfive. This pattern of overlapping subproblems is known as dynamic programming. And so for\nus dynamic program is going to be any instance where we have some larger problem, in this\ncase, Fibonacci. And we can decompose it into smaller instances of the same problem, we\nalso have an overlapping structure. So for us, right, now, I see that I have to calculate\nnow let's say fib of five, twice over to calculate the larger a fib of seven a solution. And\nsomething we're going to be doing a lot in this lesson is really trying to visualize\nproblems in terms of like their recursive nature. So we're going to be drawing a lot\nof trees. And what I'm always going to do is try to really recognize, hey, what pattern\nin this tree is duplicate, right? If I do some duplicate work, if I do some duplicate\ndrawing that I know I can optimize that out later on. But that being said, let's go ahead\nand get to the punch line on this fib function and work on optimizing this solution. Alright,\nnow let me discuss the plan, I think we're ready to actually implement some code that\nwill actually carry that plan out. Here I have our classic bonacci implementation, this\nwas the one that we ran earlier. And it's definitely too slow, right has an exponential\ntime complexity. So I know that overall, when I want to do is kind of capture a duplicate\nsubproblems, I want to store any results that I get that way, if I have to recalculate those\nsubproblems. Later on, I can just use my stored data. And so the trick here, it's a very common\nprogramming pattern, we're going to implement some memorization. memorization is actually\none of the overarching strategies we can use to solve any dynamic programming problems.\nAnd so just look at the name like why is it called memoization? Well, this refers to like,\nmemo, right? So if I have like a memo, and let's say, like real life, it's really just\nlike a reminder for myself. So using memoization, I'm looking to do is store some duplicate\nsubproblems. That way, I can just get those results later on. I think a really neat way\nto implement memorization in JavaScript, as well as many languages is to use some sort\nof a fast access data structure usually be like your hash map equivalent in the programming\nlanguage of your choice. For us, that'll be a JavaScript object. And so our plan is to\nuse some JavaScript object. And so what do I want the keys to be, so the keys in the\nobject are going to be the argument to our function, right. And then the value will be\nthe return value, that we have a nice napping for a argument to the function that is a function\ncall, as well as its return value, right. And so what I can do for my existing function\nis, I kind of just bake in some optional arguments. So my favorite strategy is to do this, and\nassign a memo to be an empty object. So if you're unfamiliar with this syntax, in JavaScript,\nit's pretty useful. What I'm saying is, if I were to call our fib function, and not pass\nin a second argument, by default, it will create this memo, as containing a new JavaScript\nobject that is empty, of course, right? So it's gonna be useful that way, whoever is\nactually testing, my code doesn't have to deal with setting up any memo object. So well,\nI prefer this strategy over here. And what I want to do is treat it as if that, hey,\nthis memo is going to store n as the key and values are going to be just the return values\nfor this function. So what we're going to see us doing a lot in this lesson is at the\nstart, we're going to first check for existence inside of our memo. So let's say that we're\nsomewhere in the middle of recursion, the first thing I should do is kind of add an\nadditional base case and say, Hey, is my current argument n inside of the memo, and if it is,\nthen I can just get the stored value from that memo. And I'm done. So I'm going to do\nan early return here, I'm going to return the value that corresponds to that memos key,\nright, I'm just using the original argument and as a key in my memo, and this condition\nis really just some classic JavaScript syntax, I'm just checking if some key is inside of\na JavaScript object. So really quick, maybe just to warm us up, if\nyou haven't seen that syntax before. So let's say I had some object and had some properties\ninside and we had a name of Alvin, that's me, then it had a favorite color of like gray.\nAnd what I can do is check for an existence of a key in that object. So JavaScript keys\nare mostly strings, right? So I can check Hey, his name in the object. That's true,\nis the fav color in the object, make sure I spell it right. That is also true, I can\ncheck for a key that's not there, like I don't know, his location and the object that is\nfalse. And so here, I'm just using that same pattern, but for and right, which is going\nto be a number, technically, it'd be converted into a string key, which would still totally\nwork here. Awesome. So I have my memo fetching logic, right? I check, Hey, is this argument\nin the memo, but if it's not, I'm gonna have to actually manually do the calculation, which\nis okay, because I know I need to do a subtree at least once. So what I'll do is I'm going\nto take the exact return value, right, so this is my return value in the original brute\nforce. What I want to do is actually store that entire result inside of my memo and the\nkey is course and write, the key you use to access is always just what your argument is.\nAnd I want to complete the original return. So I can just go ahead and return what I just\nput in that memo. So I'm not really changing any return values, or I'm returning exactly\nthe expression that I returned before. But now I'm actually also saving that value inside\nof the memo object. What I want to do is make sure that all of these recursive function\ncalls are accessing the same memo. So what I'll do is I'll pass in that object to both\nof these calls are really important pattern here is, I know that I only receive a new\ntop level metal object, whenever I make a top level call, that's a fit, right, because\nI'm not passing in a second argument over here. However, if I look at my recursive calls,\nI do pass in explicit second arguments. And so they're actually going to receive the same\nmemo object, and it would be like passed by reference, right, because when you pass a\nJavaScript object to a function, you actually receive kind of that exact object, right,\nyou don't receive a copy of it, which is really neat. So basically, I'm giving my function\ncalls a way to sort of communicate to each other, they all have some sort of global information\nto reference across all the recursive trees. So this is looking good. Again, I just want\nto emphasize I only added a new argument over here, I added a new base case on line five,\nthen I added my memo storing logic on line seven, but I didn't change any of the functional\nlogic here. Let's go ahead and run these test cases. And we'll see how our code is doing\nnow. So moment of truth, I'm going to run this file. And notice how blazing fast our program was,\nI still get the results of 813 and 21. And the 50th Fibonacci number is indeed have this\nvery large number. And it basically executed almost instantly. So let's go ahead and head\nback to the drawing board. And really understand you know, what happens when we execute this\nsort of code. Alright, so it looks like we implemented the improved version of Fibonacci\nby memorizing it. And it's clear by running the program that we definitely had an impact\non the time complexity. However, I really don't want us to understand you know how the\nstructure of the recursion tree changes, once we implemented this memoized version of the\ncode. So let's say I want to step through an example of Fibonacci. And let's say I pass\nin a number six. So really, what I'm looking for here is to get back eight, because the\nsix number of the bonacci sequence is indeed eight. So we know that we're going to have\na tree that looks like this, right? This is a tree that would really be the full recursive\nnature. So this is how the tree would look like if I did not optimize it. And what impact\ndo we have by actually adding this memo object? Alright, so let's start tracing through this,\nI know that when I call fib of six at the top level, an important thing to know is I'm\nnot going to pass in some memo object. So by default, my code says it will initialize\nit to an empty object. And the really important aspect of this is I'm going to create a new\nobject just for the top level call. But then that same object is going to be passed down\nto my recursive calls, right noticing line five. And so I'm going to travel down my left\nhand path, right, six calls five, five calls for four calls three, and three calls to,\nand right now I've hit a base case. So I know that this note of two is going to return one.\nSo that's kind of business as usual, right? In the same way, now I need to evaluate this\nother note of one, which is also base case, it also returns one. And at this point, my\nparent of three is actually ready to compute the sum of its children, right. So one plus\none just gives me two. So I just add up those values. And now three is returning two. However,\nlooking at line five of my code, not only is this node going to return to to its parent,\nit's also going to store it in the memo object, right? So the key insight is, at this point,\nI would add a key to my memo of three, whose value is to basically in my memo, I kind of\nread as if I'm saying, hey, the third Fibonacci number is two, right? That in itself is logical.\nSo I can just continue this pattern right? Now I start to evaluate what happens when\nI'm at this note of t, which is also a base case, it returns one. Now my call to four\nis ready to compute, right? It's going to take the sum of its both children. So it's\ngoing to do two plus one gives me three. But of course, it's also going to store that inside\nof the memo, right? It's going to cash that result out to be used later on. So that means\nI make the N my key and I make the return value, the value, right, so I'm going to have\nfour points to three inside of my mental object. And now here's the beauty of this memoized\nsolution. At this point, I need to compute what happens for fib of three. However, this\nis actually going to hit one of the new base cases I added, right? I know that three is\nin the memo object looking at line two of my code, right? It's in the memo object. And\nso I just immediately return the stored value. And so this call to fib of three is just going\nto return the stored value of two. And if I do that, I won't have to travel down the\nfull, you know, recursive subtree rooted at three, right? I don't need to travel to these\nnodes at all. So I already used some stored value in my memo. At this point five is ready\nto return right five will take The summer both with children, three plus two is five.\nAnd it's going to store that in the memo, right? The fifth Fibonacci number happens\nto be five. And now the same thing happens for six is right child. So I have to evaluate\nthis node now. So what is the fourth of bonacci number up, that's actually stored directly\ninside of my memo. So this actually early returns the stored value of three, right.\nAnd again, the key insight is, it will return that stored memo value without having to travel\nthrough that full subtree. And at this point, I can return for fib of six, so I do five\nplus three, that gives me eight, this would actually technically be stored in my memo\nas well. So I have the six of bonacci number as eight and very happy, right? The answer\nis eight. So it's evident that by memorizing our Fibonacci\nfunction, we definitely cut down on the number of recursive calls, we want to visualize that\nwe ended up with this kind of structure. Here in light blue, I have a circle the nodes that\nwe technically didn't need to do the full recursion at, right? So these nodes of two,\nthree and four, for this small example of my initial fib of six, I was able to kind\nof fetch a value from my memo and kind of forego traveling down the recursive subtree.\nSo what do we actually know about the time complexity of this function now? Well, I think\nit's really important that we always try to generalize things. So we just stepped through\na relatively small example of fib of six. But how does this sort of scale? So this is\nthe same tree? Let's see, I kind of tidy it up a little bit. So I know that in general,\nfib of six kind of has this structure. So I want you to take a moment, look at this.\nAnd in your brain picture, what fib of seven would look like if I memorize with with seven,\nwhat would its sub trees look like? Well, it really just looked like this. Notice if\nI route myself at the seven node, its left child is still six, right minus one. Its right,\nCharles, still five minus two. So this still obeys the laws of Fibonacci. If I asked for\nfib of eight memoized, the structure would be like this. And nine would look like this.\nSee the pattern looks like at this point, we're just growing this like memoized chain\nin a linear kind of way. If you're not convinced by you know, that just like structural argument,\nlet's say we were a little more methodical, we know that in this drawing, there is some\ncommon ground, right? Again, like I always say, when you tackle these new problems, or\nnew patterns, try to find some familiar territory, right? Where can I recognize stuff I've seen\npreviously. So I look at this chain, I go 98765432, right. So this goes all the way\ndown in a very, very, very linear fashion, right, just counting down. So I know that\nif I just look at this highlighted chain in yellow, that's definitely just an notes, right,\nwhere n is my initial top level call. So I know that what I have highlighted in yellow\nis just a linear chain right there exactly n nodes. But I haven't accounted for everything\nin this picture, right, some of the nodes are still in white, meaning I need to kind\nof work them into my description of what the shape of this tree is, well, I know that each\nof those white nodes is actually connected to some of the nodes, I've colored in yellow,\nthey're kind of paired off in a way, right? For every node in my ello chain, it has exactly\nkind of one partner node one right hand node on its right hand edge. And overall, if I\nhave n pairs, that means I have to end things overall, right? There are two things in a\npair. So overall, the number of nodes is roughly two n. And I know that that can actually be\nsimplified, right? The time complexity here would be two n, which just simplifies to n\ntime complexity. And using the same arguments we did for our space complexity, we know that\nthe space is going to be n as well. And this is pretty powerful stuff. by memorizing our\nfib function, we brought it down from an exponential time complexity to just a linear time complexity.\nPretty cool stuff, right? All right, I think we're ready to graduate from Fibonacci. And\nwhat we'll do is work on a more involved problem, this one has more of a narrative to it. So\nsay that you're a traveler on a two dimensional grid, you begin in the top left corner, and\nyour goal is to travel to the bottom right corner of that grid. And the rule is you can\nonly move down or to the right, that means you can't move up or to the left, and you\ndefinitely can't move to AGL. That being said, In how many ways can you travel to the goal?\nThat is how many ways can you travel to the bottom rate if you had a grid of dimensions,\nm by n. So the first thing I recognize here is looks like the grid, maybe a rectangle,\nnot necessarily a square, right. And overall, what we want to do is implement a function\nthat calculates this that is our function is to take the dimensions of the grid. And\nso before we hop into sketching the strategy for this one, I think it's really important\nthat we make sure that we actually understand what this question is asking. So let's say\nthey asked us to calculate grid traveller of two comma three, that means they're asking\nus in how many ways can you travel from the top left to the bottom right, of a two by\nthree grid? I will tell you right now that the answer here should be three. Right? So\nthere are three ways to do that. And in particular, you can imagine that we had, you know, a two\nby three grid, so that means two rows, as well as three columns. And we start in the\ntop left, and our end goal is in the bottom right. And so why do we say that there are\nthree ways to get from the top left to the bottom right? Well, they told us in the problem\nthat we can only either take a right move or a down To move, so one of the ways would\nbe going right right down, right, that would bring us from the start to the end. And it\nwould kind of look like this. In a similar way, another path we can take is doing a write\ndown, right? It would kind of look like this. And the only other way would be going down,\nright, right, which would look like this path. And that's why we say there are only three\nunique ways to travel not through a two by three grid. All right, so that's just one example of how\nwe might call a grid traveler, I think what's really important to notice is try to also\nframe the problem as if you were given some relatively small inputs, but I think they're\nreally important case to think about is, what happens if they give us like, basically, the\nsmallest valid grid we can have that is a one by one grid. This one is kind of trivially\nsimple, right? A one by one grid only has one unique way to travel from the start to\nthe end. And it's kind of concise in that if you had a one by one grid, there's really\nonly one position, right? So that means that the start is really the same as the end, and\nkind of you already have the problem solved out the gate, because to travel from the start\nto the end, you kind of just do nothing, right? So the logic here is in a one by one grid,\nthere's only one way to travel from the start to the end, you're kind of already there.\nSo you don't need to take any moves. Something else we might think about is what happens\nwhen one of our dimensions is zero. So let's say someone asked us to calculate grid traveller\nof zero comma one, this is a kind of strange question to ask because for one, if there\nare zero rows and one column, that kind of means that the grid is empty. So I would consider\nthat as there being zero waste to travel through that grid because the grid is sort of invalid\nin a way. In a similar way, if I asked you for traveling through a one by zero grid,\nthere's still no grid to be found here. Right? So it should also return zero. And likewise,\nwhen either of the dimensions is zero, the answer should just be zero, right? If one\nof your dimensions is empty, then there really is no grid. So maybe you're catching on into why I brought\nup those trivially small grid examples, right? Those kind of sound like base cases, which\nwe can use to reconstruct a larger answer. But let's stay grounded and look at another\ngrid. So let's say I asked you to calculate grid traveler of three comma three, right?\nSo I want the answer for a three by three grid. Well, how can we reason that one out?\nAt this point, what I'm looking to do is sort of frame the problem in a way where I can\ndecrease the problem size, usually by mutating the arguments to my function call. So let's\nimagine this three by three grid, as always, I want to move from the top left to the bottom,\nright. So I begin at this position, let's say, and so I know that overall, I have this\ntop level problem of saying, how many ways can I travel through this entire three by\nthree grid, let's say I took one of the moves, right, I can move either right or downward.\nLet's say I made the decision to move downward. Well, if I move downward, then I would appear\nhere now, I know in the future, I can only move to the right or downward. So now it's\nas if my playable area has been reduced to just this shaded region. And if I look at\nwhat I've actually done to this problem, I'm still sort of in the top left corner of some\ngrid, where now I'm really trying to answer the question, hey, and how many ways can I\ntravel through this two by three grid. And this is a really important way that we're\nshrinking the problem size, right, I had a three by three grid initially. Now I have\na two by three grid. And this is really like the relative grid from my current position,\nwe'll say, spanning all the way to the end position. So if you look at this coordinate\nof like two comma three, technically, that is like not the coordinate of the person within\nthe larger grid. This is really the size of the rectangle that the person is trying to\ncover now. Right. So in a similar way, let's say that, hey, I want it to move to the right\nnow. Well, that would also shrink the grid along a different dimension. So I'd appear\nover here. And now I have a two by two grid that I'm trying to solve. And if I keep following\nthis pattern, we're gonna keep shrinking on the problem size over here. Now, I'm asking\nfor a grid traveller of one by two. And finally, if I take a right move over here, I'm asking\nfor grid traveller of one by one, which I know is one of those sort of base case scenarios\nthat I had previously. So that's going to be really useful when we actually implement\nthis in some code. And so the key insight here is when we make a move through the grid,\nthat is when we go right or downward, are basically shrinking the effective size of\nthe playable area, right, our grid gets smaller along one of its dimensions. Awesome. So I\nthink now we're able to see that, hey, this grid traveler problem definitely has some\noverlapping subproblems. Right. Let's say I tried to take more of like a programmatic\napproach, something that we'll be doing a ton, like, basically, for every problem in\nthis lesson is whenever we have a problem that we kind of know is going to be recursive.\nThe move is to really structure it like a tree, right? I want to really visualize this\nbecause I know that if I had a tree structure on pen and paper, I can implement that with\njust some recursive code using some JavaScript, right. So let's say that I wanted to take\nmore of a tree based visual understanding now a grid traveller of two comma three. So\nI know that usually the way we do this is we encode nodes of the tree Using the arguments\nto this function right? Now I have two arguments where I have the number of rows and number\nof columns. Whereas before for something simple like Fibonacci, I only had a single argument.\nSo in the long run, I know that the answer I should get back is three. So just keep that\ngoal in mind. Let's start to flesh out this diagram. So I'm going to start with that top\nlevel, column two comma three. And now I think about how this node can transition to other\nnodes, right? How does the State of my game actually change? Well, I know there are really\ntwo options I can take right? You can either have one child going downward, or another\nchild going the right word, right? Those are the two options based on the gameplay here.\nAnd so if I go down, how does that change of the number I put in the node? That is,\nhow does it change the dimensions of the playable grid area? Well, if I go downward, then I'm\nreducing the number of rows by one. So that means my left child is just one comma three.\nNow, if I had moved to the right, that would mean I'm reducing the number of columns by\none. So my right child is just two comma two. Notice that from parent to child, all I'm\ndoing is reducing a one of the dimensions by one, right, that means you're either going\ndownward or going to the right, and I can just carry over this pattern recursively,\nright. So let's say I'm fleshing out this node now, five, mat one comma three, then\nits children would be just 03. And one, two. And a similar way. If I wrote myself at two,\ntwo, then I have children of one, two, and two, one. But now let's notice something important.\nHere. I've kind of spotted a node where I have zero comma three, remember what we trace\nthrough in terms of the visual drawing? What is this? No trying to answer? Well, let's\nnotice saying in how many ways can you travel through a zero by three grid, but if you have\nzero rows, and there's really no grid to be dealt with. And so I think for this note of\nzero comma three, or really any node that contains zero, we don't need to actually flesh\nout its children. So instead, I'll work on recursively, drawing out these other nodes.\nSo we'll carry over this pattern. At this point, we've actually hit I think all of our\nbase scenarios, right. So if I look at these notes, that have one comma one that was exactly\nlike the affirmative base case, meaning that I know, trivially I can solve the one by one\ngrid. In other words, these function calls are going to return one, right, in a one by\none grid, there's exactly one way to travel from start to end, right, you kind of just\ndo nothing. And on the flip side of that, for all those notes that contain a zero, they're\nalso a base case. But they're kind of like the negative base case, meaning that there\nis no way to actually travel from start to end. So for all of these notes containing\nzero, they should return zero to their parent, right? There are zero ways to travel through\nthat grid. At this point, I just sum up these values at the parent node, right? So I just\nleft these and then I add them together. And I forget what these things are saying, right?\nIf I look at like the node one comma two, above, it is one meaning there is one way\nto travel through a one by two grid, right? You kind of just move rightward. And so I\ncarry this pattern over, I keep adding the children nodes at their parents. And this\ncarries up all the way to the root node. And what do I know, there are three ways to travel\nthrough a two by three grid. So although there's like a narrative, and there's some, you know,\ncute story behind this problem, it's really just a spin off of Fibonacci. And that's going\nto be the case with many of these dynamic programming problems. So we've confirmed that\nthere are three ways to travel through a two by three grid. And there's also some other\ninformation encoded in this tree. I know that whenever I took like a left hand edge in this\ntree that I presented the choice of going downward. And whenever I took a right hand\nedge in this tree, that represented the decision of moving rightward. And so if I have that\npattern in mind, that not only have I been able to count the number of ways that I can\nwin the game, but I also know exactly which combination of moves lead to a solution. One\nof the ways to win this game is to go down, right, right. Another way is to go right down,\nright, and the final ways to go right right down. So we can glean a lot of information\njust from the same tree structure. Cool. So I think that's enough drawing for now let's\ngo ahead and implement this in some code. Alright, programmers, here we are back in\nmy text editor. Let's go ahead and implement this grid traveler function. So you want to\ngo with that recursive strategy. So I'll start by just laying down my base cases, I already\nrefer to the fact that hey, one of our base cases is we have a one by one grid, just go\nahead and return to zero, right? So that's really easy to do. So I'll check Hey, if m\nis one, and n is one, then the answer is just trivially one. Right? Then along with that,\nI also have the base case when I had like an invalid grid. That means if either of my\ndimensions is zero, so I'm using an order here, right? If either dimension is zero,\nthen your grid is empty, which means there's definitely no way to travel from top left\nto bottom right of that grid. Cool. Then my recursive scenario is very straightforward.\nAll I need to do is get the sum between me going downward and me going rightward, right.\nSo if I go Down number n is the number of rows, if I go down that I'm decreasing the\nnumber of rows affected rows, that is by one, but I keep the same number of columns. And\nthen in a very symmetric way, if I move to the right, that means I still have the same\nnumber of rows. So I keep him, but I decrease n, right, I have one less column. So this\ncode is looking pretty sharp, really just some reminiscent Fibonacci style code. Let's\ngo ahead and give this a run. So I'm running a few examples over here. And these are the\nexpected results. In some comments, we'll go ahead and bang this one out, grid traveller.\nCool. So I get the first four results. 1336 looks like it's working just like a charm.\nHowever, for this last example of an 18 by 18 grid, looks like my programs hang right\nnow, it's actually a little too slow to calculate an 18 by 18 grid, so you probably see where\nthis one's heading. Let's go ahead back to the drawing board and really understand a\nwhy this code is fairly slow. Alright, so here we are back in the drawing board, because\nit looks like we hit a wall when it came to our recursive implementation of grid traveller.\nThat being said, I think implementing the brute force solution here is actually a really\nlogical first step. And now we can just focus in on where there is room for improvement.\nSo our first question is, you know, what is the actual time complexity of this implementation?\nWell, I know when I call a grid traveller of two, three, the full tree would explore\nis this right. And like we said, in our Fibonacci, to understand the time complexity here, it's\nreally about to understand the number of function calls we make, which is really the number\nof nodes in this tree. And of course, I want to generalize my understanding for any large\ninputs. So I know that this tree sort of looks, you know binary in a way, meaning that a node\ncan branch to up to two children, which makes sense, because from one position of the grid,\nI have two choices to make, right, I either go down or I go to the right. But that being\nsaid, I need to realize what the height of this tree is. And this one's pretty interesting,\nbecause out the gate, we actually have two input arguments to our function, I'm given\ntwo numbers, m and n. And since this function contains two inputs, it shouldn't be the case\nthat our final complexity analysis actually describes it in terms of those two number\ninputs. So what I'll do is try to recognize the height of this tree. And so I'll just\nchoose some path from the root to the leaf. And kind of in the recursive sense, that means\nI take some path from my top level call all the way down to the base case, and preferably\nthe far this base case. So I know my base cases are either when one of my arguments\nturns to zero, or when both of my arguments turn to one. And I think in general, the farther\nbase case would be a scenario where both of my arguments are one. So here I have a path\nhighlighted that ends in a one one. And in general, I know from one node to the next,\nwhat I do is either decrease the M by one, or I decrease the n by one, it's never the\ncase that I can decrease both of the numbers by one, because that would kind of entail\nthat you're moving diagonally across the grid, which is not allowed in the gameplay. So if\nI can either subtract one from em, or subtract one from n, and overall a path from my initial\ninput down to a space, like one one is going to have a distance of n plus m, we basically\nhad to subtract, you know, n and m from your initial node to reach that bottom level of\none comma one, that kind of tells me the number of levels in this tree, right using the same\narguments as before, it's still the case that most of this tree is going to be binary, meaning\nthat a node branches to two children. And so I have that two times two times two pattern\nfor the number of levels in this tree are saying that they're n plus m levels. So really,\nthe time complexity is two to the n plus m power, right. So still some sort of exponential,\nthat was just sort of the multi variable exponential, because I have two variables of m and n. And likewise, for the space complexity, you\nknow, the space complexity, in general for recursive code is just going to be the height\nof the tree, the height of the tree gives us the maximum stack depth of the recursion.\nIn this case, it'll just be the number of levels still, which is n plus m. Cool. So\nobviously, the limiting factor here seems to be that time complexity of two to the n\nplus m time. Alright, so you probably anticipated the time complexity of this one being exponential.\nThat being said, I think it's really important to still have a nice argument to you know,\nsay what the time complexity is. That way, you can get a massive buy in from your interviewer\nright. So don't skip the steps of trying to draw it out and actually defend your reason\nfor why the time complexity is exponential. But let's try to improve this now. Is there\nany room to actually improve the runtime of this function? Well, here's that same drawing,\nright? Just sort of cleaned up. So I have grid traveller of two comma three, and this\nwould be the full tree. We sort of already know now that I have this recursive tree structure.\nWhat I could possibly do is notice any duplicate work, right? Is there some work I can prevent\nmyself from doing here. So take a moment and really remind yourself of the actions we took\nin the Fibonacci problem. And see if there's any patterns in this tree, probably from the\ngate, you notice that? Oh, I have some duplicate sub trees right? Have one comma two. So in\nthese the two highlighted sub trees in blue, that's sort of asking the question, hey, what\nis the total number of ways I can travel through a one by two grid? That being said, I think\nthere's even more sub trees that correspond to that particular problem. What if you look\nat this far right subtree of two comma one, if you really, really think about it, asking\nthe number of ways to travel through a one by two grid is the same as the number of ways\nto travel through a two by one grid, you're just flipping the rows and the columns, but\nthe total number of ways should be exactly the same. So that's actually a pretty interesting\nway you can optimize this solution. So I can still memorize it. That is I have these duplicate\nsub problems. But possibly a really cool insight we can make in this problem is, you can also\nsort of flip of the arguments. In other words, if someone asked you, for grid traveler have\na comma b, then that would be the same answer for a grid traveler of B, comma a, write the\norder of the arguments technically doesn't matter here, until we can totally encode that\nin our memo object. That being said, punchline here is, we better memorize this one. So I\nthink let's hop to it. All right, here we are back in my text editor. And hopefully,\nthat diagram of how we can improve the time complexity for this one, make some sense,\nlet me go ahead and kill this program still running. And my computer's fan is actually\ngoing crazy. Now it's running the entire time. Let's go ahead and memorize this one to the\nbeauty of you know, solving these dynamic programming like problems is if we have the\ninitial strategy of implementing, like the brute force recursion, and we wrote like a\nvery well formed recursion, meaning that I actually use return values, and I reconstruct\nthe sub solutions all the way up to the tippy top. Because I have a really nice recursion\nhere. memoization is a very like formulaic pattern. So it's going to be almost the same\nstrategy, we did have Fibonacci, even other problems that we do in this lesson. So we're\ngoing to bake in my default mental as an empty object. And then along with that, I'm going\nto add my memo checking logic. So I know we're here in general, and to check, hey, are the\narguments in the memo, right, I need to key into my memory object using all of the arguments.\nNow I have two arguments. And since both of the arguments combined, sort of dictate the\noutput, I need a key that sort of contains both of those in JavaScript keys are either\nstrings or symbols. So for us right now, really, strings is the most relevant one. So what\nI'll do is I'll concatenate both of these integers together. That way, I have a string\nwhich I can key into the object with. And we'll all definitely want to do is also maybe\nseparate them with a comma, let's say, so I'll say like key equals m plus a comma, plus,\nand, and the reason that you probably want like some sort of separator between these\ntwo arguments in your key is to make sure the numbers don't get misinterpreted. So I've\nactually ran into this issue in the past, can you imagine like, if I had a scenario\nwhere, let's say m, was 42. And then we'll say n was a number\nthree. So what I don't want to do is just make my key, something like four to three,\nbecause this isn't going to uniquely identify the exact input argument, right? Because if\nthis was just my key, then I guess I have the same key for a totally separate set of\narguments. If I gave you four and 23, right, both of these combinations of very different\narguments would lead to the same key, they would collide at the same key. So instead,\nI'll prefer to put a comma between them right now I know without a doubt that this key corresponds\nto four comma 23. Right. So that's why I put a separator between them. And depending on\nthe language that you know, you're choosing for interviews, you can find a very similar\nconstruct. Cool. So now I'll go ahead and check, hey, if my key is in demo, then I have\nthe Result Cache already. So I could just return net cash value. So return memo at key.\nAnd then what I want to do is look for my old return value, right? So here's where I\nactually do the manual recursive calculation. Before I return that I want to store it in\nmy memo, using the same key and then return that thing, I just put in the memo just completing\nthe old return logic. Cool. So you've seen this pattern before, I just want to emphasize\na few things. Now it's the second time we're seeing it. memoization, for me, at least,\nis a very, very formulaic thing, right? So I always take the exact expression that I\nreturned previously, and I put that entire thing in the memo object, right? Notice that\nmy key encodes the arguments for this function, right? Mnn. Something that I've seen students\ndo in the past is do like very heavy handed logic, where they try to, you know, check\nif the child call is in the memo. In other words, don't write any pre emptive logic where\nyou check Hey, if you know m minus one And so if you like concatenate those two things\ntogether, don't check if like your child's key is in the memo, right? So imagine like,\nthis was my key right now. Right? don't check if that is in a memo. When you write logic\nlike that, it ends up being very, very duplicate and a little harder to debug, right? Instead\nof writing your function as if it's, you know, reasoning for its children calls, you know\nthat once you actually evaluate those child calls, they're going to cache themselves,\nright, they're eventually going to check this if statement anyway, alright, so don't do\nany like the look before you leap logic, just make the recursive call. That way, every recursive\ncall doesn't like self service, right? So I prefer this way implemented. And with that,\nlet's go ahead and run this code. So I'll give this a shot grid tremor, I still have\nthat 18 by 18 grid, which took quite long last time didn't actually finish while I was\nwaiting. Looks like I'm still hanging here, because I'm actually missing a little bit\nin my code. So take a moment, see if you can spot it, I forgot one really important thing.\nSo I have the logic of checking if my key exists in the memo. And I also have a logic\nof storing something in my memo if the key doesn't exist, but what I failed to do was\nactually passed down the memo object to all of the recursive calls, I want to pass it\ndown over here. Remember, the trick is only top level when someone calls like two comma\nthree for grid traveller, then we're going to initialize a brand new empty object, which\nwill be shared for the rest of the recursion, because it's passed down by reference at this\npoint. So that's a common mistake. Let's go ahead and run this now. Nice. And\nthere we have it. Look how quick our last execution was over here now is the expected\nanswer for an 18 by 18. grid. Cool. So here's what we'll do, it's evident that we definitely\nset up the execution of this one, let's head back to the drawing board to wrap up this\nproblem and really see how we cut down the complexity here. All right, so it looks like\nwe definitely improved the runtime of our function. But I want to really understand\nyou know, what the big O complexity of our improved function is now. So sort of a way\nwe constructively argue for what the new time complexity is, is to think about where the\nvalues of the nodes that will actually have to travel through. So let's say I looked at\nthis example, I wanted to find the number of voice a traveled through a four by three\ngrid, I know in general, there would be a top level node, of course, four comma three.\nBut in general, that refers to m n, right? So I'm trying to think in a very general way\nright now. And so I know when it comes to the other nodes of this tree, they're all\ngoing to sort of at most be four comma three, but then probably be less than that, right?\nThey have like a range of values for the nodes. It's not as if to solve grid traveler, four,\nthree, I would have to solve 530, right, that would be a larger grid. That doesn't make\nsense here, right? I'm shrinking the subproblems, only in this rendition of grid traveler. And\nso if I think about some possible values here, I know that if M is for top level, then all\nof the values for m in the rest of the tree would be from zero all the way up to and including\nfour, right, it's never going to be bigger than four. In a similar way, since n is three\nhere, the only possible values for n in the rest of my tree are zero through three. Right?\nSo roughly Mele, we're a little off by one here, because I have to include zero, because\nwe know that that's a base case, in our edition of this problem. That being said, there are\nroughly n choices for the first number, node, and n choices for the second number in the\nnode. And along with that, we know that we're not gonna have to travel through many duplicate\nsub trees, because we memorize them away. And so I think what I can say here is the\ntotal number of nodes you can possibly have is m times n, and I'll be the number of like\ndistinct nodes, right? Because I have m choices for the first number in the node and n choices\nfor the second number. I know that I'm going to really minimize any duplicate exploration\nthrough the memo object. So the really the implication here is we started out with our\nbrute force recursive implementation, which looked like it was exponential in the time,\nright, it was two to the n plus m time. And then by memorizing this function, we were\nable to bring it down to n m times n, time complexity, which is much faster. Notice that\nthe space complexity stays here, which is really fine, because n plus m is some sort\nof a multi linear function. Cool. So there, we have our nice optimal solution for this\ngrid traveler problem. So key thing I want you to take away from this one is, although\nthe initial narrative and the problem made it seem, you know, pretty specific, and pretty\ndifferent from a previous dynamic programming problem, like Fibonacci, was really the same\nsort of story, the most important thing that we're going to sort of leverage throughout\nin this lesson that we leverage twice already is try to think about your recursive functions\nin terms of a tree, right, I get the most information out of the tree. And then from\nthere, I can use that tree to not only implement a brute force, but to also recognize, hey,\nwhere can I optimize this brute force, that way you can reach for the optimal solution. Alright, so we've gone over two different\nproblems together, and hopefully we're starting to notice how we tackled them in similar ways.\nI think it's about Tammy gave herself some guidelines for solving dynamic programming\nproblems using a memoization strategy. So we'll call this our memorization recipe. And\nthere are three different ways you can go about learning this topic of memorization.\nAnd you might have different recommendations. This is just my particular recommendation.\nSo I think the most important thing to establish if you want to, you know, solve some dynamic\nprogramming problem using memoization, is to stick to to like high level steps, we definitely\nneed to at first just have a solution that's recursive. So just make it work could be slow,\nthat's okay. And after that, we make it efficient. I think this is where a lot of students sort\nof try to take on too much at once. They try to just solve it quickly all in one go. Right?\nTo me, it should be a very separate process, right? First, I look for correctness in my\nsolution. And then once I have correctness, then I look for efficiency in my solution.\nSo when we go through step one, if I just want to get a working solution, then I have\nto start visualizing these problems as trees in dynamic programming problems, the gist\nof them are that we have some large problem that I can break down into smaller instances\nof the same problem. So when I visualize it as a tree, what I'm looking to do is figure\nout all right, in the nodes of the tree, that should represent a problem. And when I draw\nan edge between nodes, that should be shrinking the size of the problem. And depending on\nyou know how your problem is stated, you'll have to figure out that logic, right? In the\ncase of our Fibonacci, it was as simple as we know, we can decrement our values of n.\nBut in the case of our grid traveler, what we had to do was travel rightward or downward.\nAnd once we do that, you want to implement that tree using recursion. What's great about\na tree is it's already a recursive structure. Right? So how do you start to translate that\nkind of tree visualization to some recursive code? Well, you think about the leaves of\nthat tree as your base case, right? Lately, for us, it's been about some small numbers,\nright? So like a grid of size one, or it could also be in the case of Fibonacci, just our\ninitial seed values of n equals one, and n equals two. Now, once you have that baseline\nrecursion, that's going to be your brute force solution. And so you'll want to test it. To\nme this testing step is really important, right? So if you pass inputs into your brute\nforce recursion, it should give correct answers. Although possibly for large inputs, it may\ntake a long time, right? To me, there's a big difference between code that is slow,\nand code that is wrong, right. So here, we should give back valid results, although maybe\nour code is a little slow. Once we have our working brute force solution, making it efficient\nusing memorization is a very, very canned scenario. All we do is start by adding a memo\nobject into the mix. So this memo object needs to have keys which represent arguments to\nour function. And the values of that object represent the return values for those function\ncalls. We know that in our functions, a unique set of arguments should give me a particular\nresult. So we're just having that sort of mapping inside of an object, you need to make\nsure that this object is shared among all of your recursive calls. One way you can do\nthat is to pass them along as arguments. And lately, I've been doing that by giving myself\na default empty object at the top of each of my recursive calls right through my top\nlevel call. And once we do that, we need to add a new base case into our code. So I'm\nnot going to remove any of the old base cases, from my brute force solution to me, I'm just\nadding a new base case that captures the memo. In other words, if my arguments are in the\nmemo object as a key, then I'll return the stored value, I refer to that as like my memo\nfetching logic, right? Looking up some stored value in my memo. And beyond that, the only\nthing we need to do is implement our memo storing logic. And it's as simple as going\nto exactly where we had our return values in our function. And then we just make sure\nthat we add those return values into our memo object before returning, right, so I always\nlook to the exact return expression, and just write some code around it, right storing that\nresult into another mental object before I return it, right? Step two is actually very,\nvery easy to implement, meaning it's very easy to memorize a brute force solution, it's\nreally coming up with the brute force in the first place, that kind of feels more difficult.\nSo as you're learning and practicing memorization for these dynamic programming problems, I\nhighly, highly recommend you stay very methodical, and follow these steps, right? Don't try to\nefficiently implement an algorithm from the get go get a brute force working solution\nwith recursion, and then implement it using memoization. Afterwards, right. And as you\nget more practice with this technique, soon, you'll be able to do everything all in one\nswoop, but I don't recommend that until you've definitely finished this course. So we'll be sure to follow these rules for\nfalling problems. Alright, so I think it's tempting increase a difficulty and we're going\nto know Their dynamic programming problem. So let's work on this can some function, what\nI need to do here is take in a target some as an argument, as well as an array of numbers\nby function needs to return a Boolean. So true or false, indicating whether or not it\nis possible to generate the target some using some numbers from the array. And along with\nthat, we have some constraints here, we can totally use an element of the array as many\ntimes as we want. And we can also assume that all input numbers, so the target sum as well\nas the numbers of the array are non negative. So let's try to understand what this question\nis asking. Let's say I gave you this example case. So it looks like our targets, I'm a\nseven, and the array of numbers is 534, and seven, here, the response should be true because\nit is possible to generate seven, by adding some amount of numbers from the array, one\nway you can generate seven is by just doing three plus four, another way would actually\nbe to just take the loan seven, because seven is actually a member of the array. So it's\ndefinitely possible to generate seven using, you know, some amount of numbers from the\narray. So that's why we return true. Let's see, I gave you another example. Let's say\nI gave you a target sum of seven again, but I gave you a different array of just two and\nfour, this is actually going to return false, because there is no possible way that combinations\nof two and four can actually sum to seven. Cool. So that's really what the question is\nasking. Now let's try to think about how we can frame this problem of recursively. Right?\nHopefully, you've already gathered in your mind. If we have a smaller amount of targets\nsome, then they'll tend to be a smaller, easier problem than a larger number for targets.\nAll right, so let's start to think about the recursive structure. For the first example,\nwe know in the long run, we should be able to derive the answer true from the string\nthat we make. So like, we always say, we should encode the arguments to our function into\nthe nodes of our drawing. That being said, since in the problem, they told us that we\ncan reuse an element of the numbers array as many times as we need, I'm just going to\nomit that from the node drunk, because basically, every node every function call is going to\nreceive the same array. So I'll just list the target sum in every node. So I start with\nseven, and I have to think about how I can transition to other nodes, right? How can\nI shrink the size of this problem? Well, I know that I only have, you know, four options\nI can take right have an option for every element of the array. So basically, if I'm\nat this seven node top level, I can branch to some children, and sort of the rule for\nmy transition is you can either take a five, take a three, take a four, take a seven. And\nif I actually take you know those elements as a choice, they are going to decrease my\ncurrent target sum. In other words, seven minus five is two, seven minus three is four,\nseven minus four is three. And of course, seven minus seven is zero. So notice, we have\na very particular rule from traveling from a parent node to some child, I can just carry\nover this pattern. However, we have to watch out right, so let's say I tried to flesh out\nthis note where my target sum is two, if I look at the options I have, right, I still\nhave the options of 534, and seven, however, none of them are really compatible with this\ntarget sum of two, right, what I don't want to do is take any of these choices, because\nthat would kind of give me a negative target sum. So I can't really flesh out this note\ntwo anymore. That is there are no valid options for this node. However, some of these other\nnodes like this for to have valid options. So what I can do is take a three or take a\nfour, and of course, I get a one and zero respectively. And I'll also do this for the\nthree over here, right? For this three node, I can only take a minus three as a choice.\nCool. If I look at all of the nodes that I have, now, I like the leaf level, it looks\nlike they all sort of bottom out at a base case, that is there is no further choices\nwe can take. And I also noticed that some of my nodes have a zero in them, if I look\nat the notes that have a zero in them, they actually are a really nice base case, because\nI basically have found that I can generate to the original target sum right away, you\ncan kind of understand the base case, when the target sum is zero is you can always generate\na sum of zero by taking no elements from the array, right? So these zero nodes are trivially\nsolved. And to me, they should return a true backup to their parent, right. And it's sort\nof on the flip side for all of my nodes that are not zero. And they also can't break down\ninto any further nodes. Those return false, right? Because they kind of have a leftover.\nAnd I know there are no possible options I can take to reduce that further. So all of\nthese other nodes should return false to their parent. And remember what this question is\nasking, right? It's really asking, Hey, is it possible at all to generate the original\ntarget sum? And so the logic is when these values these Boolean values return to their\nparent, the parent should just check if at least one of them is true. And if at least\none of them is true, then that parent should also return true. And if I look at this for\nnote, have a tree above it, and that sort of answers the question, Hey, can I generate\na sum of four using elements of the array and you totally can because if you look at\nthe elements of the array, there is exactly one for so I can just take that into my son.\nSo I'll be sure to bubble up, you know all these Boolean values to their parent. And\nagain at the parent will just make sure that at least one of the values that gets back\nis true. And so if at least one of them is true, then the parent itself will also return\ntrue. So very reminiscent of some like Fibonacci bubbling up pattern as well as our grid traveller,\nexcept now we're kind of adapting this for some boolean data, but it's really the same\nstructural understanding I have. Cool. So that was an example where we said true, right,\nthere is a way to generate the sum. Let's look at another example. Right? How do we\nknow the flip side. So if we have this example, right, seven, and an array of two, four, in\nthe long run, that's gonna return false, right, there's no possible way you can generate that\ntarget sum of seven. So the tree for this example would look like this. So this is a\nfull tree. Notice that all of the leaves get as low as one, but they can't be broken down\nany further. Like we just said, in our last sketch all of these ones, since they can't\nbe broken down any further, and they haven't reached zero, they're going to return a false\nup to the parent. And I know that if I bubble up all these false values, of course, a top\nlevel call will also return false. Right? So it looks like a key insight we have for\nthis problem is, if we find at least, you know, one base case that returns true, I know\nthat I can sort of stop early and just return true all the way up to my parent, because\nthey're not really asking like, how many ways can you generate the target sum? They're just\nasking, Hey, yes or no, can you generate the target sum at all. So that's gonna be a really\nnice way to implement this code. I think we're ready to jump right into the code. So let's\ndo it. Okay, so let's go ahead and implement this can sum function. So since we're going\nto solve it recursively, I think a good starting place, as always, is to maybe handle some\nof the base cases. So when we drew up the tree, I noticed that one of our base cases\nwas when the target sum reaches the value zero, right? If our target sum is zero, then\nwe have like, basically trivially solved the problem, because you can definitely always\ngenerate the target sum of zero by taking no numbers from the array, right? So I'm going\nto return true. If ever I reach a zero, then Apart from that, I think let's go ahead and\nwork on the recursive scenario. So I know that I need to establish some logic where\nI make a recursive call or a branch for every element of the numbers array. So what I'll\ndo is I'll iterate through that array of numbers. So I'll use some for let of syntax we'll say\nlet num of the numbers, right. So if you're unfamiliar with the syntax, all it does is\niterate through every element of the array. So for example, let's say I just called the\nfirst example for can sum of seven, and an array of two, three, if I just console dot\nlog, the num, I'm just going to see the elements printed out of two, three, right, so let's\ngive this a quick spot check. Nice, so just iterating through every number of the array,\nno tricks here. But now that I have that number, I need the branching logic. So remember, the\nlogic we use for transitioning from one node of the tree to the next, what we did was subtract\nour current choice of number from the target sum, and they basically gave us like the new\ntarget sum. So I'm going to express that and maybe some variable, so I'll say, Alright,\nI'm going to generate the remainder by calculating the difference between the target sum and\nthe number, right, so I'm just subtracting the number from my target sum, that gives\nme my new remainder, which becomes a target sum. Right? So at this point, I think I need\nto call recursively on can some of our pass in this remaining quantity? It doesn't need a second argument, still,\nI'm still gonna pass in the same exact numbers array. So I'll still pass in numbers unchanged.\nI think that you know, the fact that we pass in the same exact numbers, right, it's pretty\nconsistent with the way they stated the problem, because we can totally reuse the numbers of\nthe array as many times as we like. Cool. So now that I'm using our function, again,\nI'm making the recursive call, I want to think about what this call will return. I know at\nany point in time, my can sum function is going to return Boolean. And what's great\nabout boolean data is there's only two possibilities, right, either true or false. So I think, based\non what we said about the tree was, if this call, if that returns true, then I can just\nultimately respond with a true right now. So I'll write it like this. So this is saying,\nAll right, if we figure out that it is possible to generate the remainder now using numbers\nof the array, then I can return true for this larger problem of target some, right? So if\nI find at least one way that works out, then I'm going to do an early return true. And\nthe really important pattern here is we don't want to write the LS and then return false.\nInstead, we'll want to return false after the for loop. And so here's the reason why\nyou want to return false after the for loop. I only know that after I attempted you know\nall possibilities and I found that none of them worked out Can I actually say that it\nis impossible to generate the target some Right, so I need to make sure that this for\nloop tries all possibilities of number. Before I can say false, the target sum cannot be\ngenerated. That being said, there's one thing we should add to our code. So if you look\nat line six, all right, I'm subtracting our choice of num from the target sum. And that\nmeans that sometimes the remainder might become negative. So remembering our tree structure,\nwe made sure to sort of return a false whenever we had a sum note, I didn't do any branching.\nTo kind of account for that I can kind of bake that into another base case. But this\ntime, make sure it doesn't return true. So I'll say, you know, if my target sum is negative,\nif it's less than zero, then you've gone too far. And you can just return false. Here,\nit's safe to just automatically return false if your target sum hits something less than\nzero, because you've gone too far. And there's really nothing else you can add from the numbers\narray to ever fix that negative target sum. Remember, they told us in the problem, that\nyour numbers are always going to be provided as positive numbers or just zero, right? So\nlet's go ahead and give this a go. So I'll try all of these examples. And we'll see what\nwe get. So I expect a true true false, true, false. Cool, so looks like a few of them are\nworking right, it looks like the first four are working totally fine. But looks like on\nthat last example, my program still running. And if you notice, I chose a pretty large\nvalue for em. So kind of like we expect this solution has correctness. But it possibly\nlacks some efficiency, it looks like it just finished, the definitely took way too long.\nAnd so it's a very interesting example of a slow input to can some, because for one,\nthe length of the array is pretty sure I only gave two elements here. But it seems like\nthis number as a target sum really affected the runtime. So we'll do, let's head back\nto the drawing board, and talk about the complexity of this baseline solution. Alright, so we\nimplemented the brute force for our khamsum. But obviously, now we want to make it a little\nfaster. But before we kind of just jump into memorizing the solution, let's at least describe\nthe complexity of our current brute force. So let's try to visualize this example. So\nI have a target sum of eight. And my choices for my numbers are two, three and five. In\nthe long run, they should return true, the visual for the full tree would look something\nlike this, notice that it's fairly large tree of forbs and relatively small inputs, right,\nI only have a target sum of eight, and only three choices. So let's try to describe the\ncomplexity of this, I'll sort of generalize the shape of it, get rid of those numbers.\nSo this is the overall shape of the tree. And I know I want to describe my complexity\nin terms of the input to my function, this function has two inputs to the right, I'll\nsay that M is the size of the target sum, and n is the length of the array I'm given,\nI know that both of these arguments definitely have an effect on the dimensions of this tree.\nSo like we did in all of our other examples, I'll start by maybe analyzing the height of\nthis tree, that is a what would be the maximal distance from the top level call to a base\ncase, or in the structure of the tree, what is the maximal distance from the root of the\ntree to the farthest leaf. So if you sort of imagine that, we have\nm as the root of the tree, imagine that along the left hand path, we just did a minus one\nall the way down, right? So we kept taking a minus one, right? In the worst case, maybe\nthere's a minus one present in our a numbers array. In the worst case, the distance from\nthe root to a base case would be exactly m, because you have to subtract one m times,\nright. So I can basically say that the height of this tree is M. And it kind of like we\nsaid in our other problems, that means that the number of levels is m right. So now that\nI've identified the height of this tree, the move is now to identify the branching factor.\nThat is, how does the number of nodes change from one level to the next. Remember that\ninitially, we described this particular tree example is having numbers array length of\nthree. And you'll notice that the maximum branching factor is exactly three or in general,\nN, right? because n is the length of the array. So for example, if I had three numbers in\nthe array, then a node would have at most three children, right? Cuz you have three\noptions to take. We've seen this pattern before I have n levels, and from one level to the\nnext, I would multiply the number of nodes by n, right? This is the same thing as saying,\nHey, we take n and multiply it by itself, m times. And this would definitely give us\nan exponential complexity, right in particular, and to the M time complexity, like we always\nsay another great thing about this type of diagram is we can also derive the space complexity,\nright? So what would be the space used by the call stack, it would really just be the\nheight of the tree, which we already described as M. So overall, our brute force is looking\nat an end to the M time complexity, and M space complexity. So now that we actually\nhave you know those concrete numbers for our complexity, let's go ahead and focus on how\nyou can truly improve this So here's again, the drawing for this particular example. It's\na fairly large one. And typically, you know, when you're trying to notice where there is\nroom to be optimized, you might have to give yourself a sufficiently large example to see\nthese scenarios. So in this example, I do have overlapping subproblems. And in the context\nof my tree, that means I have duplicate sub trees. So I can look at possibly this subtree\nrooted at three, notice that the root of that subtree is trying to answer the question,\nHey, can I generate a target sum of three using the array? And of course, once you find\nthat answer, that answer is never going to change for your target sum of three, right?\nSo I know that all three of these sub trees are trying to ask the same problem. And so\nwhat I'll do is I'll just cache those results in my memo object like we always do. Let's\ngo ahead and work on that. All right, welcome back to my code editor. And same stuff, different\ndays. Let's go ahead and minimalize. This can sum function, right. Once we've established\nthe brute force through the recursion, then memorization is pretty formulaic. Right? Alright.\nSo we'll start by just baking in our memo object like we usually do. So if someone calls\nour function without a third argument that is like a top level call, we'll be sure to\ngive them a new object. And I'll, before I forget, be sure to pass down this memo object,\nI'm going to make sure that every top level call and it's recursive tree shares the same\nmemo object. But now I need to figure out what what should I use to key into the memo\nobject. So here I have two arguments of my original function are I have targets summon\nnumbers, what I want to do is try to notice, you know, which of these arguments is actually\ngoing to directly impact the return value. So I know that through the recursive calls\nlike this call over here, the numbers argument doesn't change. And so if it doesn't change,\nthen right now, it doesn't really affect other return value. So I'd be okay to just use the\ntarget sum as the key into this memo. So we'll go ahead and do that. So I'll check if my\ntarget sum is in the memo, that I've seen that sub problem before, so I can just return\nthe stored value. Cool. And now I have my, you know, memo fetching logic. But now I need\nto actually store things in the memo. And the trick is, what I want to do is look at\nall of the return values that were not base cases, and I need to now store them in my\nmemo. So I have to return values here, right, these two lines, lines, 10 and 14. And so\nI need to store data into the memo for both of those lines, it's as simple as quite literally\ngoing into your memo using your key, so target some, and then assigning the value we just\nreturned. So I'll just write it like this. And this\nis going to be sort of a hard and fast rule, you can always use our for a memorizing a\nbrute force recursive function, right. So I'm just going to take exactly the lines or\nthe expressions that I returned in the recursive scenarios. And now just store them in the\nmemo. Cool. So let's go ahead and give this a shot, this code is looking pretty good.\nAnd remember before this last call with an input of target, some 300 took notice will\nbe long. But I think now when I give this a shot, right, it finishes really quick. So\nthis is going to be a nice optimized solution for cancer. Really, most of the work of this\nproblem was done in the brute force. And then afterwards, it's really just a minor adjustment\nto make it efficient. So to wrap up this problem, let's go ahead back to the drawing board and\ntalk about the improved complexity. So we definitely memorize the heck out of that code.\nBut let's recap by just understanding what the new complexity is. So again, we're saying\nthat M is the target sum, and n is the length of the array. Initially, we said that our\nbrute force solution had an end to the M time complexity, which is exponential. And actually,\nonce we memorized it, we really cut down on that complexity, we brought it down to n m\ntimes n type complexity. And so here we say that the memo is complexity is now m times\nn, because of the memo object, right? We know that the value of the nodes in the tree are\njust going to be values up to m or their m different possible values we can have in a\nnode. However, it now since we are able to cache values or cache results inside of the\nmemo object, I'm never gonna have to re explore a subtree before M. That being said, I select\nthe branch and times for each of those nodes, right. So overall, I have m times n nodes. So hopefully that can some problem made some\nsense, because we want to do now is actually carryover a lot of that knowledge to solve\nthis new Howsam problem. So this problem is very similar, it still asks us to take in\nsome target some an array of numbers, but this time around, we want to do is return\nan array containing a combination that adds up to exactly the target sum. And if there's\nnot any combination that actually leads to the target some, then I should just return\nnull. Along with that, if there are many possible combinations that can reach the target some\nthat that can return any of those. So you probably Already recognizing that this house\nsome problem is very similar in logical structure to the can some problem right? instead of\nreturning a Boolean instead now I want to return exactly the combination of elements\nof the numbers array that leads to my target sum, so it's a little more involved. That\nbeing said, let's take a look at some examples to make sure we're on the same page. So let's\nsay someone asked us to calculate how some and our target was seven, and our array of\nnumbers are 534, and seven. So there are actually a few different combinations that can give\nyou your target sum of seven. One way would be to take three plus four, that's one possible\nanswer, another possible answer would just be returning an array of seven. So no matter\nwhich combination array you return, it'll be considered correct in either scenario.\nLet's say I gave you another example, where your target sum was eight, and your choice\nof numbers were two, three and five. One possible solution for a combination is two plus two\nplus two plus two, right? So I returned that in an array, another combination would be\njust three plus five, notice that no matter what we're always looking to get back in array,\nif it is possible that our target sum can be generated. But let's look at the flip side.\nLet's say that we were given this input, so I have a target sum of seven, and my array\nof numbers is just two and four, the first thing we notice is it is not possible to actually\ngenerate the target sum of seven. Like they said, the problem in this scenario, what you\nwant to do is return Nome sort of symbolize that, hey, it's not possible to generate any\ncombination that leads to the target sum. All right, I think it's important that we\nthink about one more scenario. So let's say that I was given a target sum of zero. And\nwe were given really any array of numbers. In this case, I just gave us one, two, and\nthree, we already know that in our previous problem, we had to return a Boolean result,\nwe use the target sum of zero as a base case. And so what I want to think about now is how\nis the target sum of zero just trivially solved? Well, if I want to know the combination that\nsums to zero, and that's really just the empty combination, right. So I think the logical\nresult here is to return an empty array, when your target sum is zero. Remember that an\narray represents a combination. And if I have an empty array, that means I take no elements\ninto my combination, right? If I summed up all the elements in that empty array, it would\nindeed have a sum of zero. So that's going to be a really important facet that we need\nto encode into our logical tree that we draw next, as well as our code, right. So let's\ntake a look at how we can structure the tree and try to take a step toward really understanding\nhow we can implement it in some code. So let's say we're stepping through this particular\nexample of target sum of seven, as well as an array of 534, and seven. So the full tree\nand really the same tree that we drew last time would look something like this. from\nthe get go, I see that I have some scenarios or some nodes where I reach zero, which means\nthat it's definitely possible to generate the target sum. That being said, How can I\nget back a valid result, right, so I need to return an array. So you sort of reframe\nthis problem in that, all right, all of these base cases that have a target sum of zero,\nthey are trivially solved because they are combination would just be the empty array.\nRight. So for now, I'll just kind of trace through how one of these base cases would\nreturn. So I know that this particular zero is going to return an empty array. And like\nwe always say, when it returns, it's really returning that information to its parent,\nright. So this array sort of bubbles up to its parent. And now what I want to do is actually\nmanipulate this return value, I want to add something to it. So I want to really put the\nnumber that brought me to that zero in the first place. And that would really be the\nchoice of four. So notice along the edge, I have them labeled with a minus four, meaning\nthat, hey, I took a choice of four. And I want to actually add that choice into the\ncurrent array. So I'll just really push it into the right, of course, I actually don't\nneed a negative sign that was just for the sake of understanding the math here. But now\nthat my call to how some of four is returning an array of four, that array bubbles up to\nits parent. And of course, now I need to push that edge that I took, which would be that\nthree, so that three gets pushed to the rear as well. And if I look at what I'm seeing\nright now, it looks like above the seven, we have an array of four, three, which makes\nsense, because you can totally generate a target sum of seven by doing four plus three,\nawesome. So four comma three would be a valid answer in this particular problem. But like\nthey said, you could return really any valid combination if one exists. So let's say we\nretrace through this far right base case, we know that this zero is going to return\nan empty array, that empty array will be returned to the parent. But we also have to add the\nvalue according to the edge, right? So I would press seven in this array. And that makes\nsense because I could generate the target sum of seven by just summing up a loan seven.\nSo that's still good to go. So I'm feeling pretty good about how we can return a valid\ncombination if one exists about let's say, there are some options that we take that don't\nwork out. So for example, let's say we explored this node first, right? This was the first\nbase case we had and logically in the space of our code, it really would be right. So\nI know that this node can't really branch out any further. So it's sort of a dead end.\nThis is a node that should work Turn no meaning that, hey, there is no way I can generate\na target sum of two using elements in the array. Or if you look at the elements of the\narray, they're all too big, right? So I know that this base case is going to return null.\nBut along with that, if you look at the next base case, we would hit it would be this one,\nwhich also returns Now, if you look at the next base case, to the right, that's actually\nan affirmative one that should return an empty array. So it's kind of reasoned out how these\nreturn values should be considered at their parents. So I know that both of these values,\nbut to the left of the node four would return, right, so it kind of bubbles up a little bit.\nBut for the array on the right hand side, I would also have to push the edge that I\ntook, which was a four in this scenario. So now I'm sort of comparing you know, the nollan,\nthis four, or really, I'm comparing all of the branches that I take from a node. And\nif at least one of the branches gives me back an array that I know that it's possible, right?\nSo basically, in this scenario, the array of four actually wins out over the null, right,\nI know it's possible to generate a four. And I'll just continue this process, right, now\nI can return these two values to its parent. So let's I'm considering them at seven. In\nthe same way, I would have to add the edge I took, which would be a three on this array.\nAnd then from there, I know the array would always override the null, right? So I could\njust ultimately return this four comma three. And a really nice pattern in this code is,\nas soon as we find a winning path through the tree, or that is we find a combination\nthat creates a target sum, we can actually return early because we don't need to really\ntravel through the rest of this tree. We don't need to explore any other options because\nthey're happy with at least one combination. Right? Awesome. So again, to recap, the punchline\nis for this tree, I have the information for a combination, encoded as a path through edges\nof this tree, right, so I've looked at this path I have highlighted in yellow, I see that\nI took a three followed by four. And that eventually led to a zero. So I know that one\nvalid combination would be four comma three. All right, at this point, I'm feeling pretty\ngood. Let's go ahead and work on the code for this now. All right, here we are back\nin my code editor, let's work on solving the house implementation. So the codes going to\nbe pretty similar to the cancer problem, it's the really the whole point, we're just kind\nof going to finesse the return date over here, we're gonna have a very similar base case,\nlike we said, in the tree diagram, whenever we have a target sum, that's zero, we have\ntrivially solved the problem, because I could just return an empty array. And a similar\nway, what we can do is also have a separate base case, if our target sum ever reaches\na negative quantity, then I'll just return null. That's because it's never possible to\ngenerate a negative target sum, right? Remember, in this problem, the array of numbers is only\ngoing to be positive ones. Cool. We ended up writing very similar base cases for our\nlast problem, except now instead of returning true, we return an empty array. And instead\nof returning false, we return nil. Nice. So let's go ahead and get the branching logic.\nRight, how do I want to make my recursive calls, I'm going to need to make a recursive\ncall for every element of the numbers array. So I'll say, let num of numbers, we'll just\niterate through every number of this array. And I'll go ahead and do the same logic as\nlast time. So I'll subtract the number from my target sum, they'll give me my remainder,\nright? So remainder equals target sum minus mine number. Cool. So this remainder is now\nwhat I want to find the combination for, right? So here, I would make my recursive call. So\nhow some pass in the remainder. And the second argument will stay exactly the same. I'm going\nto pass along the same exact numbers array. I don't need to remove anything from the numbers,\nright? Because they tell us in the problem that we can reuse the elements however we see fit, right. Cool. So now I\nneed to really think about what type how some returns. So this problem is interesting, because\nwe basically have two different types, right, we could get back in array of some elements,\nif it is possible to generate the remainder, or we can get back know, when it's not possible\nto generate the remainder. I think no matter what I get back, I'm just going to save into\na variable. So I'll say console, this is the result for the remainder. I'll call it remainder\nresult. Cool. So I know that in the context of like how I thought about this logic in\nterms of the tree, I wanted to basically do an early return if I found a valid combination.\nAnd so I'll go ahead and check you know, if the remainder result is not No. So the implication\nif I enter this if statement, that means that it is possible to generate the remainder.\nAnd so what I can do is just return early and I can return of basically almost the same\nremainder is also the same array. However, I need to make sure I include the element\nthat I took recall from the diagram, whenever we had a recursive call that returned in array,\nthe parent had to also add the number that it took transition to that recursive call\nin the first place, right. So in the context of the tree, I had to put the labels of the\nedges into the array here. means I have to put the num into this array. So some syntax\nI can use for that. So use some spread operator. So I can copy all the elements of the remainder\nresult into this new array. But I'll also add on the number I just took, right. So all\nI'm doing in this return line is, I'm returning basically the same array that I get back from\nmy recursive call, with the number added to the end of it. Let's say you're unfamiliar\nwith this syntax, I can preview it really quick. It's pretty neat. Let's hop into the,\nyou know, repple. So let's say I had some array, let's say it was this array of just\na, b, c, sort of an isolated example, you can use the spread operator, which is the\nthree dots here to like unpack an array. And you can sort of say like, new array equals\nbracket. So this gives me a new literal array, I can spread out the elements of the old R,\nright? So if I do that, the new array just has all of those same elements, vi, capitalize\nthat and properly, cool, we can extend that syntax, right. So I still have that array\nof ABC. Let's say I had another variable, we'll call it other array, what I can do is\ncreate a new literal array, copy all the elements from our using the spread operator. And then\nI can comma, separate any additional things I want to add while I'm here. So let's say\nI added a z. So if I look at my other array, now, it contains ABC, and also this new element\nz. So it's all I'm doing on this slide, right? I'm returning the same combination, that my\nrecursive call gives back with the number that I took are added to the end of it. Cool.\nSo what's really nice about this code is it's very reminiscent to our previous code, because\nwe have an early return. So if I find at least one way, to generate the target sum, I can\njust go ahead and return that first way that I found, right, they say we can return any\nvalid combination here. But let's say this for loop finished, and we never found a valid\nway to generate the target sum, then after the for loop, you can just return null, because\nit's not possible not to generate the target sum, apparently. Cool. So this code is looking\npretty good. I think let's let's give it a shot. It goes without saying no, sometimes\nthe remainder right will become negative. But we already handled that with this nice\nbase case, right. So let's test this code. So I already have some example outputs over\nhere. So looks like our first few examples are working. Obviously, our last one seems\nto take quite a long time. So I'll just kill this program early. But before we talk about\nhow to optimize for this larger example over here, if you look at these other examples,\nwhat I can see is this array of 322 does add to seven. So that's looking good. This array\nof four, three, also adds to seven. So that's good. We already saw that this example of\nseven and two for now, that's your return No, because it's not possible generate that\nsum. And it looks like the array for the eight example is also good to go. So notice here,\nthere are also some other arrays that we could have returned and would still be considered\nvalid output, the exact combinations that we get back are really just dictated by the\norder that we happen to iterate in the array. So for example, let's say I switch things\naround here, like I did 352, it's really the same array, just in a different order, we'll\nprobably get a different answer for that particular one, right? So I'll run this now, notice I\nget 233. But either case, that still sums to eight, so we're totally good to go. Awesome. They bring this\nback to the original code. And yeah, it seems that now the limiting factor seems to be the\nspeed of our solution, right? We've been here before. And so let's go ahead and talk about\nthe complexity of it. So we know that the time complexity for this is almost identical\nto what we did in the cancer problem, which is conveniently over here. But sort of refresh.\nBy now you recognize that all right, the time complexity should be described in terms of\nlike the recursive tree, let's let's lay down the foundation. And we already know that M,\nwe're going to call the target sum. And let's also say that n is the numbers dot length.\nCool. And so if I think about the number of recursive calls that I'm going to make, it's\nreally the same as last time, right? So I'm going to say that, hey, the time of this function\nseems to be Oh, and I have an exponential, the base of the exponent is the branching\nfactor, which is the length of the array. And then the depth of the tree would be the\nexponent, which is just m, right. So this was the same time complexity as last time\nfor a brute force writes M to the M power. However, it looks like we have some additional\ntime that we consume in this function really coming from this expression, right. So if\nI look at line nine, in particular, this line creates a copy of an array. So that will actually\ntake sort of a linear number of steps to copy over every element of an array right. So I\nwill have to consider the cost of this operation. It sort of under the hood like iterates through\nthe remaining result, I know that the maximal length of the remainder result I can get back\nwill be at most m, right? Remember that remainder result in the worst case is going to be in\narray, the longest that array could be is exactly the target sum, right? Imagine that\nwe had the most simple, you know, sort of a combination to generate the target sum.\nIf it was just a bunch of ones, right, my target sum was 50. And I had an array filled\nwith one, then I can just do one plus one plus one plus 150 times to generate the target\nsum. So in the worst case, this copying operation will take m steps, I need to do that for every\nrecursive call. And so if I have this many number of recursive calls, in addition to\nthat, I do an M operation, you just multiply that M, right. So the time complexity for\nthis brute force so far, is n to the n power times M. Really, the thing we want to optimize\naway is this exponential part, right? So I really want to focus in on that. But while\nwe're here, let's go ahead and talk about the space of this brute force. So the space,\nthere are things to consider the terms of the stack space, it's going to be the same\nas last time, so it's going to be o of m. But think about any other space I use up I\nguess you should also consider the array that you return back, whoever we know that we're\ngoing to return back like the first array that we find all the way back up to the top\nlevel call. And the combined length of all of those arrays that we return is really just\ngoing to be in worst case, M. Right. So I would still say that the space complexity\nfor this function is just m right now. Cool. Obviously, let's work on optimizing this time\ncomplexity. So this was the brute force. So brute force. And you guessed it, and there\nis definitely some people get some problems in this brute force. So we'll just memorize\nit away. So very formulaic stuff, most of the work is always the brute force. So I'll\nstart with my empty mental object. And like we always say, we'll use the target sum as\nour key. So if I've seen the target sum before, that is if it's in the memo, then I'll return\nwhat I have stored in the Mo. And at this point, what I want to do is make sure I pass\nalong the same memo object to all of the recursive calls. That way, they can benefit from any\ninformation or any sub problems that I worked on over here, right in this stack frame. Cool.\nAt this point, I need to make sure that I take all of the return lines that I had before,\nand I store them in the memo, right? So the trick here is I can say, memo of target. So\nI'm going to save that array. So notice that now the values in the array, or sorry, the\nvalues in the memo object are going to be arrays, because that's the return value of\nthis. It's either going to be an array or not right? So I'm just going to complete this\nreturn value by returning what I just put in the memo. And in a similar way, I also want to memorize\nthis late return. So we'll also be memo of target sum equals No, I can just still return\nNo. Cool. So with that change, right, it's very, very straightforward change. Let's see\nhow this does. Now. I know that for this last example of how some 300, it is not possible\nto generate the sum of 300 using just sevens and fourteens. So should we get an all for\nthat one. So let's give that a shot. Nice. And there, we have a really quick running\na know of that very last example. So we definitely had an effect on the runtime here. Let's talk\nabout how we changed up the complexity of this code. So that was a brute force. Let's\ntalk about the memoized version. So it's good with the time over here. So we know that in\nterms of the time complexity from the number of recursive calls that we make, it's the\nsame story as our last problem, right? We just have to consider any other time operations,\nwhich would still be this array copying. So but in just terms of the recursive calls that\nwe make, it's going to be n times m, recursive calls. And then in each recursive call, I\nneed to do this copying pattern, right copying over the contents of an array, and the array\nwill be at most m elements long. Alright, so if I have this many recursive calls, and\neach recursive call needs to make an M length operation, now I just multiplied by another\nm term. So right now this looks like n times m times m, which is the same as n times m\nsquared. And I'll talk about the space complexity. So the space complexity will be at least as\nbig as our brute force, so it's going to be at least o of M, above, now we have to consider\nall the space we use up in the memo object. So I think about the keys of this memo object,\nthe keys are just going to be all unique values of target sum, right? Because I just literally\nuse target sum as a key on all these lines, right? But then everything about the value\nor the values are going to be Pretty chunky now, because sometimes of value but in the\nobject is going to be an array. And I already said that the maximal length of any of these\narrays that I returned is going to be of length M. Right. So to me, it's now the case that\nyour space complexity comes from mostly your mental object, which is going to be of size,\nm times m, right, because you have m keys. And each key has a value, which is, at worst\ngoing to be an array of M elements. So it's m times m, which is m squared. Cool. Notice\nthat we definitely cut down on the brute force implementation, especially in terms of the\ntime complexity, obviously, there was a little trade off that we made here. But now we're\nable to run our house and function in a reasonable amount of time. So to wrap up this problem,\nlet's go ahead and hop back into the drawing board. Alright, now that we coded the house\nand prom, let's wrap it up by actually analyzing the complexity of it. So recall that for our\nhouse, some problem, we have multiple arguments, right, so I need to describe them. So I'll\nsay that m is my target sum, and n is the length of the array. Remember that the array\ncontains the choices we can take. And our baseline solution, that is our brute force\nrecursion had an exponential time complexity, right? It was kind of in the form of n to\nthe n power times M. And after we actually optimize it using the memorization strategy,\nwe actually reduced it from exponential down to a polynomial time complexity. In particular,\nour new time complexity was n times m squared. So really important fact about our memoized\nhave complexities, it is no longer exponential. Please recall that when we have m squared,\nthat is not exponential, because the exponent is a constant number. Cool. If I look at the\nthe space complexity for this, I had to actually pay a little more cost in terms of the space\nbecause of the memoized object. But that space complexity we use up is still not exponential,\nright? Still a polynomial or quadratic complexity. So I'm still satisfied with it overall. So\nwe definitely prefer this memo is complexity over the brute force. All right, that was\nthe how some problem but now let's go over one more variation of it. In this problem, I'll still give you a target\nsum as well as an array of numbers to choose from. But this time, what you want to do is\nreturn an array containing the shortest combination of numbers, that adds up to the target sum.\nAnd along with that, if there's any ties for the shortest combination, you can return any\nof those shortest ones. So from this description, you probably recognize that this is similar\nto our last few problems. But now they're asking for a little bit of an optimization,\nright? So I want the shortest sums, that means an array containing the least amount of numbers,\nbut it still adds up to the target sum. So we're really just going to add on top of our\nprevious understanding, let's take a look at a few examples. So let's say I gave you\nthis example. So here, my target is seven, and the numbers I choose from are 534, and\nseven. So there are a few different ways you can generate your target of seven, one way\nwould be to do three plus four, that's one combination. But another way would be just\ntake the seven because notice that seven is actually a member of the array. And here I\nwant to choose the smallest array, which would be just the lone seven. So that would be the\nexpected result for this one. In a similar way, let's see, I gave you a target sum of\neight. And your choice of numbers were two, three and five, there are plenty of ways to\ngenerate eight, you can do two plus two plus two plus two, or you can do two plus three\nplus three, or you can just do it three plus five. And here, I want to return always the\nshortest combination, which would be the three plus five. So that would be the result over\nhere. Cool. So we definitely have some awareness that Alright, this problem is similar in structure\nto our previous one where I need to sort of generate a way to make the target sum. But\nnow I want to really specify the shortest array, right? So let's try to visualize this\nas a tree. Like always, let's say we're stepping through this example, with the target sum\nof eight. So we know that the full tree would look like this. And we've seen this tree before.\nBut now what we're trying to do is come up with a different process for the value your\nreturn, right, it's no longer going to be valid to just return the first way that I\nfind to generate the target sum. Now I want the best way. So let's start coming up with\nthe strategy for this. At this point, we know that we can definitely implement some logic\nin our code where we return an array up our recursive calls, we did that in the last problem.\nSo here, we'll sort of use some abstraction to assume some return values. So let's say\nthat I'm bringing this problem down, my top level problem asked me what's the best way\nto generate eight. But I see that along that path, I have to find the sub solution for\nthe best way to generate six. So let's say we're rooted at this subtree. And we know\nthat there are a few ways we can make six, right? If I look at this subtree rooted at\nsix, there are two zero base cases downward, right? So if I look at the first one, I get\nthis path, I know that my sub tree over here will be able to know that all right, one way\nto generate six would be two plus two plus two, right? We kind of implemented that logic\nin the last problem. But now what I also want to do is consider any other paths in case\nthey end up being shorter. Obviously, I know That this path of three 300 return upward.\nAnd now I have to kind of make the decision, you know, between these two options for generating\nsix, I should just prefer the shorter one. So that means it's sort of two to two versus\nthree, three. And obviously, the three, three wins because the array length is shorter.\nAnd if I pause right here, and I looked at what the diagram is saying, it does make sense\nthat above the six, we have three comma three, because that is the shortest way we can ever\nmake a six, right, just three plus three. But now I can return this sub array to my\nparent. But if I do that, I should also include the value of the edge along that path, right?\nSo I also included the two over here. Now this makes sense, because one way I can generate\neight is three plus three plus two, right? But we know that's not the optimal way. Let's\nsay we step through this a little further, let's say we took the same sort of process\nfor this other child of five. So I know that to generate five, there are three options\naccording to the subject, right? Because I see three different leaves that are have zero\ninside of them. And so I know that for these paths, they would work out through their own\nsub arrays. And here, I really just want to choose the shortest one, right? So obviously,\nthe lone five wins out over here. So that'd be returned all the way up to that five node.\nBut then that five node will return it to its parent, then, of course, I need to include\nthe edge that connects the eight to the five, right? How did I transition to that five in\nthe first place, so I go ahead and just add it in. And now the root node over here has\na decision to make, which one does it prefer between 332 or five, three, it'll just choose\na shorter one. So the five three should win out over here. And I just need to continue\nthis process for any other branches in my tree, right? I can't return early and this\ntype of problem because I need to find the optimal way. And I can't be sure until I've\ntried every possibility. Cool. So it looks like our overall logic is we want\nto explore and find any ways to generate our target sum. But then when we find a way that's\nshorter than our currently tracked way, we can just replace it, I'll continue that process\nthrough the entire tree. If I checked every possibility and keep replacing what I consider\nthe shortest. By the end of us exploring every branch, we would have the absolute shortest.\nAlright, I think we're ready to hop into the code. Alright, programmers, welcome back to\nmy text editor. Let's work on coding this one out. So here I have some initial examples\nthat we'll use to test our best sum function. I noticed for this last one, right, I get\nmy initial target sum of 100. And the best way to do that is obviously just take a bunch\nof 20 fives, right for 20 fives. What else I want to bring our attention to is this third\nexample over here. So my target sum is eight. And my choice of numbers are one, four, and\nfive. The optimal answer here is four and four, right? That is the shortest way to generate\nat a common mistake I see a lot of students make is sort of assume that the best way to\ngenerate a target sum always involves taking the largest choice of number as many times\nas we can, right? That is not true. If you took a five in your your sum, then you would\nhave to take three ones in the long run, which is not going to work out to the shortest answer,\nright. So it's not the case that just taking the biggest choice of number always yields\nthe target sum in the shortest amount of numbers overall. So don't fall into that trap. Which\nmeans that we have to do the full tree exploration, right, we have to do that in exhaustive sort\nof search using our recursive code. So let's start with that base case, like we always\ndo. So bring this a few times, but still right here. So if the target sum is zero, then I\nhave trivially solved the problem. So I can just return an empty array, right? That is\nthe exact single combination and the shortest combination that can generate the target some\ncool along with that, let's handle that scenario, if our target sum goes too far downwards,\nif it's less than zero, so if the target sum is less than zero, I'll just return null,\nmeaning that it's not possible to generate that target sum. And now we'll use our branching\nlogic. So I'm going to iterate through all choice of numbers will say for let num in\nnumbers. And like we always do, I'll go ahead and create my remainder, which I know would\nbe the difference between my target sum, and that choice of number. Right? So what I'm\ndoing is I'm choosing the number that decreases my target sum. At this point, I would make\nmy recursive call right with that remainder, passing in the same numbers array. But now\nI have to do some thinking, I know that all right, best sum is either going to return\nto me a combination or an array, or it's going to return null, so I'm gonna have to kind\nof differentiate between the two. So over here, maybe I'll just save this as a result.\nI'll call this my remainder. Let's say combination. And if this remainder combination is not null,\nthen it can do some other logic, right? So I'll say if the remainder combination is not\nequal to No, then do stuff. So if I enter this if statement, then that means it is possible\nto generate the remainder. And exactly what remainder combination is, is an array containing\nthe short This way, I can generate the remainder. Cool. So if I enter this if statement, then\nI also have a way to generate the full targets, right, I can just take the remainder combination,\ncopy the elements over from it like we did last time. And also add on the choice of number\nI just took, right. So this would be now a complete combination for target sum. So I'll\njust say that as a regular combination. Cool. So so far, this is very reminiscent to our\nlast one. And we need to work in some more logic relevant for this problem, that is a\nvery, very important characteristic that we needed to implement in the tree was, I need\nto sort of choose the shortest combination, RAMs, I'm going to need to work in that logic.\nSo here's what we can do, I know that I need to compare basically, all of my branches together,\nall of my recursive calls together, and pick out the shortest combination. So I know that\nthis for loop is a piece of code that sort of iterates and attempts, all of my branches.\nAnd so outside of the for loop, I'm going to need some outer variable, I'll call it\nmy shortest combination. And over time, I'll just keep updating this variable if I find\na combination shorter than my current shortest combination, right? So I'm gonna initialize\nthis to null. And the reason is, imagine that we set up\nthis shortest combination of variables, no. And then we iterate through the for loop.\nAnd there isn't even any way to generate the target sum. So this for a loop finishes, and\nshortest combination would still be no. And that'd be great to return, right? Because\nin this problem, they said, if it's still not possible to generate the target sum at\nall, you should still return null. So this is a good initial default value for shortest\ncombination. But now I need to do my update logic. So here on line 11, I've actually created\na combination, that gives me the target sum. But now I need to check, right, so I'll say,\nif the combination is shorter, then the current shortest that I need to update it. So let's\ntranslate that into some code. Just use an if statement. And I'll start by checking if\nthe combination I currently have, which is an array, right? I check if that is less than\nin length, then the shortest combination variable. And really, it looks like shores combination,\nit starts as null. So I need to fix this code a little bit. But if I update it with a valid\ncombination, then it's going to be an array, right? So I'm really checking the length of\nthe arrays here. So what I want to do is assign my shortest combination\nwith the combination that is now shorter, good. So this means the shorter combination\nwins out and gets to stay, right. If I look at this code, it needs a little bit of work,\nbecause the first time I find some combination, I know that I be comparing that array length\nto no dot length, right? Because shortest combination starts as null. And I can't do\nnull dot length in JavaScript. So I'll need like a nice or clause here. So I'll say, if\nit is the case that your shortest combination is equal to No, then you can go ahead and\nreplace it. Cool. So this sort of check over here is going to make sure that I automatically\nreplace this null value with the first valid combination. Even if right now it may not\nbe the shortest, right later on, I'll compare that combination I have stored to some possibly\nshorter combinations. Cool. So this code is looking pretty good. Let's go ahead and give\nit a little test run. Nice. Notice that and on occasions where we call besam, with a remainder\nthat is negative because remember, sometimes we subtract a number that is maybe too large,\nthat's okay. Because that will actually bottom out at a base case and return null, which\nwe sort of check for explicitly in this if statement. Cool. So let's give us code a run\nnode best some. So I get an error over here looks like I get maximum call stack size exceeded,\nwhich means that we didn't really hit our base case. So there's some work to be done\nhere. So let's take a look at this code. So if I take a look at this code, it's a very,\nvery small typo. It's kind of unfortunate that it breaks the entire code. But really,\nI messed up when I iterated in the for loop over here. So here I wrote for letting them\nin numbers, that would actually give me the indices of the array. So they'd be like 0123.\nWhereas I want the elements of the array, right? So instead of in any of over here,\nso that's on me. So with that small change. Let's give it a run now. Yeah, it looks like\nwe're passing these first three examples, we have 735, and four, four, notice that the\norder among the elements in the combination doesn't really matter too much. But looks\nlike we're definitely a little too slow on this last example, over here, right? So obviously,\nwe know the move is to memorize this because we have the brute force recursion. But before\nwe do that, let's just talk about the complexity of This. So this code is going to be very\nsimilar in complexity to our last how sum function, sort of compare the two, it's almost\nthe same code, right? But do these side by side, right, these two functions look very,\nvery similar. So we know in the long run, we probably have the same or close to the\nsame complexity. Let's be methodical. So we know that over here, we always like to say\nthat M is the target sum. And we'll also go ahead and say that n is the numbers dot length.\nSo we just did the brute force. And our brute force shouldn't be the same story as last\ntime. So talk about the time. So the time of the brute force is going to be some sort\nof exponential, right? If you remember that tree drawing, in general, the exponential\nnumber of nodes in a tree will be the branching factor to the height power. So not the branching\nfactor here is n, right? I branch for every choice of number, and then the height of the\ntree would just be the target sum. So that's n to the M. But along with that, we also have some additional\noperations, right? If I look at this for loop, so this for loop gives me the branching factor,\nright. But then I also do this operation on line 11, which is copying over the array of\nremainder combination. And that array in the worst case will be of length m, right? The\nlargest sort of combination, give me back is a combination that is just filled with\na bunch of ones, right? If my target sum was 50, the longest combination possible would\nbe a bunch of ones, so 50 ones in an array. So what I'll do is, I'll say that for each\nof these n to the M power calls, you also have to do a linear operation in M, right?\nSo like before, it's n to the m times m. Cool. And then the space complexity is sort of interesting\nin this one, because we're maintaining some values. So look at this. So I talked about\nthe space complexity, just from the stack space, it would just be the heights of like\nthe recursion. In other words, it would be m over here, right? So I know it's going to\nbe at least M. So I'll jot that down. But then we have also like this variable on line\nfive, right? So I know that over time, I'm going to be storing an array inside of this\nvariable. And this array is going to be in the worst case, m in length, right? So what\nI'm saying is, every recursive call would have to have its own shortest combination\nvariable, right? If the shortest combination variable is going to be an array of length\nm, that means I have an array of length m, for every recursive call right? Before I bought\nthem out, at like my final base case. And so also, the space complexity here is m times\nm, which we know is the same thing as m squared, right? And sort of the reasoning is, your\nmaximal stack depth is still m like last time, however, now you need to have those stack\nframes, you need to store in array, right as you recurse. Nice. So really, the limiting\nfactor for us right now is going to be the time complexity, which is exponential. And\nso like we always say, let's go ahead and memorize this. So memorization pretty trivial\nright now, right? You've done it many times. So I'll just begun my initially empty memo\nobject. And I'll check, you know, if my target sum is in the memo, then I should actually\nreturn the stored value. So return memo at Target sum. So now that I have my memo checking\nlogic, what I also want to do is add the memo storing logic, right. So I need to just go\nto my return value and store it in the memo before I return it. Notice that the return\nvalue right now, it's no longer inside of the for loop, right in the last problem, it\nwas in the for loop, because I can return early. But this time, we're going to return\nat the very end, so I'll replace it over here. So I'll say, for here, the memo at Target\nsum should be stored with the shortest combination, I can still return the shortest combination.\nAnd before I forget, let me go ahead and pass down the same memo object by reference. Alright,\nnothing too much to that. Let's go ahead and try this last example. Now. Give it a shot.\nAwesome. And there we have it. We have 425 in this last example. And that is the best\nway to generate a 100 is pretty evident that we cut down on the runtime. So let's talk\nabout the memoized complexity embolized. And so the time is obviously much faster should\nnot be exponential. But if I take a lay of the land, I know that now that every target\nsum is going to be a key of the memo object. And target some is really just a number, right?\nSo if my target time is 50, then I basically have 50 different keys I can never store in\nthe memo object. So if I have m different keys in my memo object, I know that I won't\nbe exploring any full duplicate sub trees for each of those keys. However, I will slap\nthe branch for every number in the array, right? So overall, I'm looking at an m times\nn. So so far, I have m times n, but I have some additional work from this array, right?\nSo notice that the n over here that comes from this for loop, I'm iterating through\nnumbers, but then the additional M comes from copying over this array, which would be linear.\nSo it would be m times n times M. And I can just kind of squish these two M's together.\nSo it kind of boils down to m squared, times n, which is really the same thing as last\ntime. And our space complexity would also be the same as it was last time, which was\njust m squared, mostly coming from the memo, right? And the logic is, your memo keys have\nm possibilities. But for each of those keys, their value can be an array of length m, right?\nSo just m times m, or m squared. Awesome. So looking at this code, you probably, you\nknow, feeling that Oh, my gosh, like this best some problem is pretty complex. And I\nthink it you know, to be honest, it is, however, what I really want us to focus in on is this,\nlike progression we took, right, I think that everyone could tackle this best some problem,\nif they warmed up and really understood simpler problems like can some and how some write the code is very, very similar. So to\nwrap things up, I will let's do some closing words on the drawing board. So in its best\nsome problem, right, we had two inputs, we had m as our targets, and also say that n\nis the length of the array. So the brute force that we initially implemented it with just\nsome recursion was exponential in time. And after we optimized it, we brought it down\nto just a polynomial time complexity. And notice that between our brute force and our\nmemulai solution, they actually have the same space complexity. So we definitely prefer\nthis memoized version. So hope you enjoy this series of problems. That is we worked on the\ncan some how some and best some problems, they all had the common frame of us having\nsome target some that we need to generate with some options given in an array. And in\nparticular, if you look at the can some problem it asks us what that task of generating target\nsome Can you do it? So yes or no? The house and problem. So is how will you do it? So\nwhat are the exact combination of elements that you'll use? And finally, the best son\nwas the hardest version? And it asked, What is the best way to do it in terms of the least\nnumber of elements of the array? So there definitely is a logical progression to these\nproblems. And in particular, they kind of capture a different variation of a dynamic\nprogramming problem for our can some problem, right, we had to return Boolean there. That's\na type of decision problem, right? Yes or no? Can you accomplish this task? Is it possible?\nAlong with that the house some problem was a combinatoric problem, right? We want to\nknow the exact combination that works out. And the best some problem was a variation\nof an optimization problem, right? I want the shortest way to generate the target. So\nwe saw that these three problem types definitely have some common ground, but they also have\nsome nuance, depending on exactly the question we're trying to answer. These all fall under\nthe umbrella of dynamic programming. That being said, dynamic programming problems aren't\njust limited to number inputs. All right, I think it's time to work on another prompt,\nlet's say I gave you this, what I want to do is write a function called can construct\nthat takes in some target string, as well as an array of words in a word bank. My goal\nis to return a Boolean indicating whether or not I can make the target by concatenate\ntogether elements of the word bank. And along with that, we can reuse as many elements as\nthe word bank as we see fit. Alright, notice that in this problem, we're looking for a\nBoolean response to start, right. So just yes or no. Is it possible to generate the\ntarget? So let's take a look at an example here. Let's say I gave you this. So my target\nis abcdef. And I have a nice long array of some words. And so I'm basically asking, Can\nyou construct abcdef, using elements of the array. So if I kind of take a look at the\narray, there is exactly just one way to generate the target string, which are just B, A, B,\nC plus D, F. So the answer here is true, because there is at least one way to make the target,\nright. Let's take a look at the opposite example. So let's say I had this word of skateboard.\nAnd I gave you all of these words in an array. So take a moment to kind of look this one\nover. And you tell me write Is it possible to generate skateboard here? And the answer here is no. Right? It is not\npossible to generate skateboard using this array of words. So we should return false,\nwe can get pretty close to making skateboard. But we can never build the full string. Alright,\nso here are a few ways that we can attempt but they don't work out in the long run, right?\nThis is one series we can take, but we kind of get stuck, as well as this. And also this\nway, right? Point being there are zero ways we can ever generate skateboard. So we should\nreturn false over here. Awesome. So I think let's look at one more example. We should\nalready have the vibe that in general, it's easier to create a shorter string than a longer\nstring, right? To create a longer string, you're probably going to need to use more\nelements. So if I have that kind of framing in mind, that I know that possibly the easiest\nstring to create would be the empty string, right? So let's say your target was the empty\nstring and I gave you you know, some kind of random array of words, really, the array\nof words doesn't really matter here. I think no matter what they should return true. Because\nto generate the empty string, you can just take no zero elements. From the array, and\nthat kind of line of thinking is going to help us really start to solve this problem.\nSo we'll kind of take this example, in stride, what we want to do is return true if our target\nis empty, and that takes place no matter what array of words we're given, right? Cool, more\nor less, that kind of sounds like a base case, right? But let's go ahead and start to kind\nof define some process we can take to explore all of the options, right? So I want to really\nvisualize this in a well ordered way. And that really means a tree. Right? So let's\nsay we're going to trace through this example visually. So my target is abcdef. We already\nsaid that, in the long run, we should return or conclude a true about this input, right?\nSo we'll just start with the input argument that is the target string as the root of this\ntree. And this is sort of a scenario where like, Alright, I have two inputs, how do I\nknow which one to really encode in my drawing? Well, it's about what will actually change.\nI know from like, one instance of like this problem to the next, the array of words, I\ncan actually reuse as many times as I need. So it's not like I'm taking out elements from\nthe array. So with that in mind, I think it's better or more reasonable to encode the actual\ntarget string into the nodes of this picture. Because I'm gonna start with this original\ntarget string of my route. Now I have to think about how I transition to the children of\nthis right, so what moves do I take that hopefully shrink the target string, right, I know I\nneed to shrink the target string, because I already have the base case of the empty\nstring in mind. So I need to get closer and closer to a length of zero. We'll talk about\none transition we can make. So I know that I need to sort of use the array of words as\nI transition. And so let's say I took a B as a choice right now, if I take a B, then\nI guess I could remove, you know, that sequence of characters from my parent node. So if I\ntake a B out of abcdef, then the resulting child is just C, D, F. Cool. So notice that\nas we transition from one node to the next, looks like we're taking out that substring.\nIn a similar way, I have another substring, that I can take out for my word bank, and\nthat would be ABC, and that would yield in the child d f. And then I can do this for\nsome other string inside of the word bank. And the really important thing to know is,\nthere's a correct logic to doing this. And it's also a common trap I see a lot of students\nfall into when it comes to this logic. So right now I'll talk about like the common\nmistake. So it would be ill advised to sort of take out the CD from our root node, if\nyou took out C, D, then the resulting note would be a, b, f. And so what we're doing\nright now is if we took out C, D, you're taking out something in the middle. And if you take\nout something in the middle, that means that your resulting string actually creates a new\nadjacent sequence of characters. In other words, I know that this is kind of suspicious,\nbecause look at this little run of characters, A, B, E, those are now like adjacent next\nto each other. Whereas in the original string of abcdef, A, B, he was not present, right.\nSo if I kind of take out strings in the middle, then I'll have this sort of mistake of creating\nnew adjacencies. Right. And that would actually impact the moves I take later on. So I don't\nwant to do that, right. So the move here is to not take out any characters from the middle\nof the string. So what would be the correct way of doing it? Well, if you look at our\ntwo nodes that we already branched into, a common factor for them is the fact that we\nactually took a prefix out of our original root node, that is a B as a prefix, and so\nis ABC or recall that a prefix is just a string, that kind of begins some other larger string.\nSo if I want to transition to a third node over here, there's only one more prefix I\ncan take. And that would just be ABCD. Right? If I take that prefix out, then my resulting\nchild is just E, F. And so the overall logic that we want to use when we build this tree\nis to only branch to children if we have a matching prefix in the word bank. And of course,\nthe child would be the resulting string after we remove that prefix. So let's keep it rolling.\nAnd we'll apply this logic again and again, recursively. So let's say I'm rooted at this\nCDF node, I'll look inside of the word bank and notice any prefixes that actually match\nhere, I think there's only one and that would just be CD. If I took out the prefix CD, then\nmy result is E, F. In a similar way, I can do that for d f, I find that d f is actually\ncontained in the word bang. So it's technically also a prefix. If I took the prefix def out\nof that node, then my result would be empty, which is pretty good. At this point, I look\nat some other nodes like this EF and they have no matching prefixes inside of the word\nbank. So they sort of bought them out in some sort of base case. In the long run. If I can\nbreak down EF any further than I know that it's not possible to construct EF so that\ncan technically return a false to the parent. Mr way, if I ever run into the empty string,\nthat means the job is done. And I can just return true, right? Something we said earlier\nwas, whenever we want to generate the empty string, it is always possible no matter what.\nAnd now this pattern should feel a little familiar, right? All I have to do now is kind\nof bubble up these Boolean values to the parent. And overall, if one of my children return\ntrue, then I myself will return true, right? So I'll bubble this up a little bit, bubble\nup all the way to the top. So our root note chooses basically the true value among these\nthree values it gets from each of its branches. And so the ultimate answer here is just true,\nright. And it is possible to generate abcdef using words of this array. So you're probably\nhaving deja vu right now, right? We almost use the same exact logic for the previous\nsome problem. However, all we did was adjust how we transition from one note to the next,\nreally making a compatible for this string data. But we're going to carry over a lot\nof knowledge, right? It's really important that we understand like the general like knowledge\nof dynamic programming and recursive understanding, we can apply that under any circumstances.\nThat being said, let's look at one more example. What I want to do is see an example where\nthis should return false. So let's say I gave you that skateboard example from before. In\nthe long run, this is going to return false. If I tried to break down skateboard, I would\nalways try to transition using any matching prefixes from the array. There are two prefixes\nat the start that match, and that would be SCA and SK, and those would give me t board\nand eight board, respectively. And now at this point, if I route myself at the keyboard\nnode, I can only take the T, resulting eboard. In a similar way, if I am at the eight board\nnode, then I can only transition using the eight. And I'm left over with board. At this\npoint, if I look at eboard, that node over there actually hits a dead end, right, there's\nnothing I can actually take out of Eve or there's no matching prefix, because I basically\nneed something that starts with E, but no words of the word bank start with E. So I\nguess we have to focus our effort elsewhere. Looking at this board, I can take either a\nBo or a Bo AR, and I'm left with art and D respectively. And unfortunately, those two\nnodes at the leaf level also bottom out, right, I can't transition further and take out any\nprefixes from those strings. So I know that those will have to return false. And if all\nof these leaf nodes return false, then my ultimate note at the top that is a skateboard\nnode at the root, that's going to just return a false as well. So it's pretty clear to me\nthat the overall logic we want is if we get back a single true, then we can just return\ntrue all the way up to the call stack. But if everything is false, then we'll just go\nahead and return a false. With that, I think we're ready to code this one out. All right, let's go ahead and code this one up. So here I have\nsome initial examples we can use to test our code for correctness. Looking at the last\nexample, over here, it's a fairly long one. And notice that the target incident F, whereas\nno words of the word bank have an F in it. So we know that that should result in a false.\nSo let's go ahead and lay down the base case for this. Like we said, a reasonable base\ncase is to check if your target is empty, right. If you have the empty string, then\nyou can already construct the empty string by taking no words from the word bank. So\nyou can just return true over here. And now I need to make my recursive call in a way\nwhere my target string gets progressively smaller and smaller toward this empty string.\nAnd so I know that based on the tree I drew, I need to make a choice based on the words\nin the word bang. So I'm going to iterate through all of the words. So I'll say for\nlet word of word bank. So I'm iterating through every element of the word bank. And now that\nI have the word element, as I think about when it's okay, to make the recursive call\nusing that word, and we spoke about this, we pointed out that we need to make sure that\nthe word is a prefix of the target. So I can do that, I can just check if the target dot\nindex of word equals zero. So index elf will just give me the index where I can find some\nsubstring inside of a larger string. If the index i get back is zero, that means that\nthe word starts at index zero of the target. So if you're unfamiliar with this method in\nJavaScript really quick, let's say I did potato dot index of pot, that will tell me the index\nwhere I can find it, which happens to be at index zero. But if I looked for tayto, I would\nget the index of the T, the first t rather in potato. So this is a really nice way I\ncan use to check if some substring is a prefix of another string, right, the index should\nbe zero within it. So a way interpret this if statement is if I have a prefix, then I\ncan sort of use it to shrink the target. So I'll create another variable here. I'll call\nit like the suffix so that's like the string after I remove the prefix. What I can do is\nslice my target string. Except to target that slice. And what I want to do is start picking\nup characters. After the length of the words I can say word dot length over here. So it's\nkind of reasoned out what this logic is doing. So we'll trace through this, let's say that\nI don't know my word. So I'll open up the note repple. Let's say my word was the string\npot. And we'll also say that my current target is potato. So I know when I do target dot\nindex of word, that is going to get back zero. So this if statement would be true. And then\nwhat I do is target dot slice of word, dot length. So we're dot length is just the length\nof the prefix I took, right? So it would be three over here, providing the target that\nslice starting at index three, that would give me everything after the prefix, right?\nSo I basically have removed pots, and got eight. Oh, cool. So when you use slice, if\nyou pass in a single argument, that's going to be the starting position of what you start\ngrabbing characters, and you'll go all the way through the end. Cool. And that's the\nlogic I definitely want here. So back to the code. Now that I have the suffix, I want to\nmake my recursive call on that suffix. So basically asking, Hey, is it possible? Can\nI construct the suffix now? And I'll pass along the same choice of word bank. Nice.\nSo here's where I should think recursively. So I'm focused in on what type of data do\nI get back from can construct I know I get back a Boolean, right? True or false, it tells\nme whether or not the suffix can be made. And I want to check, you know, if this call\nreturns true, maybe I'll be explicit here. So if the recursive call is true, then I know\nthat the original target can also be made. So what I'll do is return true early here.\nCool, I know that if the suffix could be made, and the word that I use to generate the suffix\nis also in the word bank, then the entire target must also be able to be made. Nice\nto hear I have my nice early return true. Like you expect, where should I return false,\nit should be after the for loop, right? Only after I've tried every possible choice of\nthe word and none of them worked out, then can I say, No, the target cannot be created.\nSo I want to do a late return false over here. So this code is looking pretty sharp, I think\nlet's go ahead and test these examples. So I should get true false true, and then false\nfor the last one, give this a go. So I get true, false true. And it looks like\nthe last example over here is taking quite some time to finish. So I think our code has\ncorrectness. But it's not efficient enough to you know, reasonably run this last example.\nSo I'm going to kill this program. If you take a look at the example I pass it for this\nlast one, it does sort of describe the worst case here. For one, we know that the answer\nis going to be false. So you will have to do a full exploration of the tree, meaning\nyou can't do any early return trues, right. And because of like the length of the string,\nand also the length of the word bank, I have a very big tree, right? Notice that there's\ngoing to be a lot of prefixes at work here, right? every element of this array is actually\na prefix that could be found over here. And that happens again and again. So I'll tell\nyou what, let's go ahead to the drawing board. And we'll try to visualize what the exact\ncomplexity of this function is. Alright, so we implemented looks like the\nbrute force for this solution. Let's talk about how we might want to optimize it, I\nthink any conversation of optimization should begin with actually understanding what the\ncurrent complexity is. So let's say I gave us this kind of large example to sort of visualize\nwith, so my target string is enter a potent pot, and I gave you a pretty diverse array\nof words in the word bank. So I'll just go ahead and kind of give us though the full\ntree in what it would look like, would be this pretty long tree, right, so I follow\nthe same logic that we did in our earlier examples. notice a few things. There are some\noccasions where I transition using a single character prefix, which is totally fine. And\nthat kind of tends to feel like the worst case scenario, right? If you take single characters\nout of your target string over time, then you're going to have a very, very tall tree\nheight, or you're gonna have to take many, many steps. So that kind of reminds us of\na worst case scenario, like we saw when we ran the code. But that being said, we want\nto generalize this understanding right for basically some generic size of our input.\nSo let's say we kind of just looked at this tree in terms of its overall shape, and then\nwe'll kind of generalize it. So to me, this tree has this sort of basic structure. And\nlet me start by defining the terms I'll use to describe the complexity right. So I'll\nsay that M is the target string length, and n is the number of words in the word bang.\nRight, so I'm really trying to use a different variable for each of my inputs, because I\nhave the vibe that both of them contribute to my complexity, possibly in different ways.\nSo you've seen, you know, us analyze trees before in terms of like their structure, right,\nwe're visualizing as a call tree, I know that the time complexity would be the number of\nnodes in the call tree, right. And so let's start with some familiar territory, I kind\nof already know that I need to realize the height of this tree, the height of this tree\nis going to be m, right? Remember that m is our target string. And so imagine, in the\nworst case that we took, or we had to take a bunch of single character, choice of words\nto construct our target string, that means that the number of things I would have to\ntake all the way from the root to a base case, or the root to the leaf would be exactly M.\nRight? If I had to take a bunch of single characters, so we can be confident that the\nheight of this tree would be m. So I talked about the height. Now I need to realize the\nbranching factor, that is from one level of the tree to the next, how does a number of\nnodes change in the worst case? Well, I know that the branching factor is dictated by how\nmany words I have in the word bank. And so that would be some relation on n. So I know\nat the root level, I have about one node. But then in the worst case, to get to the\nnext level, I will multiply by n, right? Imagine that, basically, almost every element of the\nword bank was a matching prefix, right? So you'd multiply by n. And let's say that carried\nover further, let's say almost every word of the word bank was still a prefix of those\nresulting nodes, I would keep multiplying by n. And I would do this overall m times,\nright. So we already know that this is going to be exponential, I need to multiply n by\nitself, m times over. And so this would give me an N to the M, time complexity. In general,\nif you visualize your recursion using a nice call tree like this, then the overall time\ncomplexity is going to be the branching factor to the height power. So we have a branching\nfactor of n and a height of m. That being said, this will just really consider the number\nof calls that we make, I want to be super sure and make sure we didn't do any other\nkind of performance or costly operations inside of our code. So here's our code, same code\nas we did before, if you look at this code, some things I need to consider are probably\nline six, right? If I look at line six, that was where I did a target that slice that's\nlike copying over a part of the target string. And to do that operation, I would actually\nhave to iterate through the target string. Right? So that would actually contribute to\nmy complexity here. So in the worst case, would I be slicing? Well, if I'm slicing a\ntarget string, that would have like a maximum length of M, right. And so in every call to\ncan construct, I'm going to have to do an additional m operation, if I have n to the\nM calls, then I can just multiply an additional M over here, right. So I, I added some additional\nterm into our complexity, just multiplying by M. Cool. And so overall, if you look at\nthat time complexity, it was already exponential so that multiplication by m, doesn't really\nmake it that much slower, it's really the N to the M, that makes it unbearably slow\nin the first place. So that was the time complexity. Now let's look at the space complexity. So\nif we just refer to the space complexity, due to the call stack, it looks like it's\ngoing to be the height of this tree, right? Like we always say, the height of the tree\nwould mean the maximum number of stack frames, we would need on the call stack before we\nbought them out at the base case, right? Because when we return from a call, we would actually\nremove something from the call stack, right? The height of this tree is definitely just\nM. So we'll say the space from the call stack is just o of m. But again, we should also\nyou know, look at our code and see if we created any other like growing structures. So we look\nat the code right now, I see that on line six, and kind of talking about that slice\nstatement. Again, the slice returns you a new string, right. And that new string is\ngoing to tend to be of length M. So on every call to can construct, I'm creating a new\nstring, I actually need to maintain it through the recursion, right, because I actually slice\nbefore I return out on line eight. So because of that, I know that each of my M stack frames\nwill have to store a string of length M. So that just means m times m in my space complexity,\nwhich is really just m squared. Cool, which isn't too bad of really a space complexity\noverall. Alright, so it looks like our final complexity for our brute force solution is\nexponential in time. And it looks like quadratic in space. So obviously, let's work on improving\nthe time complexity over here. And so hopefully, you're seeing where this is heading. Let's\nsay we jump back into my entropion pot example. So this was a huge tree. Take a moment look\nat this tree, and where can we actually optimize some work away? To we're trying to do is notice any overlapping\nsome problems In the context of our tree, that means I'm looking for any duplicate sub\ntrees. And I see duplicate sub trees right here, right? They follow the same structure\nall the way down even to their base cases. So I've looked at the sub trees, they're really\ntrying to solve the same problem, right? That is they're both trying to figure out, can\nwe construct the string and teapot, right? And if I saw that once, on the left hand side,\nthe answer is going to be the same on the right hand side. So I can just store that\ninformation in a memo, right? So the trick is here to of course, memorize it using our\nclassic strategy. So let's hop to it. All right, here we are back in my code editor.\nLet's go ahead and just memorize this one. So I'll create my memo object. And here, I'll\nprefer to use the target as the key to my memo, I know from one call to the next, the\nword bank doesn't change, right? So I don't need to actually make it a part of the key\nfor my memo object. So I'll just check, hey, if my target is in the memo, then what I'll\ndo is return the stored value of that target. Cool. While I'm here, let me also squish this\ndown to a one liner. So I have the memo checking logic. Now I need to make sure I pass down\nthat memo to all of my recursive calls. And then I need to actually store data in the\nmemo. And the rule is wherever you have your recursive returns. Now, you should also store\nthat return value in your memo before you actually complete the return. Right. So for\nboth of these lines, I'll make sure I store them in the memo. So it's a memo at Target\nequals that. But I still want to return that same value. So we'll return true and return\nfalse over here. Again, notice that I'm using my exact argument targets, right? I don't\nneed to write any memorization logic about the suffix, right? Imagine if we made the\ncall to can construct suffix becomes that frames target. So the memos ation would still\nwork properly. Right? So that looks pretty good. And it wasn't that much code, right?\nmemoization is always this slightly extra layer, we add on top of our brute force solution.\nSo let's try this now can't construct. Nice. And there we have that last example finishing\nfairly quickly, or we do get the correct answer of false over here. Alright, so here's what\nwe'll do, we're going to head back to the drawing board. And of course, we'll come up\nwith the final complexity analysis for this function. Some classic memorization, right?\nLet's take a lay of the land over here. So we wrapped up this can construct problem,\nlet's describe its final optimized complexity. So again, like before, we'll say M is the\ntarget length, and n is the number of words in the word bank, our original brute force\nhad an exponential time complexity, right, and that was n to the m times m. And when\nwe memorize our solution, we actually improved it from exponential. So now, the time complexity\nof our solution is n times m squared, right. And the reasoning is, now we don't have to\nfully explore any duplicate subtree, every time we run into it, instead, we just store\nthe results in the memo. And we can just kind of short circuit and fetch the stored result\nin the memo. Notice that I have an M squared, right in the memo, I have complexity, that\nsecond m really comes from the fact that we still have to do the slice, we have to pay\nfor that cost. So although we added an additional object in our memo II solution, our space\ncomplexity would remain in the polynomial class. So overall, we definitely prefer this\nsecond solution, because we remove some exponential, you know, complexity. So now it is reasonable\nto actually run this in an amount of time. I think that wraps up this can construct problem.\nNow let's work on the counting version of this problem. In particular, I want to work\non count construct. So we have the same set up here, I want to take in still a target\nstring and also an array of words in a word bank. But this time I want to return a number,\nI want to return the total number of ways that the target can be made using words of\nthe word bank. And like before, we can reuse elements of the word bank as many times as\nwe want. So notice that this question asked us to do something slightly different, we\ndon't want just true or false. If it's possible, we want the exact number of ways that we could\nconstruct the target string. So let's take a look at some examples. And also, you know,\ntake a high level view of the strategy here. So let's say I gave you this string of abcdef.\nAnd this array of words, this particular example we saw before, and it is possible, and there's\nactually one exact way we can generate abcdef. So we can construct the tree in the same way\nwe did before. And we end up with this. However, this time around, we want to choose a different\nvalue to return for our base cases, as well as changing the logic for reconstructing our\nsub solutions, right? And so if I look at the base cases here, I wanted to kind of just adapt the return\nvalue for this new type of data that I need to return which is number. So I think the\nmove is for these scenarios where we can't break down our current target any further.\nThat's your return zero, right? Yeah, f can't be broken down because it doesn't have any\nmore matching prefixes from the array. So that means there are zero ways to breakdown\nF. And so we should return zero in those scenarios. And then when we have the empty string we\nknow was successful. So we could always, you know, create the empty string. And so that\nshould return one. And we've seen this logic before in problems like Fibonacci, as well\nas our grid traveller problem, we just want to bubble up these values to their parents,\nand make sure every parent will add up all the numbers that come back from their children.\nSo it just bubbles up like this. And top level we do zero plus one plus zero, which means\nthat we can generate abcdef in exactly one way. And if you look at the way that actually\nis symbolized inside the tree, it's exactly the path from this root node all the way down\nto that lone base case that returned an empty string, right, ABC plus d f. Let's take a\nlook at another example. So here I have the target string purple, and I have some other\ncharacters and words inside of the array. So take a moment to look at the input here\nand predict what number they should return. So the answer here is two, right, there are\ntwo ways to create purple. So if you construct the tree, we know we start with the initial\nunknown of purple. And then we have about three prefixes that match here. And those\nyield some children, we can follow the same pattern recursively down the tree. So the\nfull tree really looks like this, notice that I have a two base cases that actually end\nup as the empty string. So I know those are going to turn one up to their parent. And\non the right hand side, I have a loan II that can't be broken down any further that returns\nzero. And like always, right, I just bubble up these values, until at the parent, I actually\ndo one plus one plus zero, which gives me two. All right, there are two distinct ways\nto create purple using this choice of word bank. All right, I think I'm feeling pretty\ngood about jumping into the code for this one, it's really just a small variation of\nthe last problem we did. So let's hop right in. Alright, programmers back in the code\neditor, let's go ahead and bang this one out. So I already have some examples that show\nus what numbers we should return for this count construct, right. So I have some examples\nhere. I'm gonna say even have that big example, with our large inputs, we know that that will\nprobably need to be optimized, let's lay the foundation with a brute force. So we'll start\nwith the same base case, as always, right. So if the target is the empty string, then\nwe have truly solved the problem. Meaning that there is definitely one way to generate\nthe empty string, right, just take no elements from the word bank. Along with that, I need\nto make my recursive call. So the usual structure, right, I want to iterate through every choice\nof word. So for let word of word bank. And then for every word of that word bank, I need\nto check if it's a prefix. So we've done this before, if the target dot index of word bank,\nor rather index of word, if that is equal to zero, then it must be a prefix. And if\nit's a prefix, and I can go ahead and take like the rest of the word that is the suffix\nand call recursively on it. So I'll do this in line now say, count construct, and I'm\ngoing to pass in the rest of the word, which would be target dot slice, and then I'll slice\nstarting at word dot length. So this means that the slice contains everything after the\nword or everything after the prefix. And so Also be sure to pass into the second argument,\nthe same word bank. Nice. And now I need to think about what calc construct returns. So\nit's returning a number now, right? So in particular, this will be the will say, num\nways. I'll say no more ways for the rest, maybe a little wordy of a variable name, but\nI think it does describe how exactly what this returns here, right. So this is a number\nof ways that you can generate the suffix with like the rest of the target. What I want to\ndo is keep a running total. So outside this for loop, I need a way to add everything that\nthe for loop iterates through right, so I'll create a total count over here. So I'll say\nlet, I'll say total count. And I'll start it as zero. And now inside of my for loop,\nwhenever I get the number of ways to create the rest of the string, I'll go ahead and\njust add that into my total count. So it's as simple as total count plus equals the number\nof ways to generate the rest of the string right after I've removed the word. And after\nI take the total through the entire for loop, and I can just return the total count. Something\nreally great about this, this programming pattern is let's say that none of the choice\nof words were a valid prefix. So that means I finished this for loop. And this if statement\nis never true. If this if statement is never true, that I never add anything into the total\ncount. So if I return total count afterwards, I return a still zero, which makes sense because\napparently there are zero ways to make the target right have no initial step to take\nin the word bank. So let's go ahead and test this one out. So looks like we should get\nto 104, and then also a zero at the end. Let's give that a go. So 2104. And it looks like the last example\nis just a little slow for us. So you already know where this one is heading. Let me tell\nthe program, let's just go ahead and just memorize this one off the bat, right? Hopefully,\nI think through all of these examples, you're feeling really good about memorization. And\nit's apparent that we basically have drilled into our minds already. So if the target is\nin the memo, and just return the stored value memo at Target. And then I'll need to adjust\nmy return value, right. So where I return over here is I'll store that total account\nas the value corresponds to the target. And let's not forget to also pass in the memo\nto our recursive calls, right? So memo goes right here. Nice. So let's give that a run\nagain. I expect a zero for that last answer, right. So looks like I have an error over\nhere. And of course, I forgot to actually replace my return value. So I can still return\nthe total counts. And addition to that, I'm actually adding it into my memo. So let's\ntry that now. Yeah, these answers look correct, right, I got zero for the last one, notice\nthat the last one is not possible, because it ends in an F and all my words only contain\nE's. Nice. And if you look at this code, it's a pretty similar to our previous problem of\ncan construct if I kind of split these can construct basically has the same shape. Really,\nthe only difference is this number variable that I add into, and of course, the return\nvalues. So we do expect the complexities to be the same for these two functions. Let's\nwrap this one up on the drawing board. Let's look at the complexity of this. As always,\nfor this calc construct problem, our M is going to be the length of a target string,\nand our n is going to be the length of the array, right? So that means a number of elements\nin that array. Our brute force is the same as it was in the can construct problem, right,\nso it's still exponential. And using memoization. We just brought that down from an exponential\nto a polynomial time complexity, and the space complexity remain the same. Really, there\nis no additional cost that we pay in our implementation for this counting version of the problem,\nright. The only difference is now we're maintaining a number that we just add to, you know, on\nevery iteration of that for loop. But that doesn't really affect the runtime or the space\ncomplexity at all. So I think this wraps up this count construct problem. Now I want to do one more variation of the\nstring problem. So what I want to do is write a function called all construct that has the\nsame setup, right, so I'm going to take in a target string, as well as an array of words\nin a word bank. But this time, what I want to do is return all of the ways that the target\ncan constructed by concatenating elements inside of that word bank. And that means I\nshould return a two dimensional array, a single element of that 2d array is going to represent\none of the combinations that can construct the target, right, and I want to return all\nof the ways within a 2d array. And as always, we can reuse elements of the word bank as\nmany times as we need. So let's make sure we understand this question by looking at\nsome examples and their output. So here's an example using purple. And it's the one\nwe've seen before in the last problem. The last problem I had us return to because there\nwere two ways to create purple. But now I don't want the number, I want the exact ways\nthat actually create purple, that means you need to return a two dimensional array, the\nouter array, or the outer set of brackets represents the collection of all combinations.\nWhereas a set of inner brackets or a sub array represents one of the combinations that creates\npurple. Let's take a look at another example. Let's say I gave you abcdef. And I gave you\nthis long array of word bank, notice that I actually added some elements inside of this\nword bank array. It's a little more complex of in our previous examples. Because of this,\nthere are actually many ways you can create abcdef. And this contains all of them, right?\nSo there are four ways to create our target string. And again, notice that each sub array\nrepresents one of those combinations of words in the word bank that creates the target.\nCool. So now that we kind of understand like the shape of this problem in terms of the\ndata we should return, let's take a look at some base scenarios. So let's say I gave you\nthis example. Right? So I have a target of Hello. And my words in the word bank are just\nCat Dog and mouse. Obviously, you know, that is not possible to generate Hello. So there\nare really zero ways to create this. How should we actually return an answer here? Well, I\nthink it'd be reasonable to return an empty array. Remember that we're saying the outer\narray in this context represents the collection of all of the combinations that can create\nHello, since there are zero ways to create Hello, that means that our collection is empty,\nright? This has a length of zero meaning there are zero ways to create Hello. Now let's say\nwe had another base scenario. Let's say we have to generate the empty string using the\nsame array of word bank. And that scenario, I think it's reasonable to return an array\ncontaining an empty array. And again, the reason is if it is possible to To create the\ntarget string, then we need to return a 2d array, right where the outer array represents\nthe collection. And if there's one sub array inside of that outer array, that means there's\none way to create the empty string. And what does that one way? Well, it's to take no elements\nfrom the word bang. So I think this is going to be consistent logic, this is going to be\na really important way to think about this problem. That is, when we're given a target\nthat cannot be constructed using the word bank, we should return an empty array, right,\na one dimensional empty array, because there are zero ways to create it. On the flip side,\nif I've ever given the empty string, we know that it's always possible. And so we should\nreturn like a two dimensional empty array. Cool. So with that, let's look at some tree\nexamples. Now, let's say I have this large example from before, we know that the overall\ntree like we've always know created would look something like this. Obviously, now we're\njust reframing this problem in the return values that we do for our base cases. So you\nnotice that there are four base cases here that kind of reach the empty string. And I\nknow that those represent the four ways to create abcdef. And now I have to adjust the\nreturn values here. So I'm already saying that if I have the empty string, then that\nshould return an empty 2d array. So it looks something like this, right? And how I actually\nreconstruct the entire solution from these very small sub solutions. So let's just stay\nfocused on the left subtree. Right now, I know that these arrays are going to return\nback to their parents. And when I do that, I also need to make sure that I include the\nedge that I actually use to transition to the child. In other words, I'm going to be\nsure to push the label for the edge into each of those sub arrays. So the key insight is\nthis, right? I'm just pushing those edges into their sub arrays. And from here, I continue\nthe pattern up a little further, right. So I know that these arrays return their parent\nover here, and I still, you know, push the edges that I took to get to those children.\nSo on the left, I'm going to put CD in the front, and on the right, I'm going to put\nC in the front, resulting in this. And then at this point, notice that this node rooted\nat C D E F, that is actually going to receive both of these collections, right? And what\nshould this note do? Well, it really needs to just combine a both of these arrays. Recall\nthat, you know, we technically receive a two dimensional arrays, which means that a sub\narray represents one of the ways to create the actual target. So if I just concatenate\nthese two, two dimensional arrays, that yields this construct, if I do a quick spot check,\nI'll see if this is compatible with what the question is asking, right? This is a two dimensional\narray. And I know there are actually two ways that we can create CDF, if I look at what\nthis is saying, The first way is to do C, D plus F. And the other ways to do c plus\nd f. And so this cell problem is correct in itself. So I'm going to use the same exact\nlogic to trace through the right hand side, I know that these cases return to their parent.\nAnd the parent is responsible for adding the edge to each of those sub arrays like this.\nNow, I'm just gonna reorganize everything at the top just to give us some more room.\nAnd maybe I'll even spread out these brackets to make a look more symmetric. But I'm not\ndone here, I still need to consume each of the edges at the very top of the tree. So\nif I look at my left hand set of arrays, I know that those need to receive AB. In other\nwords, they need to have a B place at the front of each of those. So I'll just do that,\nright. In the same way, all of the arrays in the middle, which is really just a one\nsub array, need to add ABC to the front of them, like this. And finally, same thing on\nthe right hand side with ABCD. Cool. Now if I look at what I have, these represent the\nfour ways that we can actually create our original target string. But at this point,\nthe root node just needs to concatenate each of these two dimensional arrays together.\nSo it really just combines them into a single 2d array like this. And if I do a quick sanity\ncheck, I know that each of these sub arrays represents one of the paths that I can take\nto a base case down my tree, which is exactly what we intended at the start. So this type\nof recursion is definitely more complex than the previous examples. But hopefully, you\ncan recognize what's similar to our last examples, right? Let's do one more together, though,\nlet's go back to this purple example of the full tree would look like this. And we'll\ntrace through this. So on the left hand side, we're going to start with a 2d empty array,\nright, because that's the base case for the empty string. Meaning that hey, it is possible\nto create the empty string in one way, and that is to just take nothing. So I do the\nsame logic as our last example, meaning I returned to my parent, but I'm being sure\nto also include the value of the edge, right. And so the key insight here is, I'm being\nsure to add the edge label and not the actual node label here. The note and the edge happened\nto have the same thing le, but I'm really looking forward to adding the edge right?\nSo I add Ellie over here. And likewise, this returns to its parent even further, and so\nAdd that last edge of perp. Cool. Now I need to do everything for this middle path. And\nso what I'll do is return the empty 2d array at the very bottom. And this really bubbles\nup all the way to the top. And we just accumulate every edge label as we go, right. So it sort\nof looks like this. And what's really interesting about this a\nright hand path, this is actually a base case, that doesn't work out, meaning we kind of\nhit a dead end at EA. And what we said in our initial examples was, whenever we have\na target string, that cannot be created at all using words of the word bank, then we're\ngoing to return a one dimensional empty array. And that actually works out in our favor,\nbecause if we return this empty array to our parents, our parent is going to try to add\nthe edge into every element of this empty array. But if there are no elements in this\narray, and it's going to add nothing. In other words, this one dimensional empty array really\njust bubbles up to the very top. And like always, if I just concatenate all three of\nthese arrays together, I actually end up with my final answer, notice that when I concatenate\nan empty array to the rest of these, I will actually contribute nothing to my file answer,\nwhich makes sense because there are no paths that work out on that right hand side. So\nour final answer is just this. Like, we know both of those sub arrays represent the two\ndifferent ways that we can create purple. All right, I'm feeling pretty good about this\nprocess. Now, let's go ahead and code it up. Alright, programmers back in the code editor,\nanother problem, another solution. So let's start by laying out the base case over here.\nNow, like we said, we'll say if the target is the empty string, then we want to return\na two dimensional empty array, right? Every single sub array here represents the one way\nyou can create the empty string by taking nothing right I take no words of the word\nbank. Nice. And then besides that, we need to make our recursive logic. So that's going\nto be very similar to what we've always done for this style of problem. So I'm going to\niterate through every word of the word bank. So I'll say let word of word bank word bank.\nAnd I need to still check if there's a prefix, right? If this word is a prefix, so if target\ndot index of word, if that index is zero, then I know that it must be a prefix, so I\ncan continue some code inside. Nice. And so what I'll do is I'll go ahead and create an\nextra variable just to store the target after I remove the word which would give me like\nthe suffix so I'll say const suffix equals, and I'll say target dot slice of word dot\nlength. So you've seen this pattern before. But just to refresh, this just gives us everything\nafter the word. So basically, once you move the word, what is the remainder of the string\nall the way to the end. And now that I have this suffix actually wants to call my function\nrecursively on that remainder, right? Just like this, I'll pass along the same word bank.\nCool. And now here's where things get a little intense, right? So we've been doing a lot\nof problems, you know, using this recursive structure, and then we memorize it in the\nlong run, I think the most important thing to do is when you make your recursive call,\nyou really just assume that your function works, right. So I think about what type I\nshould get back from all construct. So I know that all constructs and give me back an array,\nright, it's gonna give me back an array containing all of the ways to make the suffix. If there\nare no ways to make the suffix, then it's going to give me like an empty array, right.\nAnd so I'm going to assume that here, so I'll create a variable. And I'll call it, let's\nsay, the suffix waise. And the reason I'm naming it like this is, I really want us to,\nin our head, think about the return value from this as an array of all the ways to build\nthe suffix. Cool. So that's going to be a two dimensional array, right? There are many\nways to do it. Nice. So if this gives me all the ways to make the suffix, how can I get\nall the ways to make the original target like in this current stack frame? Well, what I\nneed to do is really just take each of those suffix ways, and add my word to the front\nof it, right? I used this word to even create the suffix in the first place. So what I can\ndo is, I'm going to say my target ways. Right? So now I want to relate how the suffix ways\ncan be used to build my original target, right? All I need to do is really iterate over every\nsub array over here and add my word to the front of it. Right, that's exactly the process\nwe took in the tree diagram, right? So I can use some nice JavaScript methods here. If\nI just wanted to basically manipulate every element of the array, I can do a map here.\nSo I'll say suffix, ways dot map. And I know that a single element there's going to be\none way he'll say, singular. And then what I want to do is just take that same way, copy\nit over, meaning I just spread It's elements. But I'm also going to put the word that I\ntook in the front, we've seen this syntax before, although maybe this like map method\nis maybe new free, maybe you're not super familiar with JavaScript. I think that's fair\ngame. So let's hop into the node repple. Just to demo this, let's say I had some array,\nI'll just make this array 1234. So there's my array. What I can do in general is use\narray dot map. And map is a function and you should pass in a callback. So that means another\nfunction. And what I'll do is this callbacks gonna take in every element, and it's gonna\nbe an arrow function, what's going to return is really just how I want to modify the elements,\nlet's say I wanted to multiply every element by two, right, the return value of this callback\nfunction is going to become a new element of the new array. So notice, I get back 2468,\nmy original array was 1234. And I get back a new array using map. And so essentially,\nwhat I'm doing in this example, on line eight, in my actual code, I'm just taking every sub\narray and just inserting my word at the front of every sub array. So an example that speaks\ncloser to our exact code would might look something like this, like suffix ways. And\nit's going to be a 2d array. So I'll make a sub array, and we just an array of some\nstrings kind of arbitrary right now. So I'll say x, y, and then z. And then the second\nsub array will be maybe I don't know, like, a x and then a yz. Right, so that's my original\narray. And what I want to do is, if I say suffix ways dot map, and let's say for every\nway, that is every sub array, I just want to copy over that way by spreading out. And\nthen I'll just go ahead and put I don't know, like an A at the front, just like this. So\nnotice what I get back, I basically have every sub array from before, except now I have a\nas the first elements of both of those. Cool. So that's all I'm doing in this particular\nchunk of code. Awesome. So we'll leave the node repple. Back to our running solution.\nAnd now that I have the target ways, that's good. It's basically just like a piece of\nthe answer I need. However, it now this is really only going to give me all of the ways\nto make a target that use this word that I'm currently like on in my iteration. However,\nI know that this for loop gives me multiple branches, right, it's going to use all of\nthe words that are possible to create the target. So I need to kind of gather them all\ntogether. So I'll create a variable on the outside, I'll call it result mailstore. Everything\nright? So across all of these iterations, I just want to add the target ways into the\nresults, I'm going to do result dot push target ways, and I need to actually spread this out\nthat way, I don't nest things too deeply. Right? Remember that this is a one dimensional\narray, right now, target ways would be two dimensional, I don't want to just push target\nways into result. Otherwise, I'd get like a three dimensional array. So I'm going to\nbe sure to spread out target ways, right. So with that, let's actually go ahead and\ngive this run I think all I need to do now is after my for loop, right, after I'm done\ngetting all the ways, then I can just return the results of Mr. Just work recursively. So let's just try maybe the first example\nfor now and see how we do. So I should get, you know, a two dimensional array where I\nhave two ways to make purple. Right? let's give that a go all construct. Nice, and that's\nlooking pretty good. That is a correct answer. Let's try these other ones. Now while we're\nhere. So we should get a nice, large array for that second example. Nice, here it is.\nAnd then the third example, skateboard should return just an empty array, because it's not\npossible. And it looks like that last example is also not possible. So we do get an empty\narray. And if you kind of notice, to get that last answer, like we did in our other examples,\nit does noticeably take us some amounts of time. But before we get to that, let's take\na look at this code, make sure we really understand it. So the biggest logical leap we made here\nwas really, you know, assuming that we get back valid data from line nine, right? And\nthen it's all about how we can, you know, adjust that sub result to get our full answer,\nright. So if I get all the ways to make the suffix, and for each of those ways, I can\njust add my word in front of them. And that would give me all the ways to make my target.\nRight. And I need to continue that process for every choice of word, which is why I'm\nmaintaining this like a massive results variable outside of the for just pushing all the ways\ninto this result over time. And maybe just to be super clear, you're not familiar with\nlike this push method, especially when you use the spread operator with it as well and\nreally easily step through that. So in isolation, right, this is just using push and spread\nin general, if I had some, let's say, array, and let's say it was just an array of just\nsome elements 1234 Then I had another array, I'll call it just numbs, let's say in nums,\nI had elements of seven and eight. So here's my original array. And here's my nums. And\nif I did array dot push nums, you're actually going to force some nesting in this array.\nSo array dot push returns the new length. But it also actually manipulates or mutates,\nthe argument you call it on. So if I look at the array, now, notice that it actually\nhas another array nested inside. That's because I literally just pushed the entire nums. If\nyou wanted to do something a little different, what you can say is array dot push, and you\nspread out nums, what's going to do is comma separates the seven and eight, basically removing\nthe outer brackets from it. So have a look at this. Now, look at the array. Notice that\nwith that second push, now I just added a seven and eight without those additional brackets.\nSo that's all I'm doing over here. Like I said, I don't want to add another level of\nnesting to the result array, right, it should just always remain at most a two dimensional\narray. Cool. But overall looks like we have solved this one. And let's kind of talk about\nif there is even a way to make this faster. This is kind of an interesting problem. So\nthis is looking pretty good. So earlier, when we were on the drawing board, we said that,\nalright, because of what they're asking in this problem, it is basically going to require\na full exploration, right? If I want you to return every possible way, to make the target\nstring, you'll just have to kind of do all the work of creating all of those sub arrays,\nright, so we can't really avoid that stuff over here. If you think about this example,\nunlike 3334, this is actually not the worst worst case anymore. All right, here, we know\nthat eventually we're going to return just an empty array, because we can never generate\nthe final z in this example. However, if I remove the Z, then the result will be a very,\nvery massive 2d array, because there are a bunch of ways to actually make this target\nstring. Right. So we've kind of changed the direction of what it means to be like worst.\nOn this example, let's say we brought this to use the Z. If you really cared about optimizing,\nlike this particular scenario, you would find some benefit to like memorizing it, although\nit wouldn't really affect the worst case, because the worst case is actually where you\nreturn a two dimensional array and not just an empty array. So maybe just because it's\ngood practice, well memorize this. But when we go to the drawing board, we'll see that\nthis actually doesn't affect the true a bigger worst case. But if you just want to optimize\nit slightly, let's say we baked in our memo over here, then we check, you know, if our\ntarget is in the memo, and if it is, then we return the memo, add the target, we'll\nbe sure to pass along that memo to our recursive calls. And then we just need to make sure\nthat for our return value on line 16, we actually store that inside of our demo using the target as a key, and then we still\ncomplete the return by returning result like we once did. Cool. So let's run this now.\nAnd I would agree that the last example now runs faster. But it is not the worst case\nis a really important thing to understand here. Right? The worst case is when you actually\nhave to create a massive sub array, right. And so let's head to the drawing board and\nsee our final conclusion about the complexity here. Like we usually do, well define m to\nbe the length of the target string, and n will be the number of words in the word bank.\nWe know that this problem asks us to return an array containing every combination that\ngenerates the target string. And to come up with that answer, we have to visualize it\nlike a tree sort of like this. In our previous drawing, we saw how each leaf of this tree\nrepresents one way we could create the target string. In other words, if we can figure out\nthe total number of leaves in a tree like this, then we will basically have the number\nthat represents how many different ways or how many sub arrays we have to generate in\nthis problem. We already know that based on our process, we described that there are dimensions\nto this tree, we know that the height of this tree is going to be m and we know that from\none level to the next, we really just multiply the number of nodes by n. And that means at\nthe base of this tree, we would have entity m number of nodes, right, so we have n to\nthe M leaves, which means that we have n to the M different combinations that generate\nthe target string. And if we have to represent each of these entity m combinations, then\nwe definitely need n to the M sub arrays in our output. And so what we're saying here\nis no matter what clever implementation we create, we really have to return a result\nthat is exponential in size. And that's really going to drive the complexity of this one.\nYou can't do any better than exponential over here. And its overall will say at the time.\ncomplexity of this is n to the M or just exponential. If you want to split hairs here, you can really\nmultiplied by some additional factors of m. However, the exponential nature of this alone\nreally gives us the overall complexity, right, because once something is exponential, there's\nreally no coming back from that. And in a different vein, we can say that this space\ncomplexity for this is O of M, like we usually say, it's really just the height of the recursion\ntree. And an example like this, where output is very large, we usually don't include the\nsize of the output of the size of the result into our space complexity, which case obviously,\nwould also be exponential in space, because the result is exponential. Right. So here,\nwe'll just refer to the additional space we use for the call stack, which would be o of\nM, right, any solution you come up with for this problem would be just about this fast.\nAlright, and there, we have our all construct problem. So at this point, we've gone over many dynamic\nprogramming problems, and we use that memoization strategy to work out a solution for all of\nthem. However, memoization is only one of the ways we can actually implement a dynamic\nprogramming solution. Right now I want to revisit all of those problems, but this time\nuse a different lens of understanding. As always, I want us to ease into things. So\nwe'll warm up with this fib function, this is the same problem as last time. In other\nwords, I want us to return the F number of the Fibonacci sequence. Here, I'll say that\nthe zeroeth number of the sequence is zero. And the first number of the sequence is one,\nyou might notice that this time around, I'm saying that the zeroeth number is zero and\nthe first number is one. Whereas in the first time we did this, we said the first number\nis one and the second number is one However, no matter how you start the sequence, they\nwill both actually give you the same series of numbers. In other words, down below here,\nI have some examples for n as well as what the output for our fib function should be.\nIn other words, if I asked you for the six Fibonacci number, the answer there is eight,\nlike we always expect, alright, let's get into the heart of this strategy, right? What\ndoes tabulation even mean? Well, it's all about building a table. So what we'll do now\nis step through a tabulated strategy for calculating fib of six. I know that in the long run, I\nought to return the final answer of eight, right? So I hope that I get the answer right\nby the end of this little trace. So with tabulation we're choosing to do is really think about\nthis dynamic programming problem, still in terms of subproblems. But instead of doing\nit recursively, we do it iteratively by building a table, really just an array, and I'm going\nto begin it with roughly the size of the input. In other words, if my input here is the number\nsix, then I basically want an array of length six, notice that if I want the indices of\nthis array, it's kind of line up perfectly with the original input number. And I'm going\nto have to actually add an extra position. In other words, this array spans indices zero\nthrough six, which kind of means that there actually are seven different elements here,\nright, the length of this array is seven. So something very common that I see when students\ntry to implement a tabulated strategy is they kind of overlook this off by one nature, right?\nSo technically, I'm creating an array that has one greater length than my number input.\nBut any case, if this is my array, what do I want it to represent? Well, in the long\nrun, I want to actually fill out this array in a way where each subproblem corresponds\nto an elements of this array. So here's how I'm going to begin this table. The move here\nis to actually initialize every position of this table with zero. And the reason for me\ninitializing zero everywhere in this array is the fact that I know Fibonacci requires\nme to take a sum, right, and zero is a really great starting value when I need to calculate\na running sum, right. But along with that, I need to be sure to seed the starting values\nwithin this table. In other words, if I look at the zero position of this table, it already\nhas a zero, which makes sense because the zero number on the Fibonacci sequence is zero.\nBut what I should also do is make index one contain a value of one. And that kind of entails\nthat, hey, the first Fibonacci number is indeed one. And now at this point, once I've seeded\nthose initial values, now I can actually run the general algorithm to fill out this table.\nSo now it's just a matter of iterating through this table, so I'm going to start you know,\nat the very first position of the table, probably just with a regular for loop. And what I need\nto do is really remember the definition of Fibonacci, right. So if I have this number,\ncurrently in the array zero, that's a zero Fibonacci number, what I can do is just add\nthis current number that I have kind of pointed to in yellow to the next two positions. And\nthe reasoning there is a Fibonacci number is used to contribute to the sum of for the\nnext two Fibonacci numbers. So I'm going to do is take the zero and add it to the next\ntwo positions, obviously, since it's zero, actually don't change the values of those\nnext two positions. It's nothing really is calculated on that first iteration. But any\ncase I can continue on to the next iteration, so my current position is always in yellow,\nand the next few positions are pointed to in blue. At this point, my current position\nsays one is what I should do is take one and add it to both of my next positions. So that\nmeans two and three are indices two and three are contained both a one and a one which so\nfar, make some sense because at least for the to the second number of the Fibonacci\nsequence is indeed one, I can do the same thing, right, my current position contains\na one. So I'll add that one into my next two positions. Keep doing this, I add two to my\nnext two positions, at three to my next two positions. And at this point, I sort of reached the end\nof my array. So I know that I probably shouldn't step out of bounds. So really just want to\nlook one position ahead over here. And at this point, I just add five into my next position,\nwhich actually works out to an eight being stored in index six of this array. Which makes\nsense because logically, the six number of the Fibonacci sequence is a just like we intended.\nThat's all there is to tabulating Fibonacci, the most apparent difference from our previous\nlike recursive strategy was, this is not recursive, right? This really just requires us to iterate\nthrough an array. So to fully iterative process. And at this point, the actual complexity of\nthis is really straightforward to kind of foresee, we know that we're just going to\niterate through an array of size n, that must mean that our time complexity is just n. In\nthe same way, the only space we use is really just the space of the array, which I know\nis still going to be sighs and as well. So overall, we're looking at a linear solution\nfor fib. So before we hop into the code, for this one, I just want to draw a really important\nconnection. So although at face value, this iterative strategy looks very different from\nthe recursive solution, a lot of the logic really carries over, I'm still using my overlapping\nsubproblems to solve this one. So for example, I know that every index of this array really\ncorresponds to some number input for fib of n, right? So I can kind of visualize it like\nthis, right? Like we said, the six of bonacci number is eight. So I'm just going to choose\na position of this table, let's say I looked at fib of six. So I know that to calculate\nfib of six, what I did was really add the previous two numbers into this position, right.\nAnd if you kind of see that the shape of this, I kind of dropped the table, and even just\nignore the rest of the subproblems. This is basically just a tree that can kind of shift\nthings around. And it really looks like this. So overall, you're looking at really the same\nrelationship for calculating Fibonacci. It's just encoded in a table instead of the recursive\ntree. But overall, if you understand, you know, the recursive solution, you should still\nfind, you know, some comfort inside of this iterative solution. But I think at this point,\nlet's hop into the code for this one. Alright, programmers, let's go ahead and translate\nthat strategy into some code. So I'll start by creating a table, which really just means\ncreating an array, we'll call this table. And I need this array to have certain dimensions\nthat are roughly the size of n. So to do that, in JavaScript, I can say array and call a\nstatic method and pass in my desired size. So here, I want to say n plus one. For the\nreason we did in the sketch, right, I need to make sure that the last index of this array\nis exactly n, I have to do a plus one here, because of course, indices start at zero.\nCool, that should give me an array of that n plus one size. And then at this point, what\nI want to do is assign particular values into this table. So let's just say I console dot\nlog, what this table looks like, I'll just run this first example of fib of six. So I'll\ngive this a go. So notice that the array that prints out is this, it says like seven empty\nitems, which means that the elements are undefined right now, according to our strategy, but\nwe should do is assign these all to zero. So what I can do is, after I initialize the\narray over here, I can fill it up with all zeros using the dot fill method, right? It's\nan array instance method. So with that change, now I should have a seven zeros inside of\nthis array. Cool, so it's looking pretty good. At this point, I also need to fill up a particular\nvalue inside of the table, I really need to make sure that the index one contains a value\nof one, right so I can say table at index one equals one. So we're seeding index one\nwith a value of one to symbolize that the first bonacci number is one, remember that\nwe kind of have like two base scenarios. In Fibonacci, let's just console that log with\nthis table looks like now to make sure it's in the correct state before we actually iterate\nthrough it. Cool. So this is a good starting point for our table. So at this point, what\nI want to do is iterate through the table. So use a regular for loop for that. We're\ngonna need access to the indices. So I'll say let i equals zero. And I'll go up to and\nincluding, and basically give me iterations through the entire table. And I'll do i plus\nplus, I'm going to hit every position. Cool. According to what we did in our strategy.\nWhat I should do is look at the next two positions after I right, so I'll say as I'm gonna look\nahead and table and I'll look at positions I plus one, and also i plus two, right? Of\ncourse, right now I'm currently situated at position I. And what I did was I added into\nthose two neighboring positions, I added my current value in the table. So what I'll say\nis, in my next position i plus one, I'm going to increment it by exactly what table I says,\nright? So I'm incrementing, my next position by the value in my current position. And the\nsame will hold true for the next position two spaces away, right, so they both get plus\nequals table. I know nice. So this is looking pretty good.\nAfter we're done doing this process for the entire table, where we're just going left\nto right, filling in our next two neighboring positions, what we'll do is just return our\nanswer, which should be table at position n, right? To finish this off, I just want\nto return the table at index n, because the elements of this array correspond to the Fibonacci\nnumber, right? And the index is sort of the input to my function. So let's try these examples.\nWe'll give them all ago. Cool. So I get 813 21. In this very large\nnumber, this actually looks correct. Nice. This is a fair implementation of Fibonacci.\nNotice that because we're already using an iterative strategy, we already satisfy a decent\ncomplexity for even this, this last example over here, we already mentioned the time and\nspace complexity of this strategy, right, it gives us a linear time and space. However,\nyou may already have in your head that we could actually optimize a little more here\nand just use a constant amount of space. However, if you want to kind of subscribe to just a\ngeneric tabulation strategy that I know is going to be useful in most problems, I will\nkind of stick to this overarching pattern right of initializing our table upfront, that\nis roughly the size of the input, and then iterating through that table. Of course, you\ncan probably finesse this fib function to only track two variables represent your last\nFibonacci number, as well as your last last Fibonacci number. But I'll leave that to you\nbecause it's not really a classic tabulation, which is a topic want to drill into our heads\nright now. Let's head back to the drawing board and do another problem. All right, now\nlet's revisit that grid traveller problem using tabulation. So like before, we're going\nto have a 2d grid, and we start in the top left corner. And our goal is to go to the\nbottom right corner, we only have two possible moves at any point in time that is to move\ndown or to the right. And how many ways can we actually travel to the goal, if we had\na grid of dimensions, m by n. And we want to write our function to actually calculate\nthis. So let's trace through how you can build a table for this one, let's say we're going\nthrough grid traveller of a three by three grid, that means that our output should be\nsix in the long run. So like before, our first step in this tabulation recipe, is to create\na table that is roughly the size of the input. And so here I have two inputs, and they really\nrepresent the number of rows and number of columns. So I can create a 2d array to correspond\nto that. Like before, if I want the indices to match up here, I'm going to have to make\nsure that this two dimensional array has dimensions four by four, right? If I give it a four by\nfour array, that means that the bottom right index is really three comma three, which works\nout nicely, very similar to what we did in that last fib problem. Cool. So I established\nthe dimensions for my table. Now I have to figure out what should I actually begin my\ntable with, right? What are the good seed values to use here? Well, I know this is a\ncounting problem, right? Because they're asking me to count the number of ways to travel through\nthis grid. For these counting problems. Good initial value to choose is usually zero. So\nI'm going to put zero everywhere in this grid. But at that point, I may need to seed another\nvalue in other position in this table, if you recall our previous discussion about this\ngrid traveler problem, we said that it's a really important case that all right grid\ntraveler have a one by one should return one right there is one way to travel the gray\none by one grid. And so I'll go ahead and actually take that information and encode\nit into my table. So I'll make index one one, actually contain the elements of one. And\nI should give me a nice starting point for this algorithm. So at this point, what we\nwant to do is iterate through this table and come up with some logic that combines the\nvalues in this table, right, basically combining different subproblems to solve my larger problem\nat hand. So let's just begin in the top left corner of this grid. In the long run, we can\nreally implement this kind of iterative pattern through a grid using just some nested for\nloops, right. And the key insight is I know if I'm at this position, if I see zero at\nindices, zero comma zero, that means in a zero by zero grid, there's zero ways to move\nthrough it, which makes sense, right? Because if any of your dimensions contains zero, then\nthat must mean that your grid is empty, right? So the game isn't even valid. But if we want\nto have some consistent logic, the move is to use your current position highlighted in\nyellow right now and add it to your neighbors, right, according to the game, I can only move\nto the right or downward. So technically, what I'm doing right now is I'm taking my\ncurrent positions element, and adding it to my down neighbor and my right neighbor. Obviously,\nif I just have a zero in my current position, then really no arithmetic takes place. But\nlet's go ahead and do these iterations just to make sure we have consistent logic, right,\nso they keep adding these zeros to their right and down neighbors, nothing changes for now,\nuntil I get to the next row, right, this first iteration, next row, still just add zero to\nits down and write. But once I'm at this point, I'm going to take this one, I'm going to add\nit to my right and down neighbor. So that means they both turn into a one, I keep following\nthis pattern, right, both of my neighbors turn into a one. And obviously, whenever I\nkind of reached like the bounds of my grid, I need to probably make sure that I don't\ndo any illegal Array Operations. But that's really an implementation detail for the code.\nSo on to our next row, we contribute zero to both of our neighbors. Here, we contribute\none to both of our neighbors. Now we contribute to to both of our neighbors.\nAnd here we contribute three to both of our neighbors. And finally, things get interesting\nin the very, very last row, I contribute zero to my neighbors, I contribute one to my neighbor,\nI contribute three to my neighbor. And at this point, we've kind of finished iterating\nthrough the entire grid. And if you look at this position, it contains a six symbolizing\nthat, hey, how can you actually travel through a three by three grid? Well, there are actually\nsix different ways you could do that. So before we jump into the code for this one, you can\nprobably already foresee the complexity of this. So we know that the complexity is really\ndriven by the dimensions of this table, I know that this table is going to have m rows\nand n columns. So if I need to iterate through this table, it's just going to take m times\nn time. And along with that, what is the space that we need? Well, it's really just a space\nfor this 2d array, which is, of course, still m by n. So overall have m times n time and\nspace. Let's jump into the code for this one. Now. All right back into the code editor.\nLet's work on implementing this grid traveller tabulation strategy. So we'll start by initializing\nour table, which is going to be a little more complex here compared to our last function,\nbecause it needs to be a 2d array. So what I'll do is I'll start by creating, let's say,\nthe correct number of rows. So that will be as simple as calling array. And I want really\ndimensions m plus one, again, I have to adjust for that off by one error, because I want\nthe max index in this table to actually be exactly right. And I know indices start at\nzero, so I'm going to up it by one over here. Cool. So I'll give me the correct number of\nrows. And I want to make sure that the elements inside of this array are also other sub arrays.\nSo a trick I can do for that is we're going to fill this is kind of just a very particular\nJavaScript pattern, I'm going to call fill on this array I just created. And afterwards,\nI'm able to map over it. Cool. So maybe I'll spread this out like this. And when I map over this array, what I want\nto do is make sure that every element of the array is going to be a new array like this,\nthis time of dimensions n plus one though, so I have roughly m rows and n columns. So\nlet's go ahead and just see what the shape of this is. When I print out, let's say the\nthree by two example. So we'll go ahead and run this code. So notice that if I look at\nthe arrays I printed out here, it looks like I have a four by three array, which makes\nsense because again, I increase my initial dimensions by one that looks good to go. However,\nwhat we'll want to do is really understand how what this map is useful for. So a very\ncommon mistake that you might be tempted to do is Can't I just, you know, skip this map\npart, and then do the fill with the array of n plus one. So that will look like it gives\nyou the same thing. So I'll run that code. But if you write it this way, what you're\ndoing is you're filling the entire outer array with a single array instance multiple times,\nright? So the shortcoming of this code is let's say I kind of change only one position\nof the table, let's say I just made an X kind of arbitrarily, that would actually look like\nit changed many positions of the grid, right. And that's because this is technically just\none array that's inserted multiple times into the outer array, whereas I need a really unique\narray references. So that's how we need the map pattern here. I know every time we evaluate\nthe callback function to map, it's actually going to execute this entire function, which\nmeans it's going to give us a new inner array instance. Right. So if I use this map pattern\nI run again, this is really the intended behavior, right? I have a unique array as a sub arrays\nhere. And so let's take out this expert. But that being said, Now that I have the correct\nshape of my table, I need to insert some good starting values, right? So what are the seed\nvalues here, while we're calling in our strategy, we said that basically the entire table could\ncontain mostly zeros. So maybe I'll bake that right into this line. So after I make a new\nsub array, I'll be sure to fill it with some zeros. So if I run that, now, I should have\na nice table, because that's looking pretty good. At this point, I also need to see another\nvalue, right? We talked about it in that we should see table at position one, one with\nexactly one, this is sort of like our base case, when we have a one by one grid, there's\ndefinitely only one way to travel through it. So now we have the elements of one in\nposition. One, one. Nice. So at this point, now I need to iterate through my table and\nfill in other positions. So I'm going to use just nested loops for this. So I'll say let's\ni equal zero. And I want to make sure that I goes up to and including m right, basically\nthe dimensions of the table, and I'll do i plus plus. And very similar for my inner loop\nbeing sure this time to reference j and j is gonna go up to n this time, because we'll\njust have classic nested loops just iterating through this two dimensional array, right?\nSo as I'm iterating through the table, what was the logic we trace through in our drawing?\nWell, I what I needed to do was take my current element that I'm at, so maybe I'll call it,\nlet's say, my current. So my current element would be at table ij. So I need to take this\ncurrent element, and I need to add it into my right neighbor, and my down neighbor, right.\nSo if my row is I and my columns j, that just means I do some arithmetic on i and j. Right.\nSo if I want to increment my, let's say, right neighbor, what I can say is, look at table,\na position i, j plus one, that'd be directly to my right. And I'm going to increase it\nby whatever this current is, if I want to look at my down neighbor, and that'd be i\nplus one, but I keep j the same. Cool. So this will add to my two neighbors that are\nto the right of me and below me. And at this point, what we have to be aware of is like\nwhat happens at our edges of this table, we know that if we're already at like the last\nposition of a row, if I do j plus one, I'm gonna go out of bounds. And so to make sure\nI don't step out of bounds on these increment expressions, I'll need some conditional logic.\nSo I'll say if the right position is inbound, so if j plus one is less than or equal to\nn, then I'll go ahead and increment to the end should be okay. And likewise, if i plus\none is less than or equal to m, then I'll also increment right? Notice that when I checked\nmy like j value, that should be using n, right, because that's the number of columns and then\nI is a number of rows. So it should use M. Cool. So what I have so far as I'm iterating\nthrough every position of my table, and I'm going to take the elements at my current position,\nand I'm going to add it into my right neighbor, as well as my down neighbor, about only if\nthey actually exist. Cool. So once I'm done filling up the table, then my final answer\nshould just be at position m, and right just the very bottom right corner here. So let's\ngive this code a run. So I should get 1336. And then there's a very large number, or run\ngrid traveller. Nice and looks like this solution is totally\nworking. And we are already satisfying our the last example here, right? If you tabulate\noff the bat, you will have a pretty quick solution. And we already traced through the\ncomplexity for this. So take a moment to you know, look at this code, let it sink in, or\nreally try to understand how we took that whiteboard strategy and implemented it in\nsome code, right? We do have to do some like kind of fine implementation details, especially\nwith the bounds checking here. But I think the most important logic, it's about how our\ncurrent position of the table contributes to our immediate neighbors to the right and\ndownward. With that, I think let's head back into the drawing board. Alright, now that\nwe've seen tabulation in two different problems, hopefully we're noticing some patterns right?\nLet's give ourselves some rules we can follow to tackle any dynamic programming problem\nusing a general tabulation strategy. With this tabulation recipe, it's going to be pretty\ndifferent compared to our memoization recipe in that there aren't two main steps when I\ntalked about memorization I said, make sure you implement the brute force first, and then\nadd the memorization app. Towards. Whereas if you just try to tabulate a problem, you're\nreally going to have the most efficient version of your solution all in one swoop. And so\nwhat is our first step for tabulation? Well, of course, you have to visualize it as a table.\nAnd that really begins with a conversation of what you'd like the size or dimensions\nof the table V, that should definitely be correlated based on the size of the input.\nSo in the case of fibonacci of n, we made our table roughly, you know, n elements long,\nsometimes you definitely have to watch out for like an off by one scenario, which we've\nbeen seeing lately. In the case of our grid traveler problem, we saw that because our,\nyou know, problem represents a grid, we had to create a two dimensional table at that.\nSo figure out the size of your table based on the inputs to the problem. Cool. And once\nwe do that, we need to initialize some values within the table. To me, this is always about\nchoosing compatible types. In other words, if your problem asks you to return a number,\nthen it'd be wise to initialize the values of your table with numbers right? On the flip\nside of that, if I was asked to return a Boolean in a problem, Na, consider initializing true\nor false within the table. Cool. And once I have all of the kind of generic values filled\nup in the table, then I choose my very important seed value, right? I know that this seed value\nshould capture the scenario, where I have a trivially small instance of the input where\nI automatically know the answer, right. So in the case of our classic Fibonacci, that\nmeans I just seed the N one and the N two values of my table with one and one respectively.\nAnd in the case of our grid traveller, we were sure to capture the scenario where we\nhad a one by one grid, so you're gonna need to see those values, because that's the basis\nupon which we fill the rest of the table. And then we have the hard part, which is really\niterating through the table. And you have to come up with some logic, right, as you\niterate through the table, you have to design some logic that fills further positions of\nthe table based on the current position. And you really have to, you know, look to the\nproblem to figure out what the logic is. In the case of Fibonacci, it's as simple as if\nI'm at some position of the table, I look one space ahead and two spaces ahead, very\nreminiscent of the pattern Fibonacci, in the case of our grid traveler problem was about\nlooking the unit to the right or the unit downward, effectively shrinking the size of\nour grid. So it's really up to you to figure out the logic, look for it language in the\nproblem. What I always do is focus on what options I have at any point in the problem,\nright? My options are Do I go rightward? Or do I go downward in that grid traveler and\nproblem. So we'll stick to these rules as we tackle our a tabulation problems, and we'll\nutilize them right now. Okay, so let's work on tabulating our can\nsome problem now. So recall that in this problem we want to do is take in a target sum as an\nargument, as well as an array of numbers. And we want to return a Boolean indicating\nwhether or not we could generate the target sum. By adding numbers in the array, we can\nreuse an element of the array as many times as we want, we can also assume that all the\ninput numbers over here are non negative. So we've solved this problem before, right?\nrecursively using memoization. But now we want to use a tabulation point of view. So\nlet's come up with the strategy here. So let's say I gave you this input of seven and an\narray of 534. In the long run, the answer is true because it is possible to generate\nseven, right, you can either do a three plus four or a four plus three, and that would\ngive you your original target. So you know that in the first step for tabulation, all\nwe need to do is create a table. But I guess the question here is, what size table do I\ncreate, I have two inputs, I have the target as well as the array of numbers, which of\nthose actually contribute to my initial table. And so the key insight is to think about,\nyou know, what's going to change throughout the problem. In other words, if we can reuse\nthe numbers of the array as many times as we need, then it's not like we're shrinking\nthe size of that array. However, if we think about the target number of the target, some\nthat were given, we do have a goal of actually reaching that target. So now we're going to\nincrease to it over time. And so I'm going to use that as a basis for my table. That\nis, I want to create an array that is roughly the size of my target sum. So because the\ntarget sum is seven, I want to make sure that the indices lined up perfectly. So I'll actually\nhave to create an array with length eight. And in general, I just be creating an array\nof length target sum plus one, because we have that classic off by one error over here.\nAlright, now that we have the correct size of table, what do I actually want to store\ninside? That is what should the eventual elements of this array be? So a really nice rule of\nthumb you can use for that is to just recognize what type your answer should be. In the long\nrun, right, so here, they're asking for a Boolean answer. So that really tells me that\nI should probably put some boolean data as the elements of this array. So I'm going to\nstart by initializing every element of this array with a false value. And the reasoning\nis right now we're kind of assuming before we check anything, that none of these target\nsums are actually possible to be generated. Cool. But neither think about any particular\nseed values, I need something inherent to this can some problem is we treat the target\nsum of zero very special, right sort of the base that we use. In other words, someone\ngave me a target of zero, I know that that is always possible, no matter what elements\nI have in the array, because to generate zero, I can just take no elements of the array.\nSo that's going to be a really important seed value here. So I'm going to populate index\nzero with the element. True. Cool. So now that we have some good seed value, now we\nwant to think about how we can flesh out the other elements of this array, sort of in a\nlinear fashion, right? So I'm gonna have to iterate through this table. So let's just\nstart at the very first index. So right now I'm looking at index zero. And if I'm situated\nin any position of this array, then the value I'm currently looking at, should basically\nsay, you know, is it possible to generate that index amount? In other words, since I\nhave a true at index zero, then I know that it is possible to generate zero using the\ncoins of the array. But now that I'm at this position, how can I actually transition into\nthe further positions of this table. And so what I want to do now is consider the possible\nnumbers that I can take into my sum. So I'm going to start by looking at this first element\nof five. I know that if it's possible to generate zero, then if I also have a five in the array,\nthen it's also possible to generate five in the context of my array, that means I should\nlook about five spaces ahead from my current position. So I look at this spot, right, exactly\nfive indices ahead. And right, now I should actually replace this false value that's stored\nat index five, with a true and again, the reasoning is, if it's possible to generate\nmy current amount, right, right, I have a true in the zero, it's possible to generate\nmy current amount, and I could take a five, that means that the position of five steps\nlater should also be true, right. And I want to actually continue this process for the\nother values in my numbers array. So I'm just going to look at the next element of three,\nthat's basically telling me that, hey, the next spot three places away should also become\na true, so I'll just go ahead and make that a true. And finally, likewise, for the last\nelement of four, right, the element four spaces ahead, should also be turned to true. Cool. And at this point, I think I finished\nlike my very, very first iteration, that is when my current is at index zero. And at this\npoint, I just want to keep iterating through the array, so I'm just gonna shift my point\nof view, or one space to the right. So now I'm looking at my current as index one. And\nwhat does that over here, my current element is actually false. So what that means is,\nit is not possible to generate one using the numbers of the array, which logically makes\nsense, right, I only have five, three and four. So there's no way you can ever give\nme back a one, right. So if I have a false value at my current position, then I should\nnot modify like my further values by looking ahead. So notice that if I look at my edge\nfor five, look, five spaces ahead, I am not going to make that a true because my current\nposition is not true, right. So I'm going to keep iterating. Same thing happens when\nI'm at index two, because the current value is false, there's nothing to be done here,\nthings get really more interesting on this iteration right? at index three as my current,\nthen I see a true at this position. So that means I need to look ahead to my future positions,\nand actually assign them to be true. Obviously, you'll notice over here, if I look five positions\nahead, when I'm currently at index three, then that would actually be out of bounds.\nSo I don't need to look that far ahead. So we'll kind of drop that connection. But at\nthis point, I should make the space three positions ahead truth, that's almost a space\nfor positions ahead. So that means that indices six and seven are set to true, right? I keep\ndoing this process all the way through the entire table. Notice that as I keep iterating\ntoward the right, these forward looking references kind of stopped being useful because it goes\nout of bounds. But the point is, by the end of all of these iterations, I do have a true\nstored at index seven, which means that it is possible not to generate a quantity of\nseven. And if I do a quick spot check, and I look at just my entire table right now,\nit has very consistent data. In other words, if I notice where all of the true values are\nright there at 03456, and seven, that means that all of those quantities for target are\nactually possible, right? On the flip side, if I look at the only elements and indices\nthat are false, like one and two, that makes sense, because those are the only quantities\nthat are not possible or you can't possibly generate a one and two, using a five, three\nand four as your option. Adding up, right? So we know by the end of this algorithm, the\nelement that is stored at the last position of our table would be the final answer, right?\nSo if it's true, then it's possible if it's false, it is definitely not possible. All\nright, so let's wrap up this sketch by actually talking about the complexity of this, as always,\nwe'll define our terms. So we'll say that n is going to be the target sum, which is\njust a number. And the flip side of that will say that n is going to be the length of the\nnumbers array. And we already have the vibe that, hey, both of these terms definitely\naffect our complexity, right? If you give me a larger target sum, that's probably a\nharder thing to calculate. In the same way, if you give me more numbers to choose from,\nit's even harder to calculate, right. And we can recognize that the algorithm just has\nus flesh out this table. And I know that the table is of size m, so we're going to have\nat least M. However, as I iterate through every position of the table, what I had to\ndo was actually look ahead in the table for every single element of the numbers array.\nSo I know that that's going to be accomplished basically, using some nested loops, where\nI'm going to have a loop to iterate through just the table, and then a nested loop to\niterate through every number of the numbers array. So overall, I'm looking at N, N times\nN, time complexity. And along with that, where does this space here? Well, the space is really\njust the exact size of this table, which is based solely on M. So I have just m space\noverall. Nice. So this is already looking like an efficient implementation, especially\nbecause we're not dabbling with any exponential complexity over here. I think let's work on\nthe code now. So here we are back in the code editor, let's start like we usually do by\ncreating our table. So I'll store this table, and like we discussed in our drawing, we need\nto make it roughly the size of our target sum. So I'll create an array, I need to make\nsure that the indices lineup directly or at one index, that is exactly the target sum.\nSo I'm going to initialize it to target sum plus one, right. So that means if I pass in\ntarget sum is seven, when I create an array of length eight, which means that its very\nlast index is seven, which is perfect. Cool. And while we're here, we'll go ahead and actually\ninitialize this array with all false values. So I'll do that. I need to make sure that\nI seed index zero with a true symbolizing that the target sum is zero, it's always possible\nto be made, even before I look at, you know what's in the numbers array. So I'll just\ngo ahead and say, table at index zero is equal to true. So let's just console dot log, what this table\nlooks like so far. And I'll just run, let's say the second example here. So I should see\nmy array of length beat, up need to go into this tabulation folder. Now I'm going to run\nthis guy. Cool. So it looks like a good table, right? eight elements. And I do have a true\nat index zero. Nice. So at this point, now I want to actually lay out the core algorithm\nby iterating through the table, somebody who's a regular for loop here, let's say let i equals\nzero, go up to I can even include if I wanted to, up to an including the table dot length\nis you could also say a target some here some thing based on target some I'll do i plus\nplus. And here I'm going to choose to iterate using, you know the manual index, because\nI know I have to do some arithmetic to look ahead on the array. But as I iterate through\nevery element of the array, I want to actually check you know if this position is true, so\nI'll check if table at index AI is true. Cool, they know inside of this if statement, I need\nto basically jump ahead or look ahead, based on what's in my numbers array. But I only\nneed to do that if my current position is true, right, I only got to look ahead, if\nit's even possible to get to this current amount, right, the current amount I'm sort\nof tracing through would be at index i. So at this point inside of my if statement, what\nI want to do is now look ahead for each a number of this array, so a nested loop here.\nAnd I just want to look at the elements of this array. So I'll say for, let's say, let\nnum of numbers. So I'm grabbing each element this time. And now for this number element,\nI want to look that many spaces ahead. So I want to look at basically table at index\ni plus the number. Cool. So imagine that I'm on like the first iteration of this, I know\nis going to be zero. So that's the very, very first index of my table. And if my num is\nfive, then I'm going to do zero plus five looking five spaces ahead right just like\nwe did in our trace. And for this position, that is like five spaces ahead. I want to\nassign it to be true, basically saying that, hey, if my current position is reachable,\nand I can take a step of exactly numb then that must mean position. I plus numb is also\nreachable write that entire for loop goes inside of this if statement, right? So this\ncode is looking pretty good. So far, I think the last thing we need is just to return our\nfinal answer. After we're done iterating through the table. So here I'll just return table\nat index targets. Cool. So let's, let's go ahead and run these examples. Maybe we'll\nhave to debug some stuff. Looks like I have a probably an infinite loop. Yeah, my program\ncrashed with some massive error. So let's debug this one together. There's something\nthat I'm not considering in my code. But we did consider when we drew it out. So something\nthat is probably breaking right now is having to do with like the bounds checking. Something\nthat's kind of unfortunate in JavaScript is this characteristic, this may have different\nbehavior, depending on the programming language that you're following along in. But I know\nin JavaScript, I had some array, let's say, array, and I set it equal to just a handful\nof elements, let's say a, b, and c, if you actually do like array, at some out of bounds\nindex, like index, I don't know 10. And I assign it like x, that will actually change\nlike the effective length of this array. So if I take a look at what happens here, so\nI'm just running this kind of offhand example, when we run this, notice that we have about\nseven empty items before we have the X. Basically, when you do this type of weird assignment\nin JavaScript, it's going to like lengthen your array. That way, it makes sure that this\nHey, new element of x is placed at exactly index 10. And so why is that relevant? Well,\nin my code, here, I don't really check if I'm out of bounds, right, and I just assign\nto something that's potentially outside of the current length of my array of my table,\nrather. And if I do that, then this condition is a little suspicious, right? Because if\nI do this assignment on line nine to an out of bounds position, then the length will get\nlonger. And that's sort of like a circular argument, right? I keep iterating, only to\nmake more stuff out of bounds, only to lengthen the table even more. So that's why I ended\nup with like an infinite loop over here. One way I can fix that is to just maybe limit\nthis, so I won't make a table outline that's a little too dynamic. I know, I can basically\nstop once I reach the targets. So that might actually be the better move over here. Pretty,\npretty fair bug though. With that, let's go ahead and run this code\nagain. give that a shot. Here we see true true, false, true and false. And that is the\ncorrect answer over here. Nice. So here's a nice tabulated solution for our khamsum\nproblem. And we already spoke about this code having n m times n, time complexity. Now it's\nreally obvious, right? Because I can see how these exact the loops. And our space complexity\nis simply based off of M right. Cool. With that, let's head back into the drawing board\nfor another problem. All right, now let's work on the house some variation of this problem.\nSo like before, I'm gonna take in the target some as well as an array of numbers. But this\ntime around, what I want to do is return an array containing a combination of elements\nthat actually adds up to the target sum. Right? So here, I want to return exactly one way\nif it's possible. And along with that, let's say that it's actually not possible to return\nthe target sum, then I should just return the null value. And if it's the case that\nthere are actual multiple combinations that can generate the target sum, I can return\nany one of those. So we expect the strategy for this one to be very similar to our last\nproblem. However, we will need some nuanced logic to return the array now, right? Because\nI don't want just boolean data once return an array. So let's sketch this one out. Let's\nsee I'm stepping through this example. Or my target is seven and my array is 534. For\nthis input, a reasonable answer to return would be an array of three comma four, right?\nBecause I can add three plus four to get seven. You can also I guess, switch around the order\nof these elements. So if you also returned four comma three, I think that would also\nbe a valid answer. Point being, I just want to return at least one way that can generate\nthe target. So we know we want to solve this one with tabulation. And so we'll just follow\nour recipe right? And I need to construct an initialize some table, we already know\nthat the size of this table is going to be based on the target sum, so roughly seven\nelements. But we of course, have that classic off by one nature, right? Because I want the\nlast index of this table to align with the actual number argument. And in general, I'm\ngoing to initialize this array with a length that is target sum plus one. Cool. So now\nthat I have the correct shape of table, what do I actually have to initialize as elements\ninside of this table? Previously, like the Boolean version of this problem, we initialized\neverything as false, right. And the reasoning there was, before we actually try all the\npossibilities, we're going to just assume that it's not possible to generate every quantity.\nWe just want to adapt that for this new type of problem. They tell us that if it's not\npossible to generate amounts, then we should just return null.\nSo I think null is actually a great initial value to just put everywhere in your table.\nSo at the start, we're going to assume that none of the values or none of the amounts\nare actually possible to be generated. No is sort of the analog for false in this rendition.\nCool. So now that I have most of the values added to the table, now I need to figure out\nwhat's the appropriate seed value, I need some actual data to begin and get the ball\nrolling on this one. So like we expect, it's about having an amount of zero, right, no\nmatter what if you're given an amount, or a target sum of zero, and no matter what array\nof numbers are given, you can always actually generate that quantity of zero, by just returning\nthe empty array, right, you can take zero elements from the numbers array, and there\nyou have an array whose sum is zero. So of course, that means at index zero of our array,\nwe're going to initialize it with just an empty array. And at this point, what we want\nto do is, of course, iterate through our table and come up with some logic we can use to\nfill out further positions to the table based on our current position. So let's say we begin\nat index zero. So here I am. And I have to figure out which further positions of the\ntable should I be looking at, we've seen this pattern before, I should just base that off\nof what I have as options in my numbers array. So look at my first number of five, that means\nI could look exactly five spaces ahead in the table at this position. And so if I know\nthat my current position is possible, but I see that I have an array and my current\nposition, I know it's possible. If this current position is possible, then a position exactly\nfive steps later would also be possible, right. And so what I'll do is I'm just going to copy\nmy current value into my further value. In other words, I want to put an empty array\nat position five, right. However, I also have to include the number that I'm using right\nnow, right, I took a five to actually get to this position in the first place. So I'm\nalso going to add a five into that array. Cool. If I do a quick spot check, this is\na reasonable thing to do. Because if I look at the state of that index five, it contains\nan array of five, meaning that hey, you can return a sum of five by just taking a single\nfive. And with this, I want to do the same logic for the other numbers of the numbers\narray, right. So if I have the three, I'll look three positions ahead of my current place.\nAnd I'll also start by copying over the array at my current position. So I copy over the\nempty array. And after I copy that array, I actually want to populate it with the number\nthat I took to get to the spot in the first place. So I just go ahead and put a three\nin that array. And the same thing happens for before. So if you go to the next iteration, you see\nthat our current element is null, that means that the amount, right in other words, our\nindex amount, is actually not possible, it's not reachable, meaning we can't get an amount\nof one by adding up any numbers of the given array. So what I should not do is actually\nmanipulate any further values from this position. So I just continue these base iterations.\nSame thing happens when I'm at index two, things get more interesting when I'm at index\nthree, right, I see that the element here is not null. So it is possible to generate\nthree. And so what I want to do is go ahead and look at my my forward values, and for\ncopy my current array over. So I know I don't need to look five spaces ahead, because that\nwould be out of bounds. So I'm going to look at the position exactly three spaces ahead\nin the table and copy over my current array like this, what I also need to do is make\nsure that I include the number that I'm using right now, which is three, right, because\nI'm looking three spaces ahead. So I end up with three comma three, at index six of my\ntable, which is reasonable, right, I also want to do something very similar for the\nposition four spaces ahead. So I'm going to copy over my current array, but then also\ninclude the four that I'm using up right now. So now have three four over here. Cool. At\nthis point, you can kind of see where this is heading right, I've actually already populated\nindex seven of my table, and three comma four is exactly a one way we could create the seven.\nSo we could stop here. However, let's say that you continued the algorithm. So in the\nnext iteration, I know that this space for the indices ahead would be out of bounds,\nso I don't need to look there. But according to our general logic, I would actually manipulate\nthe spot of the table three moves ahead, right. And so what I'll do is if I, you know, follow\nthe same exact logic, I'm being consistent, not really changing any of the rules here,\nI would copy over my current array into that position. So I basically overwrite index seven,\nwith just an array of four. But then at this point, I would also be sure to include the\nnumber that I'm using right now, which is three, right, because I'm looking three spaces\nahead. So I end up with four comma three, which happens to be like another way I can\ngenerate these seven. So it doesn't matter if you actually continued this algorithm,\nright? So if I continued on basically just keep iterating until I hit the very And and\nwhat do I know the element at index seven is exactly an array of four, three. Cool.\nSo the point is you actually don't have to like exit early. As you iterate through the\ntable, you'll be okay to just finish all of your iterations. And you'd still have a valid\nanswer, right? Because in this problem, they just want any way to actually make the target.\nAnd if I take a quick look at my table, I think all of the stored values here make some\nlogical sense. For example, if I look at index two, there's a null, meaning that it's not\npossible to make a two by using elements of the array. In a similar way, if I look at\nindex four, there's a sub array of four, meaning you can just take one four, to make a some\nbefore. Similarly, you can take two threes to make a sum of six. And of course, you can\nmake a seven by doing four and three. So now that we have a plan of attack, let's look\nat the complexity for this. So of course, the M will represent the target sum, and our\nn represent the length of the numbers array. So if we begin with just the time complexity,\nwe know that we're going to at least iterate through the table and the tables of size m,\nright. So I have at least an M in my time complexity. But for every space in the table,\nor in every iteration of that loop, I need to also iterate through all of the numbers\nin my number input array. And so I can multiply by n over here. Nice. But at this point, now,\nlet's say that I actually need to take a valid step here, then what I also did was copy over\nthe array at my current position into that forward looking position, I know that a sub\narray will be at most of length m, remember that m is our target amount, the worst possible\nor largest way we can generate the target sum would be to have an array of exactly m\nones, right. And so we'll say that in the worst case, we have to copy over an array\nof an additional length m, that means our time is really m squared times. And now let's\ncome up with the space complexity for this, we know that the initial size of the table\nis definitely based on M. However, in the long run, we could be storing a sub arrays\nas elements. So this is going to actually be a 2d table. In a sense, I know that the\nsize of any particular sub array here is also going to be m for the same reason we just\nsaid, and so we'd have a m squared space complexity. So overall, we're pretty satisfied with the\ncomplexity of this. Because it's polynomial, right? It's not an exponential quantity. So\nit should run in a reasonable amount of time. All right, I think we're ready to hop into\nthe code for this one. Alright, programmers back in my trusty editor,\ngo ahead and tabulate this one out. So we'll need to create the table to begin, right.\nSo I'll create my table, and it should have roughly targets some positions in it, really,\nI need to increase it by one. So I'll say array, and I'll pass in target sum plus one,\nthat way the final index aligns, I'm going to go ahead and fill this table up with all\nof those nulls. Right, exactly what we did in our drawing. What I also need to be sure\nto do is make sure we populate index zero of our table with an empty array serves as\nsort of like a base case, in that we know that the target sum of zero can always be\ngenerated, right, you can generate the target sum of zero by taking no elements from the\nnumbers array, right? If you took the sum of this array, it would be zero. Nice. This\npoint, we need to iterate through our table. So you've seen this code before. I equals\nzero, go up to and I won't mess this up this time, I go up to an including target some\nI'll do i plus plus. So so far, very similar in shape to our last problem. Now that I'm\niterating through every element of the table, I need to add some conditional logic. If you\nremember, from my drawing, we only did like the heavy logic when our current position\nwas not null, right? Because if it is no, you can't even reach this current position\nin the first place. So I'm going to check if my current amount is attainable. In other\nwords, if table at index i, which is my current amount, if that is not know, if it's not know\nthat I can generate amount I goal. So if I can generate amounts i that i know some other\nthings could also be generated. That is, I want to look forward in my table for every\nnumber in the numbers array. So I'll say let num of numbers, so I'm getting the elements\nof the numbers, right? And I need to look that number of positions ahead right. So if\nI'm at i right now, that means that a forward looking position would be at Table A plus\nnum. Cool, and I need to assign something over here. So I'm going to do is start by\ncopying over the sub array at position I at my current position, right. I know that if\ntable I is not know the only possibility that it could be is an array, right can be array\nof zero elements are going to be an array of many elements. So no matter what that array\nlooks like, I'm just gonna copy over that array. So I'm going to spread out all of the\nelements table I. And so far like this logic is looking pretty good because I'm basing\nmy assignment on table i plus num off of table I, right. But in addition to that, I also\nneed to include this choice of num. So I'm just going to add that into this new array\nas well using some syntax that we've seen previously in the course. Right. So I'm just\ncopying over all the elements of the sub array at table I, and adding on an addition to that\nmy current number. Nice. So this code is looking pretty good. I think at this point, all we\nneed to do is let all these iterations finish, and then wrap up by returning the last entry\nof the table, or really the table at index target some cool, so not that much different\nfrom our last piece of code. Let's give this a shot. So I'll run how some and here I have\na few diverse examples. And notice that some of them should return null because they're\nnot possible. If we check these 32243, no bunch of twos and another No, nice, it looks\nlike this code is totally working. Notice that we already have a very efficient algorithm\nkind of off the bat kind of comes free with tabulation, we definitely have m iterations\nin this for loop, we have n iterations on the inner loop. But then we also have to consider\nthis copying over logic, right copying over an array will be at most m. So it's m times\nn times M, which is just m squared n, exactly how we spoke about it before. It's something\nI really want to emphasize is, you know, in isolation, if someone just asked you to solve\nlike this house on problem, I don't think it's an easy problem. However, it probably\nfeels almost trivial, especially since we just did cancer, right? There's a really,\nreally straightforward progression to these problems. If you compare the house some and\ncan some functions, they're very, very similar, right, really just changing the type that\nwe store inside of our table, as well as the assignment that we do when we transition into\nour further elements of that table. Really just adjusting that logic for the data type\nthat they're asking us for. Right? I had like some array answers here. And here, I have\nsome Boolean answers. All right, so we're smashing through all of these tabulation exercises,\nlet's do one more variation of this target some problem, that way, we'll have a little\nbit of an increase in the difficulty, it's time to revisit the best sum problem.\nSo we're going to take in again, the target sum as well as an array of numbers. But this\ntime we want to do is return an array containing the shortest combination, that adds up to\nthe target sum. And if we have any ties for the shortest combination, we can return any\none of those shortest. So you take a look at an example kind of like we did before,\nwe have eight and an array of 235, there are a few different combinations, I can yield\neight, right, I can do two plus two plus two plus two, or I can do two plus three plus\nthree, or I can do three plus five. And among these options, the shortest one is obviously\nthe three plus five. So that should be the return value over here. Obviously, if you\nreturned five comma three, that would also be a valid answer. Nice. So let's start tackling\nthis with our classic tabulation recipe. So we need to decide on the size of our table,\nlike we usually say it's going to be based on the target sum and not so much the length\nof the numbers array. And like we've been saying recently, it would be nice if the last\nindex of a table aligns with the original target. So although the last index of this\ntable is eight, that doesn't mean that its length would be nine, right? Let's start by\nsetting the proper values here. I always want to begin my my value seed with the type that's\nkind of relevant to this problem. In other words, they want us to always return an array\nif there is at least one valid way to generate the sum. And I know that trivially if I wanted\nto calculate the best sum for zero, no matter what array of numbers, I'm given the answer,\nthere's always an empty array. So I'm going to be sure to store that value at index zero\nof my table. And now for the rest of the values in the array, I can't be sure if I can generate\nthem yet. So I'm going to initialize them as null just like our last problem. At this\npoint, we can begin our general algorithm by iterating through the table. And so what\nI'll do now is look ahead for my current position based on the numbers of the numbers array.\nSo I'm gonna look two spaces ahead. Right now I see that there's a no inside of that\nposition, which means I haven't quite found a way to create two, but I'm actually finding\na way right now, right, I can copy over the array from my current position. But I also\nneed to populate it with how far I'm looking ahead by so just to inside, and do this for\nthe other numbers of the numbers array. So something similar happens for three, as well\nas for the five. Notice that since I just began the algorithm, this is a really the\nfirst time I'm finding any solution for these further values. And so let's keep these iterations\ngoing. I'm going to shift my frame of reference by one since my current position, good things\nand all that kind of entails that one is unreachable, right have no way to generate a sum of one\nit's actually don't do any logic from this current position. So we move ahead to do,\nsince I do have a non null value, right, I have an array over here, that means I should\nlook ahead to my future values. So I start by looking two spaces ahead, I see that at\nindex four, there's a null, which means that I actually need to replace that now. Alright,\nI'm going to copy over my current array. But then I also add the value for how far I'm\nlooking ahead by. So now I have two comma two inside of that index of four. So now I\nlook ahead three spaces, which means I'm analyzing index five, I'll notice that index five already\nhas an array there. And if I actually continue my sort of standard process, I would consider\nthis array, I would copy over my current array in yellow, which is an array of two, then\nI would also add the element I'm looking ahead by which is three. And technically two comma\nthree is one of the ways I can generate five. But it's definitely not the shortest way right,\nI can basically compare the length of these arrays, and notice that the original array\nof just five is definitely shorter, so that one should get the stay in this spot. Cool,\nI'll do something similar for five spaces, I see five spaces ahead for my current position\nyellow, there's a no right at index seven, which means that I can just go ahead and put\nthis new array inside, so I copy over the array of two, then I add the five, right,\nbecause that's how far I'm looking ahead. I keep this process rolling, I'm going to\nmodify two spaces ahead. Notice that this sub array I'm considering\nwould still be longer than what's already stored at index five. So I actually don't\nuse the three comma to write the five gets the same. Now I look three spaces ahead. And\nthis would actually be the first time I found at least a way to generate six. So I copy\nover my current array, and also add my lookahead value. And now if I look five spaces ahead,\nthere's a Knoll currently in that index eight, which means that I'm actually finding the\nfirst way to generate eight, so I copy over my array of three, and then I add my five\nfor my look ahead. Cool. At this point, we've actually already found a way to generate eight.\nAnd you can probably foresee that this would be the shortest way in the long run. However,\nif we kind of continued this algorithm, there would actually be nothing wrong with continuing\nit right, it's not like we're ever going to put something longer in that spot. So if we\ncontinue our algorithm as normal, if I look two spaces ahead for my current position,\nthat would mean I'm considering two comma two comma two, to my array of three, three,\nand obviously, I just maintain the shorter one, so the three comma three gets to stay.\nIf I look three spots ahead, then I would be comparing two comma two comma three to\na two, five. And of course, the two, five is shorter, so it gets to stay. And this process\nreally just continues for the rest of the array. By the end of this algorithm, we do have the\ncorrect sub array stored at index eight. So before we jump into the code, let's look at\nthe complexity of this one. So we'll say that MSR target's m, and n is the length of the\nnumbers array. And so we know that in terms of the time complexity, it's going to be the\nsame as last time, right? Still m squared times n, we don't really add any additional\nlike costly logic, all we're really adding into the mix is just some conditional logic,\nwhich I know is just a very simple if statement. So that's not going to add any additional\ntime. And the same way, our space complexity is still m squared, right, because I have\na table of size m. But I know every element of that table could be an array, really just\na two dimensional array. I think with that, let's hop into the code for this. Back in\nthe editor, let's go ahead and code this one out. So we'll start by creating our table.\nAnd I'll make this table have roughly size of targets. But really target some plus one\nthat way the final index aligns. And when I actually initialize this table, I want to\nactually make sure I have no values inside. So by default, all elements will be no basically\nsymbolizing that, hey, these quantities cannot be generated yet, we have to actually prove\nthat there is some combination that can make them. But the really important seed value\nis to make sure that index zero is an empty array, right? Basically, the one guaranteed\nway I can make zero is by adding no numbers of the array. This point I need to iterate\nthrough every index of my table we always do. I'll go up to the end including why not\nthe target some nice and as I iterate through every position of the table, I only need to\ndo the heavy logic if my current position is not no, right. So if my table and my current\nposition so table I that is not no then I need to do some additional logic. So just\nto review, why do I need to only do the logic if my current position is not know? Well,\nlet's say that it wasn't All right, if my current position is null, then I don't need\nto bother considering any further moves from this position if this position isn't reachable\nin the first place, right? So only if I have a non null position, then I'll actually iterate\nthrough my options in the numbers array, or I'll consider possible moves. So let's say\nlet num of numbers. And as I iterate through these additional numbers, and then I need\nto actually look ahead in the table basically by that number amount. So I need to write\nsome logic about table at index i plus num, right, just looking forward in the table.\nAnd we know based on our previous problem, it can some we ended up doing this logic,\nwe just replaced that position with a new array, where we took all the elements from\nour current position, so table I, we spread out that array. Then we added additionally,\nthis current number that we're using, right, so we have to actually add that into our move\nlist. Cool. However, now we want to actually add some like, min value logic, I want to\nprefer to always keep the combination array that is shorter, right, I want the best way,\nnot just anyway. And so I think the move is or refactor this code a little bit. I'm going\nto actually do this step, maybe separately above. So I'm going to save this to a variable.\nAnd I'll call this my say, combination. This is like my candidate combination, I'm not\nsure if this one is actually the shortest right now. And so if I do the assignment over\nhere, then I'll just use combination. But I only want to do this assignment on line\nnine, if a condition is met, right, so what I want to express is, like, if this current\ncombination is shorter, than what is already stored, right, I only get to replace something\nif it's shorter. That's pretty straightforward to express and an if statement, right? So\nI want to check, hey, if. And my condition needs to be if the thing already there. So\nif the element at index i plus num. If that thing is actually bigger than my current combination,\nso combination, not length, and I also need to be sure to do that element dot length,\nright? If my combination is shorter than my current thing being stored in at that future\nposition, then I'll go ahead and replace it. Nice. So this code is looking pretty good.\nThere's one thing that's kind of missing, but I think we'll just run it and we'll kind\nof debug it together. So let's say at the end, I return my table at index Parkinson.\nCool. So compared to our last code, we only added this conditional logic. So if I run\nthis, something's gonna go awry. And kind of foresee it's very an error. And the error message\nis pretty on the nose over here, it's saying, alright, cannot read property length of null.\nRight. So it's really about, particularly this expression. So we know that our initial\nstate of the table has a bunch of null values. So when I look ahead to a future value, and\nfor the first time, I actually have a way to make it, then I'm going to check the element,\nwhich is no dot length, or I cannot do null dot length. Right. And so I need a way to\nkind of get around that. If ever, I have like a null value in my table, then I can just\ngo ahead and do the assignment, right, because I found at least one way to make that. So\nwhat I'll say is I can put an order here. So I can still do the assignment will say\nnot table, i plus in JavaScript knows a falsie value. So let's say table at index i plus\nnum is no. So this expression is no which is really false. So if I say not false and\nevaluates to true, so I'll go ahead and still assign that combination to that position,\neven if it isn't all, another great reason for using this syntaxes. We know toward like\nthe tail end of our algorithm, we're going to potentially look out of bounds, which means\nthat these elements could be undefined and undefined is also a falsie value. Right? So\nhere I'm saying not false, which triggers as true, which means I would still correctly\nassign those positions. Right. The important thing is I need to be sure to not do this\nexpression. When the element is null or undefined. You can't say no dot length, and you also\ncan't say undefined, not length. So this expression will guard against that. So with that change,\nlet's go ahead and run this. Cool. So 73544 and a bunch of 20 fives nice, especially looking\nat that last example, like 20 fives is obviously the best way to make 100. And just to be super\nSure, should be no different if I even switched around the order of these sort of ways. So\nwhat I put like, one, five in two. That should still give me a bunch of 20 fives, right?\nBecause it's really looking for the best way to generate each some, which would mean the\nsmallest summary. So there we have it a pretty interesting tabulation a problem. However,\nI do want us to recognize how similar it is to our last how some problem, right? So here,\nI have best some on the left and how some on the right, notice how similar the code\nis. Really, the only difference is this if statement, right? For the best some problem,\nI just added this conditional logic. And all this does is prefer to keep the shorter combinations\nover the longer combinations, right, because that's what I want to return in the long run.\nWhereas in houssam, we don't really have any preference in either direction. Awesome. So\nlet's go ahead and go back to the drawing board, I think we'll kind of switch things\nup. Let's switch gears a little bit and revisit those string problems with tabulation. Let's\nbegin with that can construct problem. So we're going to take in a target string as\nwell as an array of words in a word bank. And this version of the problem and I want\nto do is return a Boolean, right, true or false, indicating whether or not I can make\nthe target by concatenating, any number of elements from the word bank array, and I can\nreuse elements in the word bank as many times as I want. So we've seen this problem before.\nBut just to refresh, let's take a look at an example. So let's say my target was abcdef.\nAnd I gave you this array of some different substrings. In this particular scenario, it\nis possible to create abcdef using members of the array. So the answer here is true.\nAnd one way you can actually create your target string is by just doing ABC plus the fright.\nAlright, let's start to apply our tabulation to this one. So I'm going to create a table\nand you probably already recognize that, why I want to base the size of this table off\nof the target string, right, because that's really where I have some problems, I'm going\nto be decreasing the size of my target, or in other words, building up to my original\ntarget over time. And so I know that I'm going to make it about the target string and not\nthe array of words, because I'm never going to remove a word out of the word bank. So\nI'm gonna start with this table. And here the sizing is is kind of particular, because\nwe need a way to have this table or represent information of a string, right. Whereas before\nwith our number problems, it's very straightforward to just use the index as the actual number.\nSo we're going to use a little clever have an encoding here. And so what you'll notice\nis here, I created an array of size seven, right, table dot length is seven right now.\nAnd in general, you'll want to size your table by doing target dot length plus one. So we\nstill have that sort of off by one scenario, that's kind of a very characteristic of these\ntabulation problems. And so what will this table represent? Well,\nif I just think of the characters of my original target string, I know they have corresponding\nindices sort of like this, you're probably wondering, then what's the point of having\nthat extra spot at the very end of the array, right? What I need to store index six, if\nit has no corresponding character. And the reasoning is, we need a way to actually represent\ninformation about the empty string. And so here's the pattern we're going to use. If\nI look at index zero of this table, then I'm actually making a statement about the empty\nstring. So pretend that if you look at a spots of this table, depending on what that index\nis, you're considering the substring, that starts at index zero, and goes up to but not\nincluding your current position. So we'll see how this scales over the rest of the indices\nhere. So imagine that now is at index one, I'm looking at index one, and you're really\njust looking at the A string, for at index two, then you're looking at a B, if you're\nat index three, then you're looking at ABC, for index four, then you're going A through\nD, if you're at index five, you're looking at A through E. And so the really key insight\nhere is if I'm looking at index five of my table, it means I'm making some logical statement\nabout the substring starting from index zero going up to but not including index five,\nright? So if I wanted to make a statement about the entire target string, then I should\nactually look at index six, right? Because imagine you start your substring at index\nzero always, and you go up to but not including your current index. And again, the whole reason\nfor this is I need a way to actually make a statement about the empty string. And so speaking of the empty string, let's\ngo ahead and talk about our C values. We know that a really core you know pattern in this\ncan construct problem is to use the fact that hey, if your target string was empty, no matter\nwhat array of words you were given in your word bank, that is always possible. So it's\nalways true. And so that means at index zero of my table, I can go ahead and seed a boolean\nvalue. How do I know what type to even store as the elements of my table? Well, if the\nproblem is asking me to return a Boolean, then it's probably a good To actually just\nbegin with some boolean data in your table. So if index zero is going to start as true,\nI'm going to initialize the rest to be false, right. So I'm going to consider all of these\nother sub strings or prefixes as not possible until I prove them otherwise. Alright, so\nlet's begin our general algorithm. So we'll begin like we always do by just iterating,\nfrom left to right through our table. And just we have some notation to make it easier\nto kind of translate the information in a table to the statement it makes about our\ntarget string, I'm going to have the characters up top, and I'm going to like them up based\non the substrings that we're really considering here. So if I begin at index zero, like we\nsaid before, that means I'm making a statement about the empty string, right, I see a true\ninside of this position, which entails that the empty string can be constructed using\nthe word bank. Cool. At this point, I have to figure out how I can look ahead to my further\nvalues in the table. And I know that I can do that based on the choice of words in the\nword bank. So let's look at one of our words like a B. So something great about this option\nof a B is it actually is something that begins from my current position, right. In other\nwords, if you look at my current position in yellow, the characters below it start with\na and follows with me. So taking an AB right now would be a totally legal move, right those\ncharacters align. And so what I'll do is, I'll go ahead and look two characters ahead,\nby look two characters ahead in my table, that just means look two indices ahead. So\nnow I know that this position of the table is actually reachable by just taking a B.\nSo I put a true here. And now at this point, I would do this same logic for the other words\nthat have their characters aligned. In other words, ABC is also some matching word. So\nI'll go ahead and make that a true. And ABCD would be the only other one that actually\naligned its characters. So I'll make that one true. Again, how do I know to actually\nput this information in the table, it's really just the length of the word right, my current\nposition right now is at index zero. And I'm looking at a word that is four characters\nlong. So that means I just look for characters ahead to store my Boolean. Cool at this point,\nI'm actually done looking at all the words for this current position. So now I can move\nmy current ahead one. So now I'm at this position. And so what you'll notice is in this current\nposition at index one, we have the value of f, which means that it's false, right? It\nis not possible to actually generate in a write, there's no way you can ever just give\nme back an A, because all of your substrings in the word bank are too long, right? So I\ndon't actually need to do any of my heavy logic from this position. However, on the\nnext iteration, when I have something that's true, then I need to do my heavy logic. And\nif I do a quick spot check, I have a true stored in this position to write if I'm looking\nat the value stored at index two, that means I'm making some statement about indices zero\nup to but not including tomb. So really just the substring AB. And I know that if it's\ntrue, that means it's possible. And looking at the elements of the array, it's definitely\npossible, right? You just took a beat even get to this position. But I need to look ahead.\nSo I'm going to look at any words of the word bank that match starting from my current position.\nReally, the only option here is CD, right. So if you look at my going characters, right\nnow, that means I can take this CD. And so what I'll do is I'll look two characters ahead\nand place a value at that position. That's true. But the value stored at this position\nof the table is already true. So nothing really changes here. And there are no other words\nof the word bank that actually begin with a C. So I'm actually done with this pass.\nSo now I move my current again. And I look for any matching words that begin with like\na D, and potentially other characters after that, really, the only one here that works\nout is D, F. And so looking at my going characters, now I'm basically considering this chunk,\nright ABC followed by TF. So I'm going to look three positions ahead, because the word\nI'm considering right now is three characters, right def is just three characters. If I do\nthat, I'd be looking at this position. And I'd be making this one a true now basically\nsaying that it is possible to construct abcdef colon at this point, I would do the same thing\nfor the rest of the table, we know that nothing else is really going to change within this\ntable. And so by the end of the algorithm, we have\na true start at index six, which means that our entire string is possible to be constructed.\nRight? And so if we do a quick sanity check, if I look at the table at index six, that\nmeans I'm making some statement about the substring that starts at zero and goes up\nto but not including index six, which would really be the entire A through F. I know that\nit's true. So that substring is possible to be generated, right, which was our final answer\nfairly elsewhere. Like maybe at index five, there's a false here, which means that I'm\nmaking some statement about indices zero through four, right, so ABS C, D E. And since there's\na false at this position, that means that it's not possible to generate this string.\nAnd looking at just the elements of the word bank, it's definitely not possible to ever\nget a, b, c, d, e. Cool. So the data within our table a does look consistent with that,\nlet's actually talk about the complexity. So we know that m is going to be our target\nstring, whereas n is going to be the number of words in the word bank. And so we just\nconsider the time complexity right now, we know that we're at least iterating through\nevery element of our table, and our table was roughly size M, right? However, once we\nwere at some current position of a table, we had to look ahead based on all of the words\nin the word bank. And so that would be an N operation for every iteration of m. And\neven still, as always, considering the words coming from my current position. And to make\nsure that their characters aligned, right, I can't just take arbitrary words, from the\nword bank, I have to choose the ones that have their characters matching right now,\nI know that the maximum length of any word or the maximal length of a match, I would\nhave to do would basically just be in terms of M, so give me an additional m term. So\noverall, I'm looking at m squared n for the time complexity of this one. And besides that,\nwe already know that the space complexity comes from the table, which is just a array\nof Boolean, so just m space overall. And so from a bird's eye view, it looks like this\nstrategy would be an efficient one, right, we have a polynomial time complexity, but\nmore importantly, a non exponential complexity. So let's code this one up now. Alright, let's\ncode up this can construct problem. So we'll start by creating our table. And so we'll\nsay create a new array of size target dot length, plus one just like we spoke about\nin our drawing, then from there, I need to give some initial values to my table. So I'm\ngoing to go ahead and fill this one up with all falses. So we're going to assume that\nevery like prefix of our target cannot be constructed until we prove it otherwise, then\nI need to actually also initialize table index zero to be true, symbolizing that the empty\nstring can always be generated, right? Then from there, I need to iterate through every\nindex of my table. So I'll say i equals zero, just go up to the entire table. And here just\nto be safe, I'll say is less than or equal to target dot length. Nice. And as we iterate,\nwe actually need to check our current positions value. Recall that in our strategy, we said\nwe only need to do like the heavy logic, if our current position is reachable, so our\ncurrent position should be true. So I'm gonna go ahead and check Hey, if my table at index\ni is true, then I'll do some additional logic. If I enter this if statement that I need to\nconsider any further choice of words I can use to progress to other spots in the array,\nright? So over here in this if statement, I want to iterate through every word of the\nword bank, right? So I'll say four letter word of word bank. Nice. And so what I want\nto do, as I iterate through all my possible words is I need to make sure that these words\nI iterate through actually match their characters to my current spot that I'm at. In other words,\nif I am at my very first index of a over here, then when I iterate through all the options\nof words, I need to make sure that I only use a valid words that match like a, b, or\nABC, or ABCD. Right? There's no point of me trying to use def right now. Right? I need\nto actually kind of narrow down my words, based on whether or not they match characters,\nright. So to do that, I can check pay if. And what I want to express is, you know, if\nthe word matches the characters, starting at position, I position I goal, it's not going to translate\nthat into some code. Well, checking if a string matches to something straightforward, just\nabout using equality, right? But I have to figure out how can I look at the correct you\nknow, substring of characters within my original target, right? It's pretty straightforward.\nAll I need to do is say target dot slice. I'm going to slice starting at index i. And\nhow far do I want to go? I basically want to go like the length of my word. So the move\nhere is to say go from I up to i plus word dot length. And so let's kind of break down\nthis logic. So what it's trying to do is check if your word matches your characters starting\nat position I. So let's check an easiest scenario. Let's say that my current position is zero,\nright? So right now is zero. That means I'm at this position like this ABCD f example.\nLet's say right now that my word is ABC. So if I look at this slice, it's going to slice\nstarting at index zero, up to and not including zero plus three, right, the length of my word\nis three, zero plus three is just three, that would actually look at this run of ABC. Good.\nAnd let's say we were somewhere further in the string. Let's say we were actually at\nthis D character over here. And so if I'm at this D character, that means my value for\nAI is going to be three Wragge, oh 0123. And the current word I'm considering, let's say\nis this def, the length of this word is three. So this ending index is going to be three\nplus three, which is six. And so I would actually slice starting at this character, three, going\nall the way through the end, right? 345. And I always exclude the ending index of six here.\nSo this logic is good, right? All it does is check if my current word matches the characters\nstarting at index i, goal. So if I enter this if statement, then I have a successful word.\nSo I should actually set a true in that forward looking position. So I can just set table.\nAnd when I look ahead, how far do I need to look? Well, you need to look exactly this\nfar ahead, right, i plus word dot length, matching me we're at index zero of our target\nstring. If I take ABC, then I end up word dot length characters later, three characters\nlater in this example, right. So I'm saying table of i plus word dot length, that should\nbe set to true. Cool, notice how similar This is to our previous number, like our target\nsome problems, except now we have to adapt this four string data. So now I jump ahead\nbased on the length of the word I'm choosing. So this code is looking pretty good. Let's\ngo ahead and do our final return value. So I want to return the table at Target dot length,\nright? Basically, if I'm at the last position, or at Target length, a position of my table,\nthat means I have the information for the entire target range starting at index zero\nall the way through the end of the target. So here are some examples. Let's give this\na run. So I get true, false, true, false. Nice, and there we have a nice working solution.\nSo take a moment to let this code sink. And really the most tedious logic here is probably\nthis particular slice. So really try to make sure you kind of understand how this comment\nis implemented using this code. If you remember our previous recursive immobilization strategy\nfor this problem, we needed to actually have logic to make sure our prefixes match. This\nis sort of the analog for that, right. So we already spoke about the time complexity\nfor this one, but it's already in plain sight, right, we have m iterations here, we have\nn iterations here. And then the additional work we do is this slice, right, I'm slicing\nfrom my target, which is also M. So overall, I have m times n times m, or m squared, N.\nAnd of course, the table just takes up definitely m space. Cool. So with that, let's head back\ninto the drawing board. All right, now let's revisit the count construct problem. So we're\nstill going to take in a target string as well as an array of words in a word bank.\nAnd this time, we want to return a number, right, we want to turn the number of ways\nthat the target can be created by concatenating elements of that word bank, we can reuse elements\nof the word bank as many times as we want. So let's take a look at an example of this.\nSo let's say I had this input, so I have the target of purple, and I have an array with\nsome substrings. The return value here should be two because they are exactly two ways to\ncreate purple. You can do perp plus le, or you can do p plus u r plus p plus le ran,\nthose are two distinct ways. So notice in this problem, we really just want to return\nto the numbers. So we'll just keep that in mind. So let's follow that classic tabulation\nrecipe, we'll initialize our table with roughly the size of the input that changes, which\nis really going to be the target string, right, we want to actually use overlapping subproblems\non the target string. And like we always say, we're going to have\na little off by one scenario here. Although the number of characters in my purple string\nis six, I want to initialize a table of length seven. In general, you want to make sure your\ntable has target dot length plus one a number of elements inside. That way, I have a way\nto represent the empty string, just like our last tabulation. And so we'll start by thinking\nabout what are some proper seed values for this problem. I know that when I have an empty\nstring, empty target strings, my input, no matter what array I'm given, you can always\ngenerate the empty string right by taking no elements of the word bank. So the answer\nfor the target string should be one, right, there's one way to make the target string\nand that is to concatenate nothing together. So I'm going to store the value of one at\nindex zero of my table. Now I have to decide how to initialize the other values in my table.\nWell, I know that it should be number data, right? It's really important that you try\nyour best to make your table contain a consistent data type. If I remember my similar counting\nproblems like Fibonacci, or even the grid traveller of the move here is actually start\nthose other spots in the array at zero, basically saying, you know, at the start, I have zero\nways to generate these different prefixes of purple. And then as to actually find distinct\nways, I'll go ahead and increment those spots in the table. But we'll get to that. So we'll\niterate through our table from left to right, of course, beginning at index zero of the\ntable. And as we do this, I'll also up top show the characters that we're considering\nwithin our table. Remember, the really important pattern here is when I'm at some position\nof my table, that means I'm encoding some information about the substring that starts\nindex zero, up to but not including my current index, right. So if I have some information\nstored at index zero, that information is about the empty string. From my current position.\nNow I need to consider any words of the word bank that I can take right now to give me\nanother spot within the table. In other words, since I'm at index zero, I need words that\nstart with P. So let's say we looked at this first word of perp. And so if I looked at\nthat word, and I took it, that would bring me a somewhere else within the table, right\nhave to look forward like we usually do. So they'll end up at this position index four.\nAgain, notice that we have the kind of off by one scenario here. So although I'm going\nto write information into index four, that informations about the substring, that spans\nfrom zero, up through index three, right, and what I need to do now is take my current\nvalue in yellow, actually add that into my future position. So I just add one into the\nzero. And now index four contains a one, right basically saying that so far, we found a one\nway to construct the string perp. And then from there, I look at any other words that\nthe word bank that match right, so I'll just look at the next word of P. Again, just moving\nleft to right through our word bank, right now, I'm still at my current position. And\nwhat I do if I use this P is I only look one character ahead, right, because p dot length\nis only one. What I do in this future position is of course, just take my current value in\nyellow, and I added into this position, so zero plus one is just a one. There is one\nmore word I can use right now from my current position, that's purple without the E. And\nif I look at that corresponding position, they'll bring me all the way over here. And\nagain, I add the one into that position. Nice, I think that ends are a very first pass. And\nnow we move our current position to the right. So now my current is at index one. So now\nI need to consider words of the word bank that begin with a you and kind of match characters\nthroughout. The only option here is really just you are in the word bank, if I took a\nu r, that would bring me two characters ahead, right, so bring me over here, what I should\ndo like always, is just take my current value and add it into that position. Now I have\na one over here. There are actually no other words of the word bank that match from my\ncurrent location. So I can just move ahead to the next spot in the table. If we're at\nindex two, it looks like we need something that starts with an R, there's actually no\nwords of the word bank that we can use from this position. And what we also notice is\nthere's also a zero at this opposition. So this won't really do anything in our table\nanyway. So we can progress just the next spot in the table. Here's where things start to\nget interesting, right? So right now my current is at index three. So I need to grab words\nfrom the word bank that start with P and potentially have an L enemy. So what I can do here is\njust take this loan p, which will bring me one character ahead. If I look one character\nahead, what I do now is I take my current value, right circled in yellow, and I add\nit into my look at value. So I increment that to two now. Nice. And then from there, I need\nto continue on my logic by just moving rightward in my table, right shift my current point\nof view. At this point, what I do is I again, look\nat any words that start with an le, and there's really only one that matches perfectly, I\nlook two characters head because the length of Le is two. And what I do is I take my current\nvalue in yellow, and add it into that position, right, my logic throughout this entire algorithm\nis very consistent. And there we have a two in the last spot, you can probably already\nforesee that we have our final answer. But if we continue the algorithm as normal, or\nreally, we've noticed that if we move to the next position, there's no word of the word\nthat starts with E. So I don't do anything here. And once we hit the very end, we're\nactually done with our algorithm. Right? And we see that, hey, we have a two in the last\nspot a retailer which is consistent with our expected answer. Something I think is really\nimportant to do is not only recognize that our final answer is in the last position of\nthe table, but really any element of this table should make some logical statement about\nour target string, right? So let's say I look at index for over here. I see that there's\na two in that spot in the array. So what does that really saying? Well, if I am looking\nat the value stored at index four, that means I'm considering the substring That starts\nat zero and goes up to including four. So that really means I'm looking at purp, right.\nAnd if there's a two inside of the spot in the array, that means that there are apparently\ntwo ways to create perp. And if I do a quick check in my word bank, that's exactly true,\nright, you can just take the straight up perk, because that's actually a literal word of\nyour word bank. Or you can do p plus u r plus P. Cool. That's some consistent information.\nAnd then from there, if I actually consider now what I can do from that position at index\nfour, well, you could have taken an le, that's basically what we did when we traced through\nthe algorithm. If you take an le, what are you really doing? Why is that value in the\nindex six, also two? Well, for one, Ellie has a length of two. So that's why I'm looking\njust two spaces ahead in my table. And if I think about what like logical operation\nI'm doing, if I were to take an L e, and add it to all of the ways that I have in blue\nRhino, then I would end up with all of the ways to generate purple right in my last spot,\nliterally just taking the Le as an additional move, right? Pretty elegant logic. Let's talk\nabout the time complexity for this though. So we know that, hey, r m is going to be the\ntarget and n is going to be the number of words in the word bank, this is really going\nto be about the same complexity as our last rendition, right? You can't construct. So\nwe're gonna have m squared times n time, right, we definitely have m time for just iterating\nthrough every spot of the array. And we also have an additional n, because we have to actually\nlook forward for every element of the word bank. And so where does that final m come\nfrom? Like we've been saying lately, it comes from actually performing the match of the\ncheck for matching characters. In a similar way, the space complexity is just going to\nbe m, really just based off of the size of the table, we're only ever storing just some\nnumbers within this table. So our space just stays at linear o of M space. All right, I'm\nfeeling good about this plan, time to code it up. Alright, let's code this one out. Let's\nstart by creating my table, it's gonna begin as an array with roughly target length, size,\nreally target length plus one, that way the index aligns, right, I'm going to fill this\nentire table with zeros for now, because I know in the long run, I'm going to add into\nit. So zero is a great starting value. That being said, I have a really important c value,\nI need to make sure that my table at index zero actually starts as one, right, because\nthere is one way to make the empty string right. Now from here, I can start my core\nalgorithm by just iterating through every position of the table. So set i equal to zero,\ngo up to an including target dot length, and hit every index, right. And so what I'll do\nis iterate through every word of the word bank. So let's word of word bank. And as I iterate through every word, I need\nto check if the word matches my current location right there has aligning characters. So you've\nseen this pattern before, I'll check if target that slice I'm gonna slice some characters\nout of my target. Starting index i right, this is my current position, I need to look\nat the next couple of characters based on the length of my word, I'm going to slice\ni to i plus word dot length. goal. So my current position is I, this will give me the next\nword dot length number of characters starting at position, I will check if that little segment\nis equal to the word I'm considering right now. And if it is equal, then I have a word\nthat I can actually take, I can modify some further position of the table. In particular,\nwhat I should do is need to modify my table at index i plus word dot length. So I'm looking\nto head remember that our current position is I so I'm looking ahead in the table based\non my current words length, what I want to do is actually increase that by some value,\nwant to increase it by the number stored in my current position, right? That's what we\ndid at every point of the algorithm. Nice. A common mistake that I see students make\nis, usually they have a tendency to just increment by one here, right? That's not the move Do\nyou want to do is increment by exactly the number that's in your current position, right.\nNow, at this point, I think all we need to do is just return our final answer, which\nlike we always know, is basically table at Target dot length. Cool, so I have some examples\nbelow. With their expected results, let's give this a shot count construct. So I get\nto 104 and zero, that's that we have a fairly large example, which should return zero, you\ncan't possibly generate this final f here, because your word bank only contains a bunch\nof E's, and it ran fairly quick. So this solution is looking pretty good. Notice how small of\na variation it is from our last problem. Hopefully you're really feeling the progression. So\nlet's kind of quickly just take a look at That that was our can construct problem. So\nlet me split these guys. Very, very trivial difference, right, instead of assigning a\ntrue value. Now I actually just increment because I have numbers within my table. That\nwas short and sweet. Let's head back into the drawing board. Let's do one more problem\ntogether, let's revisit that all construct problem. So we're still taking in our target\nstring, as well as an array of words in a word bank. But this time, you want to return\nall of the ways that you could construct the target by concatenating elements of the word\nbank. So here, you need to return a 2d array, that means a single element of the array represents\na one combination that makes it a target. And like usual, we can reuse elements of the\nword bank as many times as we see fit. So we take a look at an example, let's say I\ngave you the target of abcdef, I gave you this array of words, you actually have many\nways to create the target string, there are four ways over here. So each sub array represents\none combination, where if you concatenate it together, you get the target. And so notice\nthat I want to return every single combination as an element of the outer array over here,\nright. So if there are many ways to create something, then I want to return a 2d array.\nThat being said, there are a few examples that we should keep really in mind having\nto do with our seed values that we kind of foresee. Right. So let's say I gave you this\nexample, where your target is the empty string, and I gave you just some words in the word\nbank. The point is, since your target string is empty, your result should really be a 2d,\nempty array. So recall that the outer array here represents like the collection of multiple\ncombinations. And here, there's only one combination that makes the empty string, right, so the\ninner array represents like that empty combination, we take no words of the word bank. And this\nis a reasonable thing to do, because they'll take give you this example, if your target\nwas birds, and I gave you an array of cat and dog, then the result, there should be\njust a one dimensional empty array, right? The array over here represents the collection\nof combinations. And there are no elements here, right? There are no combinations at\nevery yield of birds. So we'll keep those sort of seed value base case scenarios in\nmind. So let's trace through this example of abcdef. I'll start by initializing our\ntable, we're gonna need a lot of room in this one. And so we know that the size of this\ntable is going to be based on the target string, right, just like we usually do. And then we\nhave to figure out what our seed values are, we kind of just spoke about them, we know\nthat if I have the empty string, then I need to have a 2d empty array. And so we'll initialize\nthat in our table, I know we're going to need a lot of room.\nSo I'm going to spread out these outer brackets. Now for all of the other elements of our table,\nwe want to make them just one dimensional empty arrays. And here's the reason why I\nwrite for these further values in the table, I have to actually check for ways to generate\nthem. So for now, there are no ways that I found right, that's why I just have an array\nwith zero combinations inside, except for index zero, right? index zero has one combination\ninside, that happens to be the empty combination. Cool. So let's start with our general algorithm.\nA lot of this logic will feel very similar to our last few problems. Now we're just adjusting\nit have to generate these combinations, right. So we know that we're going to try to visualize\nhow we look at our string in terms of some prefixes, right. I know that if I'm highlighting\nsome spot in my table, then that grabs the prefix or an index zero all the way up to\nmidnight, including my current index of the table. And I'll light up those characters\nat the top over here. So what I need to do now is since I'm currently at index zero of\nmy table, I consider words of my word bank that have matching characters from this position.\nSo I can look at this a B First, if I took this A B move, then I should look two characters\nahead, right, because a B has a length of two. So that brings me to this position in\nlight blue. And what I should do is take all of the combinations in my current location\nin yellow, and actually copy them over into this future position. But when I do that,\nI also need to be sure to include in those combinations, the move of the word I just\ntook, right, so that would just be adding an AB inside. Right. So again, kind of repeating\nthat step, I copy over the contents of my current position in yellow. But then I have\nto make sure I add my word that I'm consuming right now into each of those combinations\nI just added. Cool. And now we would actually keep our current position here because there\nare still some other words of the word bank that have matching characters, right, I can\ntake an ABC from this position, and something very similar happens write a copy over my\ncurrent array. And then I go ahead and add ABC to it. This happens one more time for\nABCD Awesome. At this point, I've considered all\nof the words that match from this current position. So I can move forward a little bit.\nAt this point, though, I need something that starts with A, B, right? Because my current\nposition has to be on it. And I actually don't find any words of the word bank, that kind\nof match from this position. So I actually moved my current once more. What about this\nposition, I have to consider words of the word bank that have a seat, right, and there\nare a few that can use here, I can use CD, right. And if I do that, I look two characters\nahead or two indices ahead for my current position. So I'm looking at this index. So\nif I look at index four, I have a really interesting situation, right? I already have a some combination\nstored inside of index four. And that represents one way we could make ABCD, right by just\ntaking that loanword ABCD. But what I can also do is, I should take all of the combinations\nfrom my current position and just add them into that index for right, so I'm taking the\nA B from index two, just adding it to index four. But then I also need to add to that\nnew combination of the word I'm using right now, which was CD. Cool. And then from here,\nyou already noticed that, hey, there are so far, two ways to create ABCD, you can just\ntake that loan word ABCD. Or you can do a B plus CD. So this logic is taking some some\nnice shape here. For my current position, there's actually one more word that matches,\nit's really just a single character see, so like I do, I look one character head or one\nindex head in my table just next door, and I copy over the combinations from my current\nlocation in yellow. But then I also append the word I'm consuming, which is just an additional\nC, right. So so far, I have two ways to make ABC. At this point, I can progress my current\nspot and table. And I look for any matching words that start with a D, right? So that\nwould be the D f over here. d f has a length of three. So I look three spots ahead in my\ntable. And I need to add some information here, I copy over my current combinations\nin yellow. And then I have to append at the end of all of them the D F word that I'm using\nright now. So it looks like this. At this point, I can iterate my current position.\nSo now I'm at index four as my current. And I look at any words that start with any, and\nthere's actually just one over here just as EF. And so I look to character's head or to\nindices ahead for my current position. And again, this is a scenario where I need to\nappend new combinations to this existing list, right. So if I look at my current position\nat index four in yellow, I'm going to take all of those combinations and copy them over\ninto my light blue position at index six. And then from there, I also need to make sure\nthat I append to them the word I'm using right now, which is an E, F. So those two combinations\nalso get an F at the end of them. Nice. At this point, you see our final results at the\nlast spot on the table, we continue the general algorithm, we would just move our current\nposition to index five, which is actually a no words of x star with an F over here.\nSo nothing happens on this iteration. And there we have our algorithm, right, that index\nsix of the table contains all of those four ways we described how we can use to create\nour original target string, take a moment to look at this table. And notice how every\nposition of the table should make some logical statement about the target string. Right,\nI can see that if I chose some position, let's say index three, that's giving me some information\nabout the substring ABC, right, that prefix of my original target. And what saying is,\nthere are two ways to make ABC, you can just take ABC, that's actually a word of my word\nbank. Or you can do a B plus C, right? That's the only other way that applies for all positions\nwithin my table. If I look somewhere else, like at index five, that means I'm reading\nsome information about A through E. And if there's no combinations at this position,\nmeans there's no way you can ever generate ABCDE. And if you take a quick glance at the\nwords in the word bank, that is correct, you can't possibly just generate ABCD. Overall,\nthe information in our table and our logic that we did was very consistent. Before we\nhop into the code for this one, let's do the analysis. So we know that m is going to be\nthe length of our target string. And we'll define n to be the number of words in the\nword bank. So like we described, when we did the memorization and recursive solution for\nthis problem, we really can't do better than a sort of brute force, right? Because they're\nasking us to return literally every single way to generate our target string here. So\nreally, the time complexity is going to be the shape of an exponential, right, so about\nn to the M, again, it will have some extra like multiplication terms of M in it. But overall, we're looking at an exponential\ntime complexity. And what's the reason behind that? Well, we know there's going to be an\nexponent The number of actual combinations that we need to return. And I have to actually\nconstruct all of those combinations piece by piece. And so I'm looking at at least exponential\ntime. And really, once something gets exponential, that's really the limiting factor, right.\nAnd similarly, we can say that the space complexity for this is also going to be exponential.\nAgain, roughly, we know that we're going to have at least m space just from the straightforward\nsides of the table. But notice that every element of the table itself is going to be\na 2d array. So in a sense, we're really dealing with like a 3d table in this instance. And\nso we know that at any particular position of our table, we're going to have potentially\nan exponential number of things, right, if you consider the very last spot in our table,\njust the last spot that already has an exponential number of combinations inside of it, but then\nI would actually have that throughout my entire table, so it'd be really a little more than\njust n to the M. But overall, I'll say it's roughly exponential complexity. And you can't\nreally do any better here, right, especially in terms of the time, I'm really asking you\nto just do this in a brute force way, I think we'll actually be able to see that once we\ncreate the solution. Let's hop into it. Alright, for one last time, let's solve this all construct\nproblem. So I'll begin by creating my table. By now we're tabulation masters, this is very,\nvery formulaic. Create my table with roughly target size really target dot length plus\none. And here, I need to initialize the elements of my table as arrays. So here, I need to\nbe very particular and make sure I get a unique array in every spot of the array. So I'm going\nto do a fill using this index before, then I'll map over it that way I can generate a\nnew array for every element here. Cool, let me just style this up. And so this should\ngive me an array as every element of my table, right? Notice that the elements right now\nare just one dimensional empty arrays, right? These arrays represent the collection of combinations.\nAt the start, they're empty, meaning that I have no combinations for most of these elements,\nexcept for one, right, we already spoke about table at index zero, right? That should be\na 2d, empty array. And the reason was, still, the outer array here represents the collection\nof combinations. For the empty string, there is one combination that you can use to make\nit right, that is the empty combination, where you take no words to the word bank. Cool.\nSo now I can begin my general algorithm by just iterating through my target, and you've\ndone this many times before. So I'm iterating through my table. And what I'll also do is\nlook at all of the words, right, so in every iteration, I'm going to consider some words\nof the word bank. So I'll say that word of word bank. And like before I send you to check\nthat, alright, these words better have matching characters based on my current position. So\nI'll use that classic logic, right, seen it many times by now. And I'll slice a segment\nout of my target string, I'll say target dot slice starting index i, and grabbing the next\nword, dot length, number of characters. Cool. I'm going to compare that chunk to the current\nword that I'm iterating through. Nice. So using this statement, I'm sort of filtering\ndown all the words, and only going to do some logic on the words that match based on my\ncurrent position. Nice. And so we've seen you know, this nested for loop an if statement\nbefore, right, we're now we're adding our new logic within this if statement. Cool,\nall I need to do is really understand what types of data I'm dealing with here. All right,\nso let's say I just wrote this expression table at index i, well, that's going to do\nis just reference my current spot in the table. And if I think about what data it's going\nto be, it's definitely gonna be an array, right? It's either going to be like an empty\narray, meaning there are no ways to make this current target. Or it could be a multi dimensional\narray, where every sub array represents one way I can make the current target. So if this\nis all of the combinations that generate my current, then what I'll do is I'm going to\nmap over them. Remember, in our drawing, what we did was kind of copy over all of our current\ncombinations. But then make sure we also add our word that we're using right now to the\nend of each of those combinations. So that's what I'm doing right here, and a map over\nevery summary. And what I'll do is, I'll just copy over the elements of that summary using\nthat spread syntax that we've seen before. And then also be sure to add on at the end\nmy word. Nice. And then that will give me let's say, our new combinations. So I'll just\nsay that to a variable maybe. So new combinations is going to be a 2d array, right where every\nsub array represents some combination. And I want to take these combinations and\nadd them into that further spots inside of my table. So I know I need to kind of look\nat in my table. So I can look at table at index i plus word dot length. I know that\nall positions of the table are going to be arrays, right? So this is going to be an array,\nthere's going to be some data that might already exist at this position, right? So what I don't\nwant to do is just assign you combinations, because then that would overwrite any previous\nexisting combinations that I already found for this position. Instead, I need to make\nsure that I just add these new combinations to that list, right. So what I'll do here\nis I'll push to that array, I'll push all of the elements of my new combinations right\nhere, I can spread this out, I want to spread it out. That way, I don't add any additional\nnesting over here, right. So this is looking pretty good. I think let's go ahead and return\nthe table at Target dot length. Here, I have some examples down below. Let's give this\na shot. Nice. And these answers look correct. Right, notice that these last two examples\nshould return empty arrays because they are impossible to generate. Cool, let's hover\nover this code for a moment. Probably the most tedious logic here would be these two\nlines, right? Really try to understand how like these two lines translate into the logic\nwe did in our drawing. So let's break down these lines again, right? line 11 is going\nto take all of the combinations in my current position in my drawing that was like my yellow\nbox. And it's going to add our current word to each of those combinations. And then we're\ngoing to take each of those new arrays and add them to the list add our further position,\nright being sure not to overwrite, we already spoke about the complexity of this one, it's\ndefinitely going to be exponential, probably a little more than exponential. Right? If\nyou imagine all the work we have to do using these maps and like spreading, we have to\nactually construct our result array, which is going to contain an exponential number\nof things. Right? So when I look at this last example, let's say that I made it a little\nlonger, right? So let's say actually pull up the size of that input. It's going to be\nvery, very slow might even crash, but let's just do it. So let's say I had a bunch of\nA's here, just for fun. So if we try this example. Yeah, it looks like our program still\ncrashes, right? This is going to return a really, really a massive array probably can't\neven fit into memory over here, right? So we'll get like a stack size exceeded, even\nthough this isn't even recursive, right? Just calling functions way too much over here.\nSo no matter what we do, we really expect this problem to sort of demand an exponential\nsolution. With that, let's head back into the drawing board where you can wrap up this\ncourse. Alright, programmers, by now we solve many\ndifferent dynamic programming problems together. And I want to leave us with some final advice.\nSo whenever you're starting to attack any dynamic programming problem, start by really\ntaking a moment and noticing any overlapping subproblems. And then from there really focus\non like the input to the problem, in particular its type. And from there, you shouldn't be\nable to recognize what is the trivial smallest input? So in our string problems, usually\nthat means the empty string in our array problems, it's the empty array, or in our number problems,\nit's usually a number like zero or one, right? Is there some input wherever you don't really\nhave to do any extra work to know the answer? The answer just sort of is what it is. Once\nyou recognize this trivial scenario, or the base case, really, then you'll want to realize\nhow you can relate this base case toward your larger inputs. And then you have two options,\nright? You can either think recursively, and use memorization, or you can think more iteratively\nand build a table using our tabulation formula. I think as you practice dynamic programming\nproblems, I would actually always solve problems in two ways, one using memoization and one\nusing tabulation. And of course, from that point on, it's okay, if you have like a favorite\nstrategy. For me, personally, that's memorization. But that being said, it really helps to have\noptions when you're in an interview. And once you've made that decision on, you know which\nroute you're going to take, definitely, you know, slow it down and draw a strategy first.\nThis is I think, the most important thing about just data structures and algorithms\nin general. Usually, when we draw our pseudocode, or draw our process on the whiteboard, we\ncan recognize all of these edge scenarios. And it's much harder to do when we just write\nlike the code out of the gate. And so I promise if you slow it down and take a moment to draw\na visual, you're gonna find your work a lot more productive, as well as more intuitive\nwhen you explain it to someone else. And of course, through all of that, you're gonna\nhave a lot more fun, you know, dealing with these quite hard topics. Alright, programmers,\nthat's all I got for this course. Hopefully, you had fun, you know, learning this new topic.\nI definitely had fun teaching it to all of you. So what you want to do now is head down\nto the links in description and head to coder byte comm where you can actually practice\nthis new topic. Thanks for watching, and I'll see you in the next one. "
    },
    {
        "title": "10. Dynamic Programming: Advanced DP",
        "link": "https://www.youtube.com/watch?v=Tw1k46ywN6E",
        "transcript": "The following content is\nprovided under a Creative Commons license. Your support will help\nMIT OpenCourseWare continue to offer high quality\neducational resources for free. To make a donation or\nview additional materials from hundreds of MIT courses,\nvisit MIT OpenCourseWare at ocw.mit.edu. PROFESSOR: All right. Good morning, everyone. Thanks for coming on quiz day. I have to have someone\nto throw Frisbees to. Empty chairs would be difficult. So we're going to be doing\ndynamic programming, a notion you've learned in 6006. We'll look at three\ndifferent examples today. The first one is really\nat the level of 006, a cute little problem on\nfinding the longest palindromic sequence inside of\na longer sequence. Sometimes it's called longest\npalindromic subsequence. And as we'll talk\nabout, subsequence means that it can\nbe non-contiguous. So you could skip letters\nin a sequence of letters and you would still have a\nsubsequence corresponding to that. Don't have to be contiguous. And then we'll raise\nthe stakes a little bit. So each of these problems gets\nprogressively more complicated, more sophisticated. And you'll probably\nsee problems here, at least alternating coin\ngame, that are beyond 006 in the sense that\nit wasn't covered. Those kinds of notions\nweren't covered in 006. So just in terms of\nreview, I wrote this up here because I don't want\nto spend a whole lot of time on it. This is something that you\nshould have some familiarity with from the\nrecitation, for example, that you had on\nFriday and from 006. Dynamic programming is\nthis wonderful hammer. It's an algorithmic\ntechnique that you can use to solve problems that\nlook exponential in complexity. But if you can find this\noptimum substructure associated with the problem and its\nconnection to it's subproblems, and if you can\ncharacterize that, then you can do a recursive\ndecomposition of the problem where you show that you can\nconstruct the optimum solution from the subproblems. And that's really the key\nstep in dynamic programming, is step two. Once you've made this\ncharacterization, you write this recurrence out\nthat relates the optimal value of a bigger problem to the\noptimal values of subproblems. And you compute the value\nof the optimal solution through a recursive memoization. And that memoization\nis really what gives you the\nefficient algorithm, because you don't repeat\nthe solution of subproblems. You can also do this in\nan iterative fashion. Essentially, you're going to\nbe computing things bottom-up. You might want to think\nabout it as top-down when you write your recurrence. But ultimately, when you\nactually execute the program, you'll be computing\nthings bottom-up, and you'll be checking the memo\ntable to see if you actually solved this problem before. And that would be the\nrecursive memoized case, which, in some sense,\nis a little bit easier to think about and translate\ndirectly from the recurrence. But the other way to do it\nis to do it iteratively. And we'll take a look\nfor this first problem as to how you'd do the two\ndifferent ways at least from a conceptual standpoint,\neven though I might not write out the code for\neach of those cases. So a couple of choices\nhere, recurse and memoize, or essentially do\nit iteratively. And the smaller\nsubproblems would have to get computed\nfirst in both approaches. The one thing that sometimes we\ndon't spend a whole lot of time on is this last step, which\nis getting the exact solution. So a lot of the time,\nyou stop with saying, I can compute the value\nof the optimum solution, the value in terms of\nthe length of the longest palindromic sequence is 7 or 9. But what is that\nsequence or subsequence? That requires some\nadditional coding, some additional accounting. The construction of\nthis optimal solution typically requires\nsome back-tracing and some information\nto be kept track of during the recurse\nand memoize step or during the iterative step. So that's something\nto keep in mind. You're not quite\ndone once you've found the value of\nthe optimum solution. More often than not,\nyou want the solution. So we'll talk about that\nas well a little bit. But let's just dive in and look\nat this cute, little problem of longest palindromic sequence. And palindromes, of course,\nread the same front to back or back to front. Radar is a palindrome. Just as a trivial example, a\nsingle letter is a palindrome. Maybe I should have used a\nsince that's actually a word. But here I got bb. That's definitely not\na word, at least not a word that-- acronym, maybe. Radar is a palindrome. Able was I 'ere I\nsaw Elba, right? That's a palindrome. That's, of course,\nnot a single word. But it's a famous\npalindrome, days of Napoleon. But what we're\ntrying to do here is, given that we have this\nnotion of a palindrome, we'd like to discover\npalindromes inside longer words or longer sequences. So what we have is a string,\nand we'll call it x1 through n, n greater than or equal to 1. And we want to find the\nlongest palindrome that is a subsequence. And so here's an example\nto get you guys warmed up. We'll have a couple of\npuzzles here in a second. So character. And you want to find\nthe longest palindrome. And so you go, I'll pick c,\nI'll skip h, I'll pick a, I'll pick r, a, and c. And carac, which I guess\nis not a word either-- but it's the longest\npalindrome that corresponds to a subsequence of character. Right? So the game here,\nas you can see, is to pick the letters that\nform the palindrome and drop the ones that don't. OK? And we're going to have to use\ndynamic programming to do this. The answer will be greater\nthan or-- 1 in length because we've defined a\nsingle letter as a palindrome. So it has to be-- if you have\none letter in the input, well, you just pick that letter. But regardless of how many\nletters you have on the input, greater than or\nequal to 1, you know that you're going to get\nat least a one letter palindrome at the output. So here we go. Let's say I have under-- and\nthis is thanks to Eric here. I've got a couple of nice\nwords-- underqualified. The person who gets me\nthe longest palindrome wins a Frisbee. And if you want to code dynamic\nprogramming in the next two minutes and run it\non your laptops, that's perfectly fine with me. That's not cheating. So underqualified. So u is a palindrome. So we got that. Right? So one letter for sure. What else? What's the longest palindrome? Shout it out. Go ahead. Shout it out. [STUDENTS RESPOND] PROFESSOR: D-E-I--\nwow, that was quick. Deified. That's right. So right? Well, deified is to\nmake somebody a deity. So that was you, a\ncouple of you guys? Do you have a Frisbee yet? AUDIENCE: No. PROFESSOR: All right. All right. This is a little bit more\ndifficult. I tried this on my daughter\nyesterday, so I know it's a little more\ndifficult. Turboventilator. We'll call that a word. Turboventilator. Yell it out. AUDIENCE: Rotor. PROFESSOR: Sorry? AUDIENCE: Rotor. PROFESSOR: Rotor. OK, well, that's five. Can anybody beat that? AUDIENCE: Rotator. PROFESSOR: Rotator. So rotator. Rotator. So R-O-T-A-T-O-R, rotator. All right. Who is the rotator? You already have one? I want to throw this one. Right. Good practice with\nthe quiz, guys. Good practice with the quiz. No, no, no. These quiz jokes\nnever go over well. I've been teaching for\n27 years, and I still haven't learned that you\ndon't joke about exams. But so nothing like\nthis on the quiz. I don't want you studying\nthe thesaurus as opposed to the textbook for\nthe next few hours. OK? Nothing like this on the quiz. All right. Those of you who are missing\nPython, who loved 6006 in Python, let's talk about\nhow you would actually solve this using dynamic programming. And so what we\nwant is lij, which is the length of the longest\npalindromic subsequence for xij. And we're going to have i\nless than or equal to j. So that's essentially\nwhat we'd like to compute. And essentially when I've said\nthis here, when I have lij, I have decomposed the overall\nproblem into subproblems, and it was kind of fairly\nobvious in this case, because I'm going to\nhave to go in order. Right? I mean that's the constraint. A subsequence does maintain\nthe ordering constraint. It's not like I can\ninvert these letters. That would be a\ndifferent problem if I allowed you to do that. So I'm going to start somewhere,\nand I'm going to end somewhere. And I want to have a\nnon-null subsequence, so I'm going to have i\nless than or equal to j. I'm good with i being\nequal to j, because I still have one letter, and, well,\nthat happens to be a palindrome, and it'll have a length of 1. So that's my lij. And what I want to do is\ndefine a recursive algorithm that computes lij. So we'll just try and figure out\nwhat the recurrence looks like, and then we can talk about\nmemoization or iteration. So if i equals\nequals j, then I'm going to return\n1, because I know that that's a palindrome\nby default. So that's easy. And what do you think\nthe next check should be? If I look at this\nx sequence, and I have i as the starting point\nand j as the next point, what do you think the next check\nis going to be once I have-- if i is not equal to j? AUDIENCE: If x of i equals x\nof j, then j equals as well. PROFESSOR: Sorry. What was that again? AUDIENCE: If x of\ni equals x plus-- PROFESSOR: Beautiful. You're just checking\nto see-- you're just checking to see whether the\ntwo endpoints are equal or not. Because if they're\nequal, then you can essentially\ngrab those letters and say that you're\ngoing to be looking at a smaller subsequence that is\ngoing to get you a palindrome. And you're going to be able\nto add these two letters that are equal on either side\nof the computed palindrome from the subsequence. So if x of i equals equals x\nof j, then I'm going to say, if i plus 1 equals\nequals j, I'm going to go ahead and return\n2, because at that point, I'm done. There's nothing else to do. Else I'm going to return 2\nplus L of i plus 1 j minus 1. So I'm going to look inside. And I've got these two letters\non either side that are equal. So I can always prepend\nto the palindrome I got from here the letter, and\nthen append the same letter. And I got 2 plus whatever value\nI got from this quantity here. So so far, it's not\nreally particularly interesting from a\nstandpoint of constructing the optimum solution. But this last line that we have\nhere, where we have the case that the two letters\nare not equal is the most interesting\nline of code. That's the most interesting\naspect of this algorithm. So does someone tell\nme what this line is going to be out here? Yeah, go ahead. AUDIENCE: If x of L i plus\n1j or L i [INAUDIBLE]. PROFESSOR: Beautiful. That's exactly right. So what you're going to\ndo is you're going to say, I need to look at two\ndifferent subproblems, and I need to evaluate\nboth of these subproblems. And the first subproblem is\nI'm going to-- since these two letters are different, I'm going\nto have to drop one of them. And I'm going to look inside. I'm going to say--\nin this case, I'm going to drop the\ni-th letter, and I'm going to get L i plus 1j. And in the second case, I'm\ngoing to drop the j-th letter, and I'm going to get ij minus 1. And that's it. So it's a max. And there's nothing\nthat's being added here, because those two letters, one\nof them had to get dropped. They weren't equal, so one\nof them had to get dropped. So you're not adding\nanything to this. So that's good. And at this point,\nyou're kind of done. Right? Whoops. Oh, nice catch. But you did drop something. All right. So the thing that we've done\nhere is gotten to step three. So just to be clear, we're\nnot done-done, in terms of this chart here, because\nwe don't have the code there that corresponds to actually\ncomputing the sequence. So it's not that hard. I'm not going to go\nover the code here. You can certainly look\nat it in the notes. But you need a\nlittle bit of tracing backwards in this recursion\nto actually compute things. What is the complexity of\nwhat I wrote up there, though? Yeah? AUDIENCE: Theta n squared? PROFESSOR: Theta n squared. Do people agree that the\ncomplexity is theta n squared? Or is this gentleman\nan optimist? Is the complexity\ntheta n squared? Tell me why the complexity\nis theta n squared? AUDIENCE: Because\neach subproblem is-- that code right there just\nexecuted by itself is constant. But then there's theta\nn squared subproblems. PROFESSOR: Absolutely. But if you actually implemented\nthis code, and you ran it, and n was 100,\nhow long would you wait for this code to complete? Look at it. What's missing? AUDIENCE: The cache. PROFESSOR: The cache, exactly. Well, you fixed your\nown little error there. It was a trick question. So there's no recursion-- I'm\nsorry, there's recursion here, but no memoization. So this is exponential\ncomplexity. You will recur. In fact, the recurrence for\nthat is something like T of n equals 1 if n equals 1, and 2T\nn minus 1 if n greater than 1. And this would be 2 raised\nto n minus 1 in complexity. Now there's a\nsingle line of code, and you all know this,\nthat would fix this. And that single line of code\nis simply something that says, right here, look at\nthe lij-- and I'm writing this differently. I'm calling this now a 2D array. So that's why I have the open\nbrackets and close brackets. So I'm overloading l here. But it's a 2D\narray that is going to essentially be a cache for\nthe subproblem solution values. And then if you want to do the\nbacktracing to actually compute the solution, you\ncould certainly have that as an additional\nrecord that's connected to this very same value. But that's implementation,\nand we won't really go there. So look at lij and don't\nrecurse if lij already computed. OK. So that's important to remember. Now, if you actually put that,\nthe cache lookup, hash table lookup, array lookup,\nwhatever you want to call it, out there, then what you\nsaid is exactly correct. So our formula for computing\nthe complexity of a DP, that you've seen\na bunch of times and I mentioned in the\nvery first lecture as well, is number of\nsubproblems times time to solve each\nsubproblem assuming or given that smaller\nones are solved or the lookup is Order 1. So lookup. Now you could say\nthat hash table lookup is Order 1 on average,\net cetera, et cetera. So what actually happens\nin the worst case, in this particular\ncase and in most DPs, you can do things\nlike perfect caching or, something that's even\nsimpler in this case, is just a 2D array. There's not going to be any\ncollisions if you just use i and j as the indices\nto the array. So you will definitely get an\nOrder 1 lookup in this case, in most problems\nwe'll look at in 046. So if we just do that\ncomputation, which my friend over here\njust described, you do get your theta n\nsquared, because you have theta n squared subproblems. And time to solve\neach subproblem, given that the smaller\nones are solved, is simply going to\nbe a computation of a max and an addition. So all of that is theta\n1, because you're not counting the recursive calls. So this is our first example. I'm done with it. Any questions about it? Any questions about\nDP in general? All right, good. So little bit of review there. Not a particularly\ncomplicated question. Let's go to a different\nquestion corresponding to optimal binary search trees. It's a very different question. I don't think I\nneed this anymore. And it's kind of\ncute in its own way. One of things that's\ninteresting about this question is it seems like a greedy\nalgorithm should work. And we'll talk about that, as\nto why the greedy algorithm doesn't quite work. So it's kind of similar\nto the interval scheduling and the weighted interval\nscheduling problem that we had back\nin February, where the regular interval scheduling\nproblem, greedy worked, earliest finish time worked. But when it came\nto weights, we had to graduate to\ndynamic programming. So here's our second\nproblem, optimal BSTs. So what is an optimal BST? We have a bunch of keys that\nwe want to store in the BST, K1 through Kn. And we'll assume that\nthe way this is set up is that K1 is less than K2,\nda, da, da, less than Kn. And just to make our life\neasier in our examples, we just assume that Ki equals i. That's not necessarily\nrequired for anything we're going to do next. It's just for the\nsake of examples and keeping things manageable. So I got a bunch of keys. And clearly there are many\ndifferent binary search trees that can come, whether they're\nbalanced or unbalanced. Many different\nbinary search trees can be consistent with\na given set of keys. If I choose the root\nto be Kn, then I'm going to get this\nhorribly unbalanced tree. If I chose the root to be\nsomewhere in the middle, then I'm going to\nget something that looks a little better, at\nleast at the top level. But again, if I messed\nit up at the next level, I'd get something\nthat's unbalanced. So there's clearly\nmany different BSTs. I'm not talking about\nbalanced BSTs here. But we're going to define an\noptimality criterion that's a little bit different\nfrom balanced BSTs, because it's going to\nhave this additional cost function associated\nwith it that corresponds to the weight of the keys. So what is that? Well, I'm going to\nhave weights associated with each of these keys\ncorresponding to W1 through Wn. And the easiest\nway to motivate you to think that these weights\nare an interesting addition to this problem is to\nthink about these weights as being search probabilities. So what you have,\nfor argument's sake, is a static structure\nthat you've created. I mean, you could modify it. There's nothing that's\nstopping you from doing that. But let's just pretend for now\nthat it's a static structure corresponding to this BST--\nhas a particular structure. And chances are you're going\nto be searching for some keys more frequently than others. And the Wi's tell you\nwhat the probabilities are in terms of searching\nfor a particular key Ki. So you can imagine, and\nwe won't have this here, that you take-- the\nWi's all sum up to 1, if you want to think of\nthem as probabilities. Or I'm just going\nto give you numbers. I don't want to deal with\nfractions, don't particularly like fractions. So you can imagine that\neach probability corresponds to Wi divided by the sum\nof all the Wi's, if you want all of the\nprobabilities to sum up to 1. So think of them as\nsearch probabilities, because then you'll see what\nthe point of this exercise is. And the point of\nthis exercise is to find the BST T-- so\nwe're actually constructing a binary search tree here. So it's a little more\ninteresting than a subsequence, for example-- it has a richer\nstructure associated with it-- than an exponential number\nof possible binary search trees that are associated\nwith a given set of n keys that are all binary\nsearch trees. They're consistent, unbalanced,\nbalanced-- unbalanced in one way versus another\nway, et cetera, et cetera. So we want to find a\nbinary search tree T that minimizes sigma\ni equals 1 through n. Obviously, we're going to have\nthis Wi that's the game here. Depth in that T-- so this\ndepth is for that T. What is the depth of the node? And K of i plus 1. And I'll explain\nexactly what this and tell you what\nprecisely the depth is. But roughly speaking,\nthe depth of the root-- not roughly speaking. The depth of the root is 0. And the depth of\n1 below the root is 1, and so on and so forth. And so, as you can\nsee, what you want to do is collect in--\nroughly speaking, you want to collect the high\nweight nodes to have low depth. If Wi is high, you want\nthe multiplicative factor corresponding to depth T\nof that node, i, i-th node, to be small. And if Wi is small, then you\ndon't mind the depth number to be higher. You only have a certain\nnumber of low-depth nodes. You only have one\nnode of depth 0. And you have two nodes of depth\n1, which means that you only have one node where\nthat quantity there is going to be 1, because\nyou're doing 0 plus 1. And you have two nodes\nwhere the quantity is going to be 2, and\nso on and so forth. So you have some room here\nto play with corresponding to the BST structure, and you\nwant to minimize that quantity. Any questions so far? All right, good. So the search probabilities\nwould be an example. So in terms of a more\nconcrete application, you could imagine you had a\ndictionary, English to French, French to English,\nwhat have you. And there are obviously\nwords that are more common, let's say, in common\nspeech than others, and you do want to do the\ntranslation in a dynamic way using this data structure. And you could imagine\nthat in this case, the search probability\nof a word is associated with the occurrence of the\nword, the number of times over some normalized\nnumber of words that this particular\nword occurs. And that would be the way. So it makes sense to\ncreate a structure that minimizes that function,\nbecause it would minimize the expected search\ncost when you want to take this entire\nessay, for example, and convert it from English\nto French or vice versa. So this can-- if these\nare search probabilities, then this would minimize--\nthis cost function here would minimize\nexpected search cost. Make sense? Yeah. So that's the definition\nof the problem. And now we have to talk about\nwhy this is complicated, why this requires\ndynamic programming. Why can't we just do something\nfairly straightforward, like a greedy algorithm? And so let's look into that. Let me give you a really\ngood sense for what's going on here with respect\nto this cost function and maybe a little\nabstract by giving you a couple of concrete examples. First off, we got exponentially\nmany trees, exponential in n. Let's say that n equals 2. So the number of nodes is 2. Then remember that I'm assuming\nthat the Ki's are all i's, that 1 and 2 would\nbe the case for n equals 2 and 1, 2, 3 for\nn equals 3, et cetera. So I could have a tree\nthat looks like that. And I could have a tree\nthat looks like this. That's it. n equals 2, I got 2 trees. So in this case, my cost\nfunction is W1 plus 2W2, and in this case, my cost\nfunction is 2W1 plus W2. Just to be clear, what this\nis the K, and it's also the i. So the numbers that\nyou see inside, those are the i\nnumbers, which happen to be equal to the Ki numbers. And the weight itself\nwould be the Wi. So I put W1 here, and the reason\nit only gets multiplied by 1 is because the depth here\nis 0, and I add 1 to it. The depth here is 1,\nand I add 1 to it, which is why I have a 2 out here. Being a little pedantic here\nand pointing things out, because you're going to start\nseeing some equations that are a little more\ncomplicated than this, and I don't want you\nto get confused as to what the weight is and\nwhat the key number is and what the depth is. There's three things\ngoing on here. So over here you see that\nI'm looking at W1 here, which is this key. So the 1 corresponds to the 1. And this has a depth of 1, so\nI put a 2 in here, and so on. So so far, so good? When you get to n equals 3,\nyou start getting-- well, at this point, you have 1, 2,\n3, 4, 5-- you have five trees. And the trees look like this. I'll draw them\nreally quickly just to get a sense of\nthe variety here. But I won't write the\nequations down for all of them. There you go. So those are the five binary\ntrees associated with n equals 3, the\nbinary search trees. And this is kind of cool. It's nice and balanced. The other ones aren't. And I'm not looking at-- Should I have another one here? I guess I should have. This is a-- oh, no, no, no. So I'm not doing mirrors. So there are a\nbunch of other trees that have the same equation\nassociated with two-- no, that's not true. Because these are it. I was going to say that\nyou could put 3 in here, but that wouldn't be\na binary search tree. So this is it. And we've got a bunch of trees. This one would be 2W1 plus W2\nplus 2W3 by the same process that I used to show you\nthat W1 plus 2W2 for the n equals 2 case. You just go off, and\nthat's the equation. And so your goal here in\nan algorithm-- clearly this is not the\nalgorithm you want to enumerate all the\nexponentially many trees, compute the equations\nfor each of those trees, and pick the minimum. I mean, that would work, but\nit would take exponential time. But that's what\nyou have to do now. That's the goal. You absolutely want the best\npossible three that has, for the given Wi's\nthat you're going to be assigned as\nconstants, you do want to find the one tree\nthat has the minimum sum, and you want to do\nthat for arbitrary n, and you want to do that\nin polynomial time. So the first thing that you\ndo when you have something like this is forgetting\nabout the fact that we're in a\ndynamic programming lecture or a dynamic programming\nmodule of this class, when you see a problem like\nthis in the real world, you want to think about whether\na greedy algorithm would work or not. And you don't want to go off\nand build this dynamic program solution, which is,\nchances are, going to be more inefficient then\na greedy solution, which, if it produces the optimum\nanswer, is the best way to go. So an obvious greedy\nsolution would be to pick K of r in\nsome greedy fashion. And what is the obvious\nway of picking K of r to try and get a\ngreedy solution that at least attempts to\nminimize that cost function that we have there? AUDIENCE: Highest weight. PROFESSOR: Highest\nweight, right? So just pick K of r\nto be highest weight. Because that goes back to what\nI said about if Wi is high, you want this value\nhere to be small. So that's essentially\nyour greedy heuristic. So K of r should be picked\nin a greedy fashion. So what you do is\nyou pick K of r as the root in this\nparticular problem. And you could certainly\napply this greedy technique recursively. So you do that for\nevery subproblem that you find\nbecause when you do this choice of the root for\nKr in the current problem that you have, you immediately\nsplit the keys into two sets, the sets that have to\ngo on the left-hand side of Kr and the sets that have to go\non the right-hand side of Kr. So in this case,\nyou know that you're going to have a bunch of\nkeys here that correspond to Ki to K4, and\nover here, you're going to have-- oh, Kr\nminus 1, I should say, because you already\nhave Kr out there. And the keys here are going to\nbe Kr plus 1 to Kj, if overall I'm going to say that eij is the\ncost of the optimal BST on Ki, Ki plus 1, all the way to Kj. So I'm kind of already\nsetting myself up here for dynamic programming. But it also makes\nsense in the case of a greedy algorithm, where\nthis greedy heuristic is going to be applied recursively. So initially, you're\ngoing to have E(1, n)-- so if you want to\ncompute E(1, n), which is the cost of the optimal\nBST on the original problem, all the way from 1 to n,\nyou're going to look at it, and you're going to say, I\nhave a bunch of keys here of different weights that\ncorrespond to K1 through Kn. I'm going to pick the\nKr that corresponds to the maximum\nweight, and I'm going to use that as the\nroot node, and I'm going to stick that up there. And the reason I did\nthat is because I believe that this greedy heuristic\nis going to work, where this maximum\nweight node should have the absolute minimum depth. So I stick that up there. And then my BST invariant tells\nme that Ki through Kr minus 1-- remember, these are\nsorted, and they go in increasing order,\nas I have up here. You're going to have\nthose on the left, and you're going to\nhave those on the right. And then you've got to\ngo solve this problem. And you could certainly\napply the greedy heuristic to solve this problem. You could go essentially\nfind the K that has the highest weight. So you look at Wi\nthrough Wr minus 1, and you find the K that\nhas the highest weight. Actually, you're not\ngoing midway here. It's quite possible\nthat Kr is K of n. It just happens to\nbe Kr is K of n. So that means that you have the\nhighest weight node up here, but it's also the biggest key. So all of the nodes are\ngoing to be on the left. So this greedy heuristic-- and\nnow you're starting to see, maybe there's a problem here. Because if you have a situation\nwhere the highest weight node is also the\nlargest node, you're going to get a pretty\nunbalanced tree. So I can tell you that\ngreedy doesn't work. And when I gave this\nlecture, I think it was a couple of years\nago, I made that statement, and this annoying student\nasked me for an example. And I couldn't come up with one. And so I kind of bailed\non it, went on, completely dissatisfied, of course. And by the end of the\nlecture, the same student came up with a counter-example. So I'm going to have\nput that up here and thank the student who\nsent me an email about it. And so here's a\nconcrete example. It turns out I was trying\nto get a tree node example for a few minutes and failed. It's, I think,\nimpossible-- I haven't proved this-- to\nfind a tree node example with arbitrary weights\nfor which the greedy algorithm fails. But four nodes, it fails. So that's the good news. So here's the example,\nthanks to Nick Davis. And it looks like this. So I claim that the\ngreedy algorithm for the problem that is given\nto me would produce this BST. And the reason for\nthat is simple. The highest weight\nnode happens to be node 2, which has a weight of 10. So I would pick that, and\nI would stick that up here, which means, of\ncourse, that I'm going to have to have 1 on\nthis side, and I'm going to have to have 4\nand 3 on the other side. And since 4 has a higher weight\nthan 3, I'd pick that first. And then 3 would\nhave to go over here. So if I go do the math, the\ncost is going to be 1 times 2-- and I'll explain what\nthese numbers are. I did tell you it was going\nto get a little cluttered here with lots of numbers. But if you keep that\nequation in mind, then this should all work out. So what do I have here? I'm just computing-- this is W1. So you see the first numbers in\neach of these are the weights. And so this would\nbe W2 and et cetera. And you can see that\nthis is at depth 1, which means I have to have\n2 here, because I'm adding 1 to the depth. So I have 1 times 2, 10\ntimes 1, because that's at the root, 9\ntimes 2, et cetera. And I get 54. It turns out the\noptimum tree-- you can do better than that if you\npick 3, and you go like this. And so what you have here\nis the cost equals 1 times 3 plus 10 times 2 plus 8 times\n1 plus 9 times 2, and that's 49. So I'll let you look at that. The bottom line is\nbecause of the way the weights are set\nup here, you really want to use the top\nthree spots, which have that the minimum depth,\nfor the highest weight nodes. And so you can see that I could\nmake these weights arbitrary, obviously, and I could\nbreak a greedy algorithm as this little example shows. So we got no recurs here. We got to do some more work. We're going to have to use\nDP to solve this problem. The good news is DP\ndoes solve this problem. So let's take a look\nat the decomposition. And as with anything\nelse, the key is the step that\ncorresponds to breaking up the original problem\ninto two parts or more that essentially give you\nthis sort of decomposition. And we don't quite know. So this is really the\nkey question here. We don't quite know what the\nroot node is going to be. So what do we do when we\ndon't know what to do? What do we do in DP when\nwe don't know what to do? This is a very\nprofound question. What do you do? AUDIENCE: Guess. PROFESSOR: You guess. And not only do yo guess,\nyou guess all outcomes. You say, is it going\nto come up heads? Is it going to come up tails? I'll guess both. You have a die. It's going to get rolled,\na 1, 2, 3, 4, 5, 6. Guess them all, right? So if you're going to have to\nguess that the root node could be any of the keys,\nand it still-- I mean there's a linear\nnumber of guesses there. That's the good news. It's going to stay\npolynomial time. So we're going to have to guess. And once you do that\nguess, it turns out that decomposition\nthat you see up there is exactly what we want. It's just that the\ngreedy algorithm didn't bother with all of\nthese different guesses. And the DP is different\nfrom the greedy algorithm because it's going to do\neach of those guesses, and it's going to pick the\nbest one that comes out of all of those guesses. So it's really not that\ndifferent from greedy. So we'll keep that up\nthere, leave that here. Let's go over here. So the recursion\nhere is not going to be that hard, once you have\ngotten the insight that you just have to go make a linear\nnumber of guesses corresponding to the root node for your\nparticular subproblem, and obviously this\nhappens recursively. So there's a little\nsomething here that that I'll point\nout with respect to writing these equations out. So what I have here,\njust to be clear, is what I wrote up there. Even when I was talking\nabout the greedy algorithm, I had the subproblems defined. So the original problem\nis E1 through n. The subproblems\ncorrespond to eij. And given a subproblem,\nonce I make a root choice, I get two subproblems that\nresult from the root choice. And each of those\ntwo subproblems is going to be\nsomething-- and this is something to keep in mind as\nwe write these equations out-- they're going to be one\nlevel below the root. So keep in mind that the\noriginal eij subproblem corresponded to this\nlevel, but that Ei r minus 1 problem and\nthe E r plus 1j problem are at one level below. So keep that in mind as we\nwrite these equations up. And so what I want to do here\nis just write the recurrence. And after that, things\nbecome fairly mechanical. The fun is in the recurrence. So I got Wi if i equals j. And so I'm at this level. And if I just have one node\nleft, then at that level, I'm going to pay the weight\nassociated with that node, and I'm going to have\nto do a certain amount of multiplication here\nwith respect to the depth. But I'm just talking about\neij as the subproblem weight, just focusing in\non that problem. So if I only have one\nnode, it's the root node. And that weight\nis going to be Wi, because the root\nnode has depth of 0, and I'm going to add 1 to it. So for that\nsubproblem, I got Wi. Keep that in mind, because\nthat's the only subtlety here with respect to these\nequations, making sure that our actual cost\nfunction that we're computing has the correct\ndepth multiplicands associated with it. So then we have our\nlinear guessing. And I might have said\nmax at some point. We want to get the min here. And I had minimize\nhere, so I think I wrote things down\ncorrect, but at some point, I think I might have said\nwe want to maximize cost. But we do want to minimize\ncost here corresponding to the expected search. So we're doing a linear,\nand we're doing a min. And we're going\nto go off and look at each of the different\nnodes as being the root, just like we discussed. And what I'm going to do here is\nI'm going to simply say, first, that I'm going to\nlook at Ei r minus 1, which corresponds to this, and\nI'm going to have plus E of r plus 1, j. And at this point,\nI don't quite have what I want because\nI haven't actually taken into account the fact that\nthe depth of the Ei r minus 1 and the r plus 1j is\n1 more than the eij. So it's 1 more than that. And I also haven't taken\ninto account the fact that, in this case, I definitely\nneed to add a Wi as well. Because the root node is part\nof my solution in both cases. In one case, it ended my\nsolution, the top case. But in this case, it's\nalso the root node, as you can see over\non the left, and I've got to add that in there. So I definitely need\nto add a Wi here. And what else do I need to add? From a standpoint\nof the weights, what other weights do I\nneed to add to this line? Yeah? Go ahead. AUDIENCE: First of all,\nshouldn't that be a Wr? PROFESSOR: First of\nall, that should be a Wr, you're exactly correct. AUDIENCE: And you want\nto add all the weights. PROFESSOR: And you want to\nadd all the weights, right. You're exactly right. I have two more\nFrisbees, but I need to use them for something else. So you get one next time. Or do I have more than that? No, no. These are precious\nFrisbees here. Sorry, man. And you corrected me, too. Shoot. This is sad. So that needed to be a Wr. But you also need to add up all\nof the nodes that are in here, because they're one more level. And now you see why\nI made the mistake. I don't usually make mistakes. But what I really\nwant-- actually it's more like-- I don't\nknow, a few per lecture. Constant order one mistakes. I'm going to say this is\nWi, j, where Wi, j is simply the sum of all of the\nweights from i to j. And this makes perfect\nsense, because the nice thing is that I don't even need\nto put an r in there. I could choose a particular r. Wr will be in there. But all of the other nodes are\ngoing to be in there anyway. So it doesn't really\nmatter what the r selection is corresponding\nto this term here. I will put it inside\nthe minimization. This bracket here\nis closed with that, but you can pull that\nout, because that doesn't depend on r. It's just going to be there\nfor all of the cases, all of the guesses. So that's it. That's our recurrence\nrelationship corresponding to the DP for this\nparticular problem. You can go figure out\nwhat the complexity is. I have other things to\ndo, so we'll move on. But you can do the\nsame things, and these are fairly mechanical at this\npoint to go write code for it, trace the solution to get\nthe optimum binary search tree, yadda, yadda, yadda. Any questions about this\nequation or anything else? Do people get that? Yeah, go ahead. AUDIENCE: What is\nthe depth input? PROFESSOR: So the depth is\ngetting added by the weights. So basically what's happening\nis that as I go deeper into the recursion, I'm adding\nthe weights and potentially multiple times,\ndepending on the depth. So if you really think\nabout it, this Wij, I added all of these weights. But when you go\ninto this recursion, into the ei of r\nminus 1, well, you're going to see i to r minus 1 in\nthe next level of recursion. So you would have\nadded the weight again. So it's not the case\nthat the weights are only appearing once. They're, in fact,\nappearing this many times. So that's what kind of\ncute about this, the way we wrote it. Any other questions? All right, good. So we're done with that. So one last example. This is, again, a little bit\ndifferent from the examples of DP we've looked at up until\nnow, because it's a game. And you have an\nopponent, and you have to figure out\nwhat the opponent is going to do and try to win. I suppose you could\ntry to lose as well. But let's assume here, same\nthing with minimization and maximization,\nmost of the time you can invert these\ncost functions, and DP will still work. But let's assume here that\nyou want to win this game. So the game is an\nalternating coins game where we have a row of n\ncoins of values V1 through Vn. These are not necessarily\nin any particular order. And n is even. And the goal here is\nselect the outer coins. So select either the first\nour last coin from the row, and then the opponent plays. Remove permanently, but\nadd it to your value and receive the value. So I need two volunteers\nto play this game. And you want to\nmaximize the value. The winner gets a blue Frisbee. The loser gets a purple\nFrisbee, because blue is greater than purple. And you might ask, why is that. Well, if you went to a beach,\nand you saw water this color, and you went to another beach,\nand you saw water this color, which beach would you pick? Right? This is Cozumel. This is Boston Harbor. So blue is greater than purple. Don't use this proof\ntechnique in the quiz. So do I have a couple of\nvolunteers to play this game? Two of them over there. Are you waving for him? Yeah. I see one. You can come down. Another volunteer? Yeah. Over there. You don't get your Frisbees yet. So we're going to\nmake this really fair. What's your name? AUDIENCE: Josiah. PROFESSOR: Josiah. AUDIENCE: Tessa. PROFESSOR: Tessa. Josiah and Tessa, I'm going\nto write out a bunch of-- it's going to be a fairly short game. And we're going\nto be really fair, and we're going to flip a coin\nto decide whether Josiah goes first-- you can pick\nheads or tails-- or whether Tessa goes first. Actually if you win, you can\nlet her go first if you want. But you get to choose. AUDIENCE: All right. PROFESSOR: So pick. AUDIENCE: Heads. PROFESSOR: That's heads. Do you want to go first, or do\nyou want to let Tessa go first? [LAUGHTER] AUDIENCE: You should go first. PROFESSOR: All right. So Tessa, you get to go first. AUDIENCE: OK, 6. PROFESSOR: 6, OK. So let's just say T.\nSo you get to choose either 25 or 4, Josiah. AUDIENCE: I think I'd pick 25. PROFESSOR: You think\nyou'll take 25. So that's j. So it's not on the 4 and 19 over\nhere because those are gone. So your turn again. AUDIENCE: OK. Can I take a minute,\nor should I just go? PROFESSOR: Well, you\ncan take 30 seconds. AUDIENCE: 19. PROFESSOR: 19, OK. AUDIENCE: 4. [LAUGHTER] AUDIENCE: All right, 4. PROFESSOR: 4. All right. And 42? AUDIENCE: Yeah. PROFESSOR: All right, 42. This is one strange game. Now, we get to add\nup the numbers. This is going to be tight. 4 plus 39 is 43. 43 plus 25 is 68. 42 plus 19 is 61. 61 plus 6 is 67. Ooh. Well, you get Frisbees. Well, blue for you. I mean, you could give\nher blue if you like. AUDIENCE: I prefer purple. PROFESSOR: You prefer purple. Thanks. Good job. [APPLAUSE] No offense is intended\nto Josiah and Tessa, but that was a classic example\nof how not to play the game. First off, Josiah could\nhave won regardless of the coins that were\nup there, regardless of the values of the coins,\nif he'd chosen to go first. So this game, the\nperson who goes first is guaranteed to not lose. And by that, I mean you\nmay have a situation where you can have a tie in\nterms of the values, but you're guaranteed\nto not lose. Now, he ended up winning\nanyway, because there were other errors\nmade during this, and I don't have the time\nto enumerate all of them. [LAUGHTER] So we're just going to go move\non and do the right thing. So let me first tell\nyou, outside of DP, just in case you play this game\nover Spring Break or something, how you can win this\ngame without having to compute complicated\nrecursive memoization DP programs for this case. So let's say I have V1, V2,\nV3, all the way to V n minus 1 and Vn. And remember n is even. So you've got to\npick n over 2 coins if you're the first\nplayer and n over 2 if you're the second player. So what the first\nplayer does is simply compute V1-- take the odd\nnumbers-- and n is even, so you've got V n\nminus 1 being odd. Compute V1 plus V3 all\nthe way to V n minus 1, and compare that with\nthe even positions, V2 plus V4 all the way Vn. So in this particular\ninstance, Josiah, who went second,\nif you just look at the odd positions, which\nis, in fact, what he ended up picking, it was 4 plus\n39 plus 25, which was 68. So you can do this\ncomputation beforehand. You compute this to\nbe 68, in our case. Compare that with 67. And you don't give up your\nfirst-player advantage. So you're going with\nthe first player. But now you say, I know\nthat I can set this up-- and that wasn't\nthe order that he did this-- but I know\nI can set this up so I always have a chance to\nget V1, V3, V5, et cetera. Because let's just say that\nthe first player Josiah started first. And he decided, in this\ncase, that the odd values are the ones that win. So let's say he picks V1. At this point, Tessa\nsees V2 through Vn. So you're just looking at that. Now Tessa could either pick\nV2 or she could pick Vn. In that case, Josiah,\nwho's the first player, could pick V3 or Vn minus\n1 and stick with his rule of picking the odd coins. So regardless of\nwhat Tessa does, the first player,\nJosiah, could pick odd if odd was the way to go or if\nthe values were such that, even with the way to go,\nhe could go even. So no reason for the\nfirst player to lose. But let's just say that you're\na nasty person, Michael Jordan nasty. You want to just\npress your opponent. You want to make sure they\nnever want to play you again. So now you have a\nmaximization problem. So this is clearly not DP. You don't need DP to add\nup a bunch of numbers. But let's say that you want\nto, given a set of coins, V1 through Vn, you want\na dynamic strategy that gives you the maximum value. This odd versus even\nis a bit constraining, because you're stuck\nto these positions. And it's good to be\nin that situation if you just want to win and\nyou don't care how you win. But if you want to\nmaximize, then it's a more complicated problem. And so we have to talk about\nhow you would do something that would give-- maybe it would be\nV1 and V4 and something else, depends on the values. How would you get\nto a situation-- if you're the first player. We'll just stick with\nyou're the first player. You know you can't lose\nusing this strategy. But not only do you\nwant to not lose, you want to get as many\ncoins as possible-- let's say this is money. More money is better,\nand that's your goal. So people understand that. A little trick there with,\nI guess, a greedy algorithm you can think of. Or it's not really\neven something that you might want\nto call an algorithm. It's a little computation. And our goal now is to\nmaximize the amount of money when assuming you move first. And so this is going to be a\nlittle bit different from all of the other problems\nwe've looked at, because we have to now think\nabout what the opponent would do. And there's going to be\na sequence of moves here. You're going to move\nfirst, so that one is easy. You've got the whole problem. But now you have to\nsay, the opponent is going to move\nand pick a coin. And then you have to\nthink of your subproblems as the potential rows of coins\nthat are going to be different, depending on what\nthe opponent does. And through this process, you\nhave to maximize the value. So it's really pretty\ndifferent from the other couple of examples that we looked at. So we're going to have to\ndo a little bit of set-up before we get to the point\nwhere we can write something like this, which is\nthe solution to our DP. And so let me do that set-up. But it's not super complicated. And part of this is going\nto look kind of the same as previous problems\nwe've looked at. So Vij is the max\nvalue we can definitely win if it is our turn. And only coins Vi\nthrough Vj remain. And so we have Vii. Then there's only one coin\nleft, and you just pick i. Now, you might say,\nbut that's never going to happen if there's\nan even number of coins and I'm playing first, because\nthe other player is going to be at the end of the-- is\ngoing to be the person who picks the last coin. But we need to\ncategorize Vii because we need to model what the\nother player is going to do. So we can't just\nsay that we're going to be looking at an even\nnumber of coins in terms of the row of coins that\nyou look at, which is true, that when you get\nto move, you only see an even number of coins\nif you're the first player. But you do have to model\nwhat the opponent does . So we need the Vii. And what you might\nsee, of course, is a board that looks like Vi\ni plus 1, for some arbitrary i. So that's why I\nhave it up there. But remember that you're only\npicking coins on the outside, so it's not like you're\ngoing to have a gap. I mean, you're not going to\nhave V3 left and V7 left. There's no way that's\ngoing to happen. You're just going to keep\nshrinking, taking things from the left or the right. So it's going to\nbe i and i plus 1. That make sense? And so in this case,\nwhat would you pick? Vi and i plus 1. You just pick the max. Because at the end of this,\neither you did it right or you did it wrong. Either way, you're going\nto improve your situation by picking the max\nof Vi or Vi i plus 1. So there's no two\nthings about it. So here, you're going to\npick the maximum of the two. And you might have Vi i plus 2,\nwhich is an odd number of coins that your opponent might see. It gets more complicated\nfor Vi and i plus 2. We're going to have to now start\nthinking in more general terms as to what the\ndifferent moves are. But we've got the\nbase cases here. All I did here was take\ncare of the base case or a couple of base\ncases associated with a single coin, which\nis what your opponent will see and pick, or two coins,\nwhich is your last move. So with DP, of\ncourse, you always have to go down\nto your base case, and that's when\nthings become easy. So we have to talk\nabout two things and put up our\nrecurrence together. The two things we\nhave to talk about are what you do when you\nmove, and that's actually fairly easy, and\nthe second thing is what the model\nof the opponent looks like when you're waiting\nfor him or her to move. So let's take a\nlook at your move. And I've got V1. Let's look at Vi. Vj here, dot dot dot, Vn. So that's what you see. And you're looking at i and j. And at this point, you're\nseeing all those other coins, the outer coins have disappeared\ninto people's pockets. And you're looking\nat this interval. So I'm going to write\nout what Vij should be. And keep in mind that we want\nto maximize the amount of money. And we want to say\nthat you should be able to definitely win this\namount of money, regardless of what the opponent does. So I want to do\na max, obviously. And I have two choices here. I can pick Vi or I can pick Vj. It's not like there's\na lot of choices here. So if I pick Vi,\nthen-- let me go ahead and say I pick Vi here. And here, I pick Vj. Let me draw this out\na little bit better. So I've got to fill in these\ntwo arguments to my max. So this is easy. I'm going to have\na plus Vi here. Going to have a plus\nVj here because I picked the appropriate value. And now, this is also\nnot that difficult. What exactly happens? What can I put in\nhere if I pick Vi? AUDIENCE: Vi plus 1. PROFESSOR: Yeah. Vi plus 1 to j. So the range becomes i plus 1 j. I have to be a little\ncareful here in terms of whether I can argue\nthat it's actually the V that I put in here. So the subtlety here is\nsimply that the Vi plus 1 j is not something that\nI see in front of me. This is the complication. Vi plus 1 j is never a board\nthat I see in front of me, whereas Vij was a board\nthat I saw in front of me. So I have to model the boards\nthat I see in front of me, because those are the boards\nthat I have control over that I can maximize. I cannot would be Vi\nplus 1 j in there, simply because I don't\nquite know what that is, because of what I get eventually\nis not something I control. It's going to be the board\nafter my opponent has moved. So all I'm going to do is\nI'm going to say the range becomes-- range is i plus 1 j. And I'm going to say something\nelse in a second here. The range is i j minus 1. And in both of these\ncases, the opponent moves. So in order to actually\nwrite out my DP, I'm going to have to now\nlook at the worst case situation in terms of\nthe board I get back, because the only times\nI'm adding values is when I see a board in\nfront of me and I pick a coin. And I'm going to have to say\nnow the opponent is going to see an i plus 1 j-- or\nan i j minus 1, excuse me, and might do something. And I'm going to\nget something back. I'm going to assume that\nthe opponent is just as smart as I am,\nknows DP, taken 6046, et cetera, et cetera. And I still want to\nget the maximum value that I can definitely win. And so we need to look\ninside of that a little bit. And it's not that hard if\nyou just make the assumption that I just did,\nwhich is the opponent is going to do-- I mean\nmight not necessarily do the right thing. But you have to assume that\nthe opponent knows just as much as you do and is going to try\nand do as well as possible. So let's do that. That's the last thing\nthat we have to do here. And it's just one more equation. So here's the solution. We now have Vi plus 1 j\nsubproblem with the opponent picking. And the simple\nobservation is that we are guaranteed the min\nof Vi plus 1 j minus 1 or Vi plus 2 j. In this case, the opponent\npicks Vj, and in this case, the opponent picks Vi plus 1. And you're guaranteed\nthe minimum of these two, because the opponent\ncan only pick one coin. So that's the simple\nobservation that lets you jump ahead to your\nnext move, which is really what the DP is interested\nin, because that's the only time that you're\nactually executing something in terms of picking\ncoins from the board and adding to your value. But we did have to model that\nas to what the maximum value was that you could win,\njumping ahead of this move. And you have the min\nin here because you're assuming that this is\na definite guarantee. That's what we want. It's possible that the\nopponent plays a different game from the one that we think\nhe or she is going to play, which maximizes his or value. But the min is guaranteed. So now that you've\nmade this observation, it turns out we just have to\ntake that, and we'll be done. So let's see. Let me erase this. It's the last set of equations. And it's just plugging\nin that observation into what I wrote before. So we have Vi j equals max. This is the outer max that\nI had up there already, so that's the same max. And put these giant\nbrackets here. And inside, I'm going to\nplug in this min, which is something that\ncorresponds to the value that I would win\nin the worst case after the opponent plays\nthe best possible move. And that would be Vi plus 1 j\nminus 1, V1 plus 2 j plus Vi. This Vi is the same\nas this one up here. And you've got a plus Vj here. And I didn't actually\ndo this, but in terms of writing out what the opponent\nwould do in other subproblem case, but it's really\npretty straightforward. You have a problem\nthat corresponds to the i j minus 1 problem. And the opponent\ncould pick the i-th or could pick the j minus 1th. If the opponent picks\nthe j minus 1th, you get Vi j minus 2, and you\nneed to take the min of that. In the other case, where the\nopponent picks i, in which case you get i plus 1 j minus 1. And that's our DP. That's our DP. So the big difference\nhere was the modeling that you had to\ndo in the middle. We didn't actually have\nto do that in any of DPs we've covered in 046 at\nleast up until this point. Before we talk about complexity,\nthat should just take a minute, people buy that? See that? Good. So with all of these\nproblems, the complexities are fairly straightforward\nto compute. The complexity here\nis simply, again, as before, the number\nof subproblems times the time it takes to\nsolve the subproblem. You can see here are that\nthese are all constant time operations. So assuming that the\nVij's have been computed, it's theta 1 time to\ncompute a subproblem. So that's your theta 1. And as before, there are\nn squared subproblems. Sorry. Let's just do number of\nsubproblems times theta 1. It's just theta n squared. So that was good. All right. So good luck for the quiz. And don't worry\ntoo much about it. See you guys next week. "
    },
    {
        "title": "A Deep Understanding of Dynamic Programming [Intro / Overview]",
        "link": "https://www.youtube.com/watch?v=Clp5c7HvLqs",
        "transcript": "welcome this is a lesson on dynamic programming and we'll cover roughly everything you need to know to start solving problems and before we start let's do the prerequisite the main thing you should already know is recursion because db solutions usually build upon recursive solutions if you don't know recursion you can still benefit from a good portion of this lesson but it won't be truly complete without recursion knowledge and if you need a good resource for that check out the lesson from this course now here's my effective resume in terms of competitive programming i have about three years of experience in competitive programming and i reached the rank of international grandmaster on code forces and seven star on co-chef in terms of google stuff i've gotten to round three and code jam twice and my best ranking kickstarts the tenth which i also got twice by some coincidence so yeah the point of this resume is not to flex because there's not really a point in doing that i just want to say you can trust me i know what i'm talking about i'm not going to mislead or confuse you and this lesson will be accurate well thought out and complete and with that said let's get into the lesson but before we start the lesson let me give you a quick overview of how this will be structured we'll start with a brief overview of the big picture of dp and use a carefully selected example problem to demonstrate the point of dp and its power i'll go over both of the common methods of using dp namely the recursive and iterative methods and after that we'll establish some vocabulary and tie it back to the example problem so you can understand it in context then i'll give you a couple of very useful methods you can use to start solving problems with dp and we'll use three example problems to give you a bit of practice with those methods i'll finish off by comparing the recursive and iterative methods so you can know which one is better suited for your current level and i'll also briefly go over some more advanced forms of dp that you can use as a guy once you've mastered the basics now let's start with what is dp because i think it's a good idea to start with the big picture so you can understand what this technique is and what we're really trying to do here and the main trick of dp is we're going to be solving problems recursively via the recursive method of breaking down the large problems into smaller subproblems in fact we're going to be doing brute force recursively most of the time but it's going to be a smart brute force we're going to save time by not doing the same thing multiple times and we'll do that by discarding useless information about the solutions generated by the brute force now that probably doesn't make sense by itself so let me illustrate this with a problem say our task is to count the number of different paths on a grid where from the red cell to the green cell where you can only go down or right now first let's imagine how a brute force would solve this in this example there are four total paths i'll show sorry a brute force would simply go through all of them and count each one you don't strictly need code to understand this but feel free to implement this brute force yourself if you want and i'll show the code here too you can pause the video and see that but let's look more closely at this blue cell there are two ways to get from red to blue and for both of these waves we're also going to take both paths from blue to green but let's ask why are we taking the blue to green paths both times because remember the big picture we're discarding useless information once we get to blue we don't care how we got there from red all we care about is that there are two paths from red to blue so let's compress both of the red to blue paths into a single path it'll have something like a value of two which represents that there are two ways to get to blue then we can go from blue to green only once instead of twice but we'll remember that there are two ways to get to blue so each time we get to green we can add two to the answer instead of one and that way we'll still get the four paths we'll do it a bit more efficiently because we compress these paths into a single path and that's our other big picture idea not doing the same thing more than necessary we only got we only go from blue to green twice for the two paths instead of four times and okay but that was a contrived example that grid looked kind of weird you know so let's do it for a general three times three grid now and here there's no clear middle point there's no blue cell where we can use the optimization but why not just treat every point as the middle point what we can do is we can essentially treat every cell like the blue cell and for each cell our goal will be our goal will be to count the number of paths that end at that cell so we immediately know there's one path from the red cell to the red cell obviously what can we do from the red cell we can only go down or right if we go down then we know of one path ending at that downward neighbor where we go down from the red cell so we can add it to that neighbor and if we go right same deal we know of one path ending at that rightward neighbor and we can process every cell like this for each cell figure out how many paths end at this cell let's call it x then if we go down we know the x paths go through the orange cell and then go down so we should add x to the downward cell and do the same for the rightward cell x paths go to the orange cell and then go right so let's just run through this whole example really quickly each cell will be orange and we will push out the number of paths from the orange cell to its neighbors and here's what the code would look like for this again you can pause the video i'm not going to dwell on it so it should make sense why this is correct at least right maybe not why it's maybe not why it's like fast but it should make sense why it's correct because we're still doing the brute force the only difference is for each cell we're compressing all of the paths that lead to that cell into one single path for each path we're discarding the information of how we got to the ending point because it doesn't matter all that matters is where it ends meaning that we're allowed to mash together all the paths that end at the same point and we're actually solving the assigned problem for each cell instead of just the green cell and that's kind of the recursive way to think about it we just solved the same problem for every cell and we use the answers of the smaller sub problems to build up to the larger sub problems and the number of possible ending points for pads is just the number of cells so it should make sense that the time complexity is the number of cells because that's literally the only information we have about the pads and there's one more thing i should note when we push out the answer from a cell to its neighbors we need to make sure that our answer for that cell is correct that is we need to have pushed the answers from all the cells that affect the cell which in this case are the upper and left neighbors for this problem going through the cells in row major order is fine because we can only move down and right but for other problems the necessary order may be more complicated so be careful about that and one more thing if you're familiar with graphs you can think of these push relationships as directed edges in a graph where the states are nodes then the order that you have to visit the nodes has to kind of be a topological sort of this directed graph but in most problems it's going to be as simple as going from smallest to largest or largest the smallest so don't worry about too much don't worry too much about the like ordering stuff when you're starting off and that's it that's dp this generally general sorry this explanation may be hard to generalize so i'll run through a couple more practice problems later in this video but if you're comfortable with recursion i'll also show you a different method that you might find easier to use or more intuitive now again think about how you would brute force this brute force this recursively it would essentially be backtracking starting from say the ending cell and computing the number of paths for each cell that start sorry computing the number of paths that end at each cell if you didn't have it before for the iterative solution i would recommend having code for this so you can try to code it for yourself or just see the code from before i'll show it again here but we can do an optimization here that's pretty similar to the iterative method let's look at our contrived example again the compression would actually be the exact same for each cell we compress all the paths ending at that cell into one path representing the number of pads ending at that cell so instead of all the paths we just have the number of paths and of course we can do this for every cell as well implementation wise it's not actually much different from the recursive code itself and like i want you to try and think about how we can do this like actually pause the video and figure out how we can manage to go through the red to blue paths once okay hopefully you paused if you didn't come up with anything that's fine because we're all here to learn and the trick is let's remember the number of red to blue paths after we compute it for the first time and we'll remember the answer for every cell to that way we compute each cell's answer exactly once and afterwards we can just return the value that we remembered so this is what it would look like in code as you can see here we're storing this extra right answer that represents the answers that we remembered from previous states that we from previous cells that we visited now this is called memoization and it's not a typo or a verbal typo and don't ask me why it's named that instead of just memorization but the complexity analysis and stuff is pretty similar to the iterative version so i'll just leave it to you to figure out and by the way you can convert between recursive and iterative pretty easily for example to convert from recursive to iterative just change the parentheses to brackets and put in a loop simple enough right it's also worth taking the time to relate this method to the big picture ideas in this case we're once again able to get rid of the information of the paths themselves all we care about is where the pads end we're allowed to only compute an answer for an ending cell once because that answer will be the same answer no matter how the rest of the path will be and if you want a bit of practice here's a variation of this problem you still move on a path from top left to bottom right and you can still only go down to right but now each cell has a value a number the cost of a path is the sum of numbers on the cells you visit and your task is to find the minimum cost over all paths for a problem like this you would compress the possible paths into not the number of paths because we're not trying to count anymore but the best possible path like the path with minimum cost so if you end up trying this good luck all right before we get into more problems let's establish a bit of vocab related to the grid problem so you can understand it in context if you want more examples of the vocab you can check out the section with more problems that comes later in this video so the first thing in the vocab is the state the state essentially represents the values that the discarded information was compressed to it also just represents the sub problems we solved to build up to the main problem in the grid problem this is just the cell because we compressed all paths ending at that cell and do just the number of paths ending at each cell so the only information that matters is the ending point which is the cell the next thing are transitions which represent how states kind of interact with each other in the grid problem the states the transitions are represented by moving down a right so for iterative the transition will be pushing the answer from cell r c to r plus one c and r c plus one aka down and right and for recursive the transition is taking the answers from r minus 1c and rc minus 1 aka left and up or up and left respectively and adding them to get the answer for cell rc and similar to recursion there are base cases these are the easiest type of states which you already know the answers to in the grid case the base case is the starting cell which has exactly one path you can also consider the edges the base cases be because you have to treat them special and make sure to avoid an out of bounds error and also similar to recursion dp always needs base cases or there'll be no starting point for our answer and here's a bit of vocab that can further distinguish the two methods i talked about earlier there's pull dp and push dp in pull dp we essentially pull from previous dp values to compute the current one in pseudocode is structure like for each state x that we're trying to compute for each state y they can affect x so for all the states that x depends on do some transition with dpy to dpx or do some like for example you can add dpy dpx or do some mimik shenanigans it all depends on the problem so we're pulling the information from the y states and using them to figure out what the x state is this was equivalent to our recursive solution in contrast push dp is more like taking the value of the y state and pushing it to all the x states that it affects pseudocode is something like for each state y for each state x that it affects do some transition with dpy and dpx so we're pushing the information from the y state out to the x states that it affects this was our iterative solution i personally find push dp a lot more intuitive because usually in a problem you can do something to the state for example you can move around or add an element onto an array when you do an action you modify the current state into a new state then you would naturally push the current state value onto the new state because you just went from the current state to the new state but when you do this with pull dp you kind of have to reverse the actions so you would maybe have to move backwards or remove an element from the array and do the opposite of what the problem statement tells you to this personally feels more confusing to me but it does allow for the usage of recursive formulas so it can also be useful and since i just mentioned it recursive dp can only be pull dp because think about trying to use push dp on a grid problem recursively if i push the starting cell to the cell on the right and then visit that cell then maybe i'll visit the orange cell next because that's how recursive dfs would work but that orange cell doesn't have the answer from its left so we'll think it only has one path which is wrong for pole dp this is fine because we can just recursively compute the answer if we don't know it and for iterative dp the order always matters because we can't just recursively compute the answer like i just said for iterative dp because iterative can't make use of a recursive function so if we do pol dp iterative we also have to make sure that our order is fine and the answers we pull are complete all right we've established our vocab now i'll give you some tips to help you start off with solving dp problems and the first question you might have is how would you recognize that a problem is solvable with dp my my answer to that is just intuition you'll eventually just have a dp radar kind of where you can roughly tell if dp applies to a problem or not and that radar comes with practice but if you don't have it yeah i'll give you an alternative instead whenever you try a problem like any problem just ask yourself can it be solved with dp because you don't have that radar radar you don't know if a problem is dp or not but you can try it anyway and just assume it can be solved with dp and try your hardest to apply dp to the problem and if you succeed great you solve the dp problem and if you don't it's quite possible that it wasn't a dp problem at all and that's fine you still learn an example of when dp doesn't work so you're getting better at it either way and you're getting the practice in and if you thought it wasn't dp but it is that's kind of problematic so spend some extra time thinking about what you missed and how you might could have come up with the right solution another perhaps obvious question is how do you actually solve problems with dp there are two main ways you can go about doing this and the first is think about how you can solve the problem recursively remember i mentioned at the beginning dp is basically just recursion so think about how you would solve it with like a brute force or backtracking as a first step if your answer is a sequence of moves process it one move at a time if you're given an array process the array one element at a time stuff like that you end up breaking the problem into little bits and solving one bit at a time then passing out the rest of the problem to another recursive call that's how you think recursively that's how you solve problems recursively and once you have a recursive solution that usually tells you the state and transition for example here's some code that demonstrates how i can get that information the state in this case is given by the parameters to the recursive function it's just the cell and the transitions the moves are given by the para are given by this recursive calls you make the smaller states and if you add in memoization you'll often just have a solution right there and that's what we did for our recursive solution to the grid problem but it also gives enough insight for you to be able to solve it with the iterative method too if you want practice with that and if there's no obvious recursive solution there's another way to find a dp solution often you can pull the state and transition straight out of the statement like there aren't that many possibilities for what can be part of the state and the state usually represents a smaller version of the main problem you're solving that you use to build up to the main problem so wouldn't it make sense that the state might just be the problem you're solving as long as you make sure you're getting rid of useless information you can often just get the state right out of the problem statement and you can get the transitions in a similar way if the problem allows you to do something like move around or change something about the state then that usually takes you from one state to another and that's what transitions are so you can figure out the transition from what the problem asks you to do and if neither of those methods work chances are it's not an easy dp problem so you're probably going to have to be able to conceptually reason about dp problems and come up with something smart to solve it which you'll only be able to do with practice if you get the practice in you can solve anything and speaking of practice here's an extra problem you may recognize you may recognize it you may not but either way it's fine so pretend you're a frog you start at position zero on a line and you're going to go to position n in one move you can either jump one unit to the right or two units to the right and similar to the grid problem we're going to count the number of different pads you can take from zero to n so right now take some time to pause the video and try and solve this for yourself this could be called easier than the grid problem but it also might not be so don't worry too much about the difficulty for now just try to solve it okay hopefully you paused so let's first ask what information is important about our path and what information isn't is there some defining feature we can compress all identical paths into a single state and with those questions in mind how would you solve this problem recursively just try writing a brute force first if you want you can spend some more time thinking about these questions so pause the video you can come back right now right so the state should just be our position in our current path we don't care about how we got to this position all that matters for the future is that we're here very similar to the good problem since nothing to the left can restrict our movement to the right so we don't care about anything about a previous path the only thing that matters again is our current position and what about the transitions well those are given directly from the statement we can either move one or two units to the right and both of them are almost always valid options so a transition should be adding together the possibilities and moving one or two units if you wrote a recursive solution it probably looks something like this it doesn't have to necessarily look exactly like this but it could look similar you'd be using memorization you'd be counting the number of paths starting from zero and ending at the value pause you can move one or two units so you can either come from one unit to the left or two units to the left meaning that you sum the number of pads ending at those two positions and if you wrote an iterative solution it's probably similar to this since the answers for positions rely on positions to the left we would iterate from left to right starting with zero at the base case and that way when we compute the answer for position we've already computed everything to the left of it meaning we've already computed the answers that this position depends on so if we know that there are x paths to position pause then we know if x passed the pause plus one because we can jump one unit on each of those pads and we know of x paths to pos plus two because we can also jump two units in either case the state is still the position and the transitions are still jumping now relating this to our big picture ideas we optimize this brute force by compressing all paths with the same ending point into a single path and we don't process any ending point more than once because we don't care about how we got to a particular ending point only that we got there and by the way this problem is equivalent to the fibonacci sequence if you recognize it good job uh yeah okay here's another problem we'll just do knapsack which is very common you have an array of numbers of length n and a target value t you want to answer is it possible to select some of the numbers from the array so that these selected numbers sum the t and here are some examples of when it's possible and not possible so you can again pause the video spend some time to try and solve this one okay hopefully some time has passed so let's start with the basic methods again it might not be immediately obvious how to get the state from the problem statement because there are a lot of options there's for example you could have n in the state you could have t in the state you can have all combinations of selected elements in the state so let's try the other method of just writing a recursive brute force and we can ask the same questions as the last problem to help with thinking about our recursive solution as mentioned before to solve array problems recursively we usually handle the problem element by element again you can pause the video here if you want you don't have to um okay so we look at the first element do we select it or not if so our target sum goes down by that element because we just made progress towards the sum we just we made progress towards the sum with that element where that element closer to the the target sum so for element was three we're three closer to the target and if we don't choose that element our target sum is the same but either way we should move on to the second element because we made our choice about the first element we decided what to do either we took it or not so we never need to process that element again and we can do this for each element we make our choice about whether we'll take it or not and we move on to the next element so the state for our recursive solution is the current element that we're considering and our current target sum and the transitions are we can either take our current element or not so now we have our recursive brute force and here it's simple enough that we can just add a memoization and be done here's the recursive code for reference i'm not going to dwell on it and if you want to do it iteratively we still handle it element by element but unlike the other problems here we won't push the number of solutions to the new state because we're not trying to count all we're pushing is that now it's possible to reach that new state and also note that our current state has to be reachable for us to be able to push to new states because otherwise like we're it's already impossible and we're saying that other things are possible from this impossible to reach state which doesn't make sense and again let's relate this to the big picture ideas we don't care about the actual elements we use to reach a certain sum so we can discard that information all that matters is that we got the sum and that we made our decisions about a specific number of elements so we don't process any combination of sum and number of elements more than once because we don't need to we're processing every state exactly once another thing this is another kind of trick that you might want to use you can convert basically any 2d dp problem into a grid problem like for example in this problem you can simulate your actions as moving in an n times t plus 1 grid taking an element x is moving down a row in x columns right and not taking an element is just moving down a row as you can see by these arrows now your task is just to see if it's possible to hit the bottom right cell similar to our grid problem except now it's just asking if it's possible and this isn't that revolutionary revolutionary of an idea because this is just how you'd be representing the problem with the 2d array anyway but if this is easier for you to visualize feel free to think about other problems this way too representing it as the 2d array of states if you want an extension to this problem there are a lot of variants in knapsack i encourage you to search them up and try them for yourself and here's the third problem it'll be quicker than the other ones it's the same grid problem except this time you can move in all four directions and you have to visit each cell exactly once that is no cell can be revisited and no cell can be unvisited your task is still to count the number of valid paths from top left to bottom right except you have these extra restrictions as usual spend some time and try to solve it okay and yeah i'll show you these questions if you want but yeah okay hopefully you didn't spend too much time and the reason being it's not actually solvable with dp i figured it's a good idea to make you spend time on a problem where it's not possible because it's good to build intuition on when dp does and doesn't work as i mentioned earlier you should also you should be trying to build that radar up as soon as possible so let's think about why it doesn't work in the original grid problem we can compress paths with the same ending point because it doesn't matter how we got there this is because there's no restriction on how we can move that's based on our previous moves our previous moves don't matter in determining how we can move in the future but in this problem our past moves do matter because we have to visit each cell exactly once so we can't just represent this path by its ending cell because we need all the information about our path to determine how we can make our next move so dp doesn't work here and the solution is actually just basically just optimized backtracking there's not much better we can do but yeah it doesn't work because the information about our path is important this time so our big picture idea doesn't imply here because there's no unimportant information to get rid of all of the information here is important all right i'll also quickly go over the advantages of recursive dp and iterative dp i would personally recommend learning both because if you because both have their advantages but if you want one formulation to really focus on fine i'll you can practice whatever you prefer from this list so recursive is nice because it's basically just recursion with a few extra lines thrown in like the memoization lines if you already know how to solve problems recursively and you hopefully do if you're this far into the video then recursive dp isn't much extra work you just memoize your states and call it a day right and also unlike iterative dp you don't really have to worry about the order that you use to go through states with iterative you have to make sure that for each state you don't compute that state until you've computed the states that that state depends on that's a lot of state sorry with recursive the order takes care of itself because if you don't know something you can just recursively compute it first then head back to your current state and use that information that you just computed when you get the complex problems like dp on graphs or trees this can make it a lot simpler as for why iterative dp is nice for one it's just faster recursive dp is slow because it makes a lot of function calls and it can't benefit from fancy compiler operat sorry fancy compiler optimizations that only work for like loops so for some problems iterative dp can be over five times faster i've done those measurements but usually it's very simple problems and usually time limit won't be an issue until you get to later problems but it's it's good to know that iterative will probably be faster and it's also more versatile for example you can do both push and pull dp with iterative but you can only do pull over with recursive and there are certain optimizations of dp that can only be done with iterative though those are mostly beyond the scope of this video and that's like mostly it for comparison in general recursive dp is good for people who are new to new to dp but familiar with recursion because it's not so different you can get the big picture pretty quickly iterative dp is kind of a different style and it requires more work to use but it's more powerful and more versatile so it's also necessary to learn eventually especially as you get into more advanced problems and finally here are some extensions of dp i'm not going to spend too much time on each one because i'll go into more detail in another lesson but i'll give a brief overview of the different types and some problems to demonstrate how they work first a very general version is quote unquote reconstruction dp this is not an official name by any means and it just means dp where you have to reconstruct the answer for example in the knapsack it means you'd have to output the entire valid subset of values you'd have to output your chosen elements not just whether it's possible to reach the target sum and the way this is usually handled is by storing the choice you made at each state to make it possible or to reach that state for example for the knapsack you would store not only whether that state is possible but also whether you took the last element or not you would store the choice you made about that element and that way you can go element by element and you can go backwards through your states and figure out your choices for the whole array meaning you can reproduce the array that you chose another thing is dp on trees this can involve problems like of all paths that go through the root of the tree you want the one with the maximum sum of values just an example problem i'm not going to discuss the solution here you can also have dp on directed acyclic graphs for example you can be given a dag and asked to find the longest path on it that's a pretty common one there's stuff like digit dp for example you can count the number of numbers between some l and some r that have each digit appear an odd number of times there are other optimizations specifically you can optimize the db transitions you can use for example a segmentary of the convex hull trick i have a video on these two tricks specifically so i will just link that one and there are also other optimizations like divide and conquer and the neuth optimization which i'm not going to really talk about here because i don't know them moving on if you want more problems to practice on just check out the website in the description it'll have a sizeable list of extra problems you can try out and yeah that's it hopefully you got a good idea of how dp works and how you can start to solve problems with it the good and bad thing about dp is it's mostly just practice your skills can mostly only come from practicing it i personally like to describe it as a mindset because it's kind of just a strategy for thinking about problems in a certain way and you have to strengthen that mindset with practice and some people say it takes a while to understand but then suddenly it just clicks and you'll immediately be a god at solving dp problems or something i honestly don't remember what my own experience was with it but one thing is certain if you practice it you'll get better and one more thing in terms of this video itself i i put a lot of care into it maybe more than the chose just from these slides but i really hope this tutorial came out good like this is this is actually the second revision i wrote about i rewrote about 80 of this because it kind of just wasn't that good so hopefully this version is is good i'm i'm going to try and maintain this level of quality throughout the rest of the course and yeah i hope it'll continue to be great that's all goodbye you "
    },
    {
        "title": "Top 5 Dynamic Programming Patterns for Coding Interviews - For Beginners",
        "link": "https://www.youtube.com/watch?v=mBNrRy2_hVs",
        "transcript": "hey everyone welcome back and today let's not write some neat code because today's video is going to be a little bit different i'm going to be going over five of the most common dynamic programming patterns which are very fundamental in learning about dynamic programming and even solving some more difficult and complex dynamic programming problems and what i'm showing you right now is a google spreadsheet where i have collected the five categories that i'm going to be talking a little bit about today i have also gathered a few sample problems for each category you can see the first one that we're going to be going over is the fibonacci numbers and i have some sample problems collected and for most of the problems and categories that i'm going to be going over today i've actually already made video solutions so if you wanna you know watch a video on let's say climbing stairs which falls under the fibonacci numbers category you can go ahead and watch that video over here and if you find these videos helpful i encourage you to check out my patreon where you can consider supporting the channel if you would like to it's completely optional you do not have to but i do want to quickly thank the 21 uh patreons that i currently have thank you so much for supporting the channel now let's continue with the video so the first pattern that we're going to be going over today is the fibonacci numbers pattern so if you are unfamiliar with the fibonacci numbers basically the 0th fibonacci number you can see represented with f is the function name so f of 0 is 0 that means the 0th fibonacci number is 0. the first fibonacci number is 1 and for every fibonacci number that comes after it it's basically going to be the summation of the two previous fibonacci numbers so you can see for every n for every fibonacci number greater than or equal to two it's just going to be the summation of the two previous fibonacci numbers so fibonacci number of two is just going to be fibonacci number of zero and fibonacci number of one added together which is just going to be one in this case now if we continue so let's say our zeroth fibonacci number is zero next is one next is one and the next position we're going to be adding these two numbers together which is going to be two next we'll be adding these two numbers which is going to be 3 et cetera et cetera so why are the fibonacci numbers a dynamic programming problem why is dynamic programming useful for fibonacci numbers let's say arbitrarily we wanted to solve we wanted to get some random fibonacci numbers such as fibonacci number of six well how the heck do we compute that well a naive way to compute that is going to be with a decision tree so the decision tree as you can see is going to be a very fundamental part of dynamic programming problems if we want to compute fibonacci number of six as the as per the equation i just mentioned a second ago we can get that by computing fibonacci number of five adding it with fibonacci number of four right to get a fibonacci number we can take the two previous fibonacci numbers and of course we're going to keep continuing these this entire decision tree until we get to the base case where everything in our tree is either fibonacci number of zero which is a base case that evaluates to zero or fibonacci number of one which is also a base case which evaluates to one so you can see that this tree is going to get pretty large but you can also kind of start to see there is some repeated work going on which is the reason why we can apply dynamic programming you can see that we're trying to calculate the the fourth fibonacci number over here right so suppose we did calculate it then you know we finish this left portion of the tree then on this right portion of the tree the entire tree itself the goal of this tree is just to compute this fourth fibonacci number again so why are we doing the same thing twice so that kind of leads us to go in a different direction with dynamic programming so if we want to compute the sixth fibonacci number we can just go ahead and compute the fifth fibonacci number right and when you know as we are computing the fifth fibonacci number the fifth fibonacci number wants to compute the fourth fibonacci number right so we're going to keep going like this so as we compute the fibonacci numbers required to compute this fibonacci number we're going to end up computing all of these right of course these are our base cases right the first and zeroth fibonacci numbers are our base case right and if we want to compute this we're going to need to add these together and you know add these two previous numbers together to compute this one we're going to need to add these two together to compute this one we're going to need to add these two together etc etc right how about instead of starting at the top we start at the bottom meaning we start at the zeroth fibonacci or at the beginning right basically this is called the bottom and what i'm showing you is the bottom up dynamic programming approach so we're doing the bottom up approach but one thing i want to mention this fibonacci numbers pattern is a one-dimensional dynamic programming problem so you know you can see that we just have a single array of size n this is one dimensional that's where the fibonacci numbers dynamic programming pattern falls into and there are many problems that do fall into this pattern i've listed some of them in the spreadsheets one of the problems is climbing stairs which is pretty much exactly this fibonacci numbers problem and i think that that video i've made a video on the climbing stairs dynamic programming problem i think that will give you a very like in-depth explanation of this style of problem i'm just quickly going over a little bit about this pattern right now but i recommend watching those in-depth videos if you want to get a more deeper understanding but with the bottom-up approach instead of starting at you know fibonacci number of six how about we start over here these two are already computed if we want to compute the second fibonacci number we just take these two add them together put them over here right if we want to compute the third we take these two add them together put them over here and we can keep doing that you know just like this until we finally get to the sixth fibonacci number right and one thing you might notice about this particular pattern right we're only maintaining like for example to compute this we just need to know the two previous results right to compute this we just need to know the two previous results so one thing is you know even though our our dynamic programming this is a one-dimensional n you know size of n problem we don't actually have to have this entire thing in memory we can just maintain the last two fibonacci numbers use these two to compute this one and then we don't have to store this one in memory anymore right we only have to store these two in memory to compute this next one and then again we can remove this from memory just store these two to compute the next one etc etc so that's a little bit about this type of dynamic programming problem so now let's get into a couple more complex ones so the next pattern i'm going to be talking about is the zero one knapsack pattern and you can see we have a couple example problems on leak code one of them that i've solved and have a video solution for is the partition equal subset sum problem so the zero one knapsack problem the name comes from you know this whole zero one comes from so we're given some you know quantity of things available to us in this example let's say we're given some coins and we want to use these coins to sum to some particular target in this case you know we could ask you know what's the minimum number of coins required to reach the target we could ask something like that but the most simple thing is is it possible from using these coins is it possible for us to ever sum up to this target that's the most simple question so that's what i'm going to be talking a little bit about now if you want to get a more in-depth explanation of this pattern i recommend watching my video explanation for this particular category in the spreadsheet that i linked but so the zero one comes from the fact that from this available set to us we can use each of these coins either zero times or we can use it one time we can't use it an infinite number of times we have a fixed quantity of these coins we can use each one zero or one times for us to possibly sum up to the target now if for each of these coins we can use it zero or once how many different possible combinations could we have with these available coins well for each one if we can use it or not use it that's two options right for each coin so that's two times two times two whatever the size of the input array is going to be the number of ways we could do it is two to the power of n now that's not very efficient so how can we use dynamic programming to speed this up well remember our initial target is five so let's ask ourselves how can we get a sub problem out of that right because after all dynamic programming is all about getting sub problems well if our target is five we can use each of these coins once let's suppose we start at the sub problem five which we want to know if we can sum up to five well suppose we use the first coin then what does our sub problem become if we use the first coin one our sub problem is then four right we wanna know can we sum up to four only thing is we are not allowed to use this first coin anymore what or let's say we skip the zero the one right let's say we don't use the one at all then we want to use the coin two then the sub problem becomes we use the two and then we're left with a sum of three right we want to target to and we want our sum to end up being three we already used the two coin now we have the three coin available to us right we skipped the first coin or another branch is we use that third coin in which case you know we use the third coin then we have a sum left of two that's what we're trying to target up to so that's kind of how we would get the sub problem with this zero one knapsack right when you actually break it down like this it's not too difficult now the question is you know we're drawing this brute force decision tree how can we actually speed it up now this is going to be a little bit more complex than the one-dimensional dynamic programming solution that i showed you the dimensions of this are going to be a little different right let's think about it what are the dimensions we can see that we have some target sum that's going to be available at any given point right the biggest it could possibly be is 5 because all our coins are going to be positive right we want to know can we sum up to five every time we add a coin we're going to be decreasing the target sum to some smaller value now if it ever became negative like if it became negative three that's invalid right that's our base case where we're just going to return false that's an invalid case otherwise the target could be from anywhere from five to zero right so that's one dimension of our problem right of our cache or our dynamic programming grid the the size of the target is one dimension another dimension is we could use each coin one or zero times right so for each coin we want to know did we use the coin or not and actually one one step further than that at the beginning we have the entire list of coins available to us if we use the first coin then the sub problem becomes okay the target is four right and now we don't have the first coin available to us we only have the first two coins or if we skip the first coin right we skip it we don't use it our target remains five then we have the last two coins available to us so you can see that this is what the you know dynamic programming grid for this problem would look like the dimensions are a little bit more larger right this is two dimensional this is more complex than the fibonacci numbers problem obviously but the the idea is still similar we are using the idea of sub problem so here you can see we have two dimensions one for the all the possible target values we could have and one for all the possible coins we could use and this is our base case right if we had a target of zero we return true right because we want to know can we sum up to the target right and every time we use a coin we're basically subtracting it from the target amount so if we ever got to a target of zero we're basically going to return true right because it's always possible to sum up to the target zero and so ultimately we want to know what value would go in this position because this position represents can we sum up to the target value and it represents that we are allowed to use all possible coins this position similarly is also summing up to the target five but this position tells us we're only allowed to use the available coins two and three so here we can use any of the coins now if we want to know if the the value in here is true what positions are we gonna go to next suppose we use the coin one in that case we're gonna be looking what value goes in this square why are we looking in this square because if we use the coin one the other sum the target that we're looking for is then four and we go down a notch because then after we use the coin one we only have two and three available to us which is why we're looking diagonally in this position if we do not use the coin one if we skip the coin one then we're just going to look directly below because we still need to sum up to the target five but we we decided to skip the the one coin and then we only want to use two and three which are also available to us so this is kind of how the zero one knapsack problem works out there are many variations of this problem but this is kind of the main idea now the next dynamic programming pattern i want to talk about is very similar to the one that we just went over the unbounded knapsack and one problem that i've solved for this category is the coin change problem a very famous problem and you can watch that explanation here for a more detailed explanation of this unbounded knapsack category so the difference between the zero one knapsack and the unbounded knapsack is pretty much in the name this is unbounded what is that unbounded refer to it basically means let's say you know these coins that are available to us instead of choosing each coin zero times or one time we are allowed to use each coin an infinite number of times right that's that's what unbounded means but the goal let's say for this problem at least is still the same we still want to sum up to this target value and i left the grid here because we can actually reuse this exact grid for the unbounded problem as well so as you can see you know the unbounded and zero one knapsack problems are very similar if they can be solved with the same grid this is also a two dimensional dynamic programming problem now when we had the zero one knapsack it was possible to sum up to this target five right if you just take two and three use each of these values once we can sum up to target five but with the unbounded knapsack there are multiple ways to do it right we can take one plus one plus one plus plus two right we can do it this way because it's unbounded right we can choose this one value three times and choose the two value once now this is obviously a pretty simple example but there are more complex examples but what's the difference with this unbounded and the zero one basically the way that our grid is gonna work right let's just go through an example so similarly in this position we're asking can we sum up to the target five with all three coins available to us so if we wanna know if this value is true how are we going to decide it well if we decide to use the the one coin instead of going diagonally down right we can go straight to the right why are we going in this position well obviously if we use a one coin then we want to know can we sum up to the value four but we're going to this right position because just because we used a one coin doesn't mean we can't use it again right so when we're in this position we can use any of the coins that we want now just because we have an infinite number of ones doesn't mean we're required to use a one right so we can also go straight down because if we go straight down that means we didn't use a one coin so we still want to sum up to five but now we're just going to decide to skip one right we don't have to use it we're not going to use it we're just going to use the other two coins so basically the way the unbounded knapsack is basically you know the the directions that we're going to look in in this two-dimensional grid right so for every every point like if we're trying to get the value that goes here we can choose to go right or we can choose to go down and so obviously you know the value we're looking for is what goes in this position because with all three possible coins available we wanna can we sum up to five but the way we would actually compute the values in this grid is bottom up right instead of computing this first we'd want to start down here because as you can see you know every any particular value like this one depends on the bottom and depends on the right so we're going to compute this from the bottom going left you know starting at the bottom going left and then going up right this is called bottom up because then if we if we do it in this direction right and then we start here we do all these values now let's say we've computed all of this and all of this then when we want to know the value that goes here we can just look straight down it'll already be computed down here or we can look straight to the right it'll already be computed over here and then we'll know the answer that goes in this position and for a more detailed explanation you can always watch my coin change video and the next category we're going to be going over is the longest common subsequence category there are many different dynamic programming problems related to subsequences and i think lcs this longest common subsequence problem is a good start to understand some of these i've listed four down here but of course there are many others you can see up here actually this maximum alternating subsequence sum i put this in the fibonacci numbers category but it also falls in this lcs category as well and you can see down here longest palindromic subsequence that actually also falls into this fourth category you can see that these categories they're not very rigid right there there's definitely some overlap between the problems you know it's hard to categorize this problem maximum alternating subsequence whether it's a fibonacci numbers or a longest common subsequence category that's why i think kind of understanding these five gives you a very good foundation to tackle more complex dynamic programming problems such as this longest palindromic subsequence which really takes a lot of knowledge it takes knowledge from this fifth category and from this fourth category just to adequately solve this problem i think right now let me explain to you a little bit about this longest common subsequence category i've actually already solved the longest common subsequence problem on this channel so i'll give a high level explanation of this category but basically it has to do with how subsequences work so for example if we have a string such as a b c a sub sequence of the string is basically a non-contiguous uh element of the orderings right it's basically the similar idea that we did with the coin change problem for each character we can choose whether we want to include this character or not in the subsequence the order does matter so for example if we decide to to include this a we don't want to include the b but we do want to include the c the order matters so if we got a subsequence like this we have a subsequence of a c right we have to put them in this order because that's the order that the characters occurred in the original and so the main idea of this type of problem is basically if you want to know you know all the subsequences for a string like this we could get all the subsequence for the substring or the remaining portion of the string not including the a right we could get all subsequences like this and then you know once we've done all of that that's like our sub problem then we want to get to the a and once we get to the a for any of the subsequences over here we can decide okay can we include the a or not include the a right that's a zero one decision similar to the knapsack problem but the longest common subsequence actually refers to taking two different strings so for example if we had abc and the string ace then we want to know what's the longest common subsequence between these two strings and the way that's going to work is we're going to compare character by character we're going to start at the beginning we're going to see okay if these characters are equal if they are equal that's good right then the sub problem becomes okay we saw that you know these two characters were equal now we're going to compare the remaining portion of the strings right we're going to find the longest common subsequence between these two that's what the sub problem is going to be in this type of category but if the characters are not equal so in this case we can see bc and ce the for the first characters in this case b and c are not equal so then what's the sub problem going to be in that case well we're going to have two different sub problems in that case right since the first characters are not equal we're going to have a branch we're going to have two decisions we're either going to find the longest common subsequence we're basically going to skip the b character right we're going to decide to just skip it in which case we would want to find the longest common subsequence between these two strings c and c e or we would decide to skip this character this c in which case we'd want to find the lcs between bc and between e so that's kind of how it would work and as you can see we could potentially split in every single case now in the since this is going to be a two dimensional dynamic programming problem what is the grid going to look like for this problem well as you can see this is also going to be a two dimensional dynamic programming problem we could compare any position of the first string abc to any position of the second string ace right so we're just going to take the dimensions of the two strings and multiply them together to get this grid now as you can see the base cases are going to be well the good base case is going to be if we reached the end of string two right the end of this string and we reach the end of this string in which case we'll just return zero right what's the longest common subsequence between empty strings it's just going to be an empty string itself right now what if we reached any of these x's basically we're asking what's the lcs between a string like e and an empty string right there is no longest common subsequence so this is a wrong base case similarly to this position a c and an empty string and that's also not a valid base case now so how are we going to actually compute so this this target value is what we're looking for this top left corner that's what we're looking for similarly to the other two dimensional problems that we went over right so you might be noticing a pattern this top left corner is usually the target value we're looking for because we're comparing the beginning of ace to the beginning of abc right we want to know are the entire what's the long what's the lcs between the entire strings now in this case since a is equal to a where are we going to be going well in that case we want to compare ce to bc right so in that case we're going to be going diagonally down right we don't have to go here and we don't have to go here we just have to go diagonally right now we're comparing c with b these are not equal right so we can't go diagonal when they're not equal then we want to know okay what's the lcs between ce and c in that case we go right or we want to know what's the lcs between bc and this string just e right we're not looking at this character anymore in that case we want to go down so you can see for any particular position you know any position in the grid we're either going to be going diagonal or we're going to be going down and we're going to be going right so in this case similarly to the other one it would if we want to know the value that goes in the top left corner it might be helpful it might be beneficial to start at the bottom right keep going keep going keep going keep going and then finally one once we've done all of these it'll be easy to compute this value because either we're going to be going diagonally in which case we'll already have that computed or we'll be going to the right and we'll be going bottom which will already have those values computed as well so this is also the bottom up approach a two dimensional dynamic programming problem okay so the last category that i'm going to be going over today is the palindromes dynamic programming category as you might know though there are definitely categories that fall outside of these there are definitely problems that don't fit in nicely to any of these five categories that i mentioned of course there are many types of dynamic programming problems out there and as you can tell you know some of the problems i've even listed happen to actually fall into multiple categories this lps problem falls into category five and category four this problem up here falls into category one and category four so i'd highly encourage you to you know list out some more categories that you'd like me to go over in the future in the comments if you'd like now there are many things i could talk about when talking about palindromes but what i'm going to mainly focus on is how palindromes relate to dynamic programming and specifically i'm going to be showing you a little trick with palindromes that happens to be required to solve a lot of these types of problems efficiently so suppose we're given a string like this one how can we use dynamic programming to our advantage to maybe count all of the palindromes in this entire string well let's think about it so a naive way would be something like this let's say we ended up getting to this entire string we want to know is this string a palindrome or not right we start at the beginning and we start at the end compare character by character now these two characters are not equal so we know that it's not a palindrome but in the worst case we would have to compare character by character and basically looking at the entire length of the string right so that's the worst case we'd have to go through the entire string to know if it's a palindrome right now let's say we want to know okay we're not looking at this anymore we want to look at the entire string right we add this character to our consideration we're asking is this entire string a palindrome so once again we would have to start at the beginning start at the end compare character by character in this case they are equal so we'd keep going compare character by character and basically what i'm getting at is we would have to look through the entire string once again write that entire length n eve for every single sub string that we're looking at so even if we just looked at this entire string if we add just one more character then we have to look through the entire string again because of how basically the nature of palindromes how they work is there any way that we could cut down on this type of repeated work well there happens to be one way basically we would have to change the way that we build upon our strings instead of looking at a string and then adding a character to the end of it how about we start at any given string of size one and then expand outwards for example if so if we were looking at a string like this one it's just a string of length one so we know it's a palindrome now if we want to look at a longer string let's say we want to add one character to the left and one character to the right how do we know if this new string is a palindrome are we going to start at the middle and then start expanding outward again no because we already know this middle portion happens to be a palindrome all we have to do is now compare the new left character and the new right character they happen to be equal so we know that this new string is also a palindrome we did that in an o of one operation it makes sense when you look at a small string but even for a big string it would work the same right if we knew already that this string is a palinder on this big string if we just add the left character and add the right character we already know this is a palindrome so if we add a new character to the left a new character to the right now we can check in o of one in constant time that this new string is also a palindrome because we only have to compare this new left character and this new right character now one detail to mention is the way i showed you is only going to get uh get us odd length palindromes right because we start with one and we keep adding two characters so we're always going to have odd length palindromes if you do want to check even length palindromes you can do the same you can just start with two characters like this are they equal e and c are not equal so of course since these are not equal if we expand outward to the left and right none of the new strings are going to be palindromes either so we don't even have to check those so that's kind of the main idea that i wanted to go over with palindromes it might seem pretty simple once you know it it actually is pretty simple but you would be surprised how many problems require this particular trick that i just showed you to be able to solve them efficiently i have at least three of them listed in that spreadsheet and i'm sure there are many more so i hope you found this video helpful if you did please like and subscribe and if you do want to take a look at these problems this spreadsheet will be linked in the description i do have solutions for most of the problems that i listed and i do have a problem link for pretty much all of these problems if you find any more on leak code that you feel fit into any of these categories feel free to suggest them in the comments i'm sure many people including myself would find that helpful and if you enjoyed this new style of video please let me know and if you have any suggestions for future types of videos also please leave that in the comments below i enjoyed making this video i hope you all found it helpful thanks for watching and i hope to see you again soon "
    },
    {
        "title": "Dynamic Programming with Java \u2013 Learn to Solve Algorithmic Problems & Coding Challenges",
        "link": "https://www.youtube.com/watch?v=oFkDldu3C_4",
        "transcript": "dynamic programming is a method for solving complex Problems by breaking them down into simpler overlapping sub problems and storing solutions to these sub problems to avoid redundant computations it can help you solve complex programming problems such as those often seen in programming interview questions about data structures and algorithms Alvin zablin teaches this course about dynamic programming in Java he has multiple super popular algorithm courses and he is a great teacher hey programmers Alvin from structure here Welcome to our course on dynamic programming in Java this is one of the most highly requested topics from free code Camp students so I'm super excited to explore this material with you in Java so if you're looking for a really thorough exploration of dynamic programming exclusively in Java you're in the right place of course that means all of our code specific walkthroughs are going to be in the Java programming language as for the format of this course we're going to build our dynamic programming knowledge by exploring a sequence of problems the problems are going to start simple but it's really going to give us the foundation we need to eventually solve some very tough dynamic programming problems in this very course for every problem we work through we're going to solve it using two steps the first thing we're going to do is head to my whiteboard where we'll come up with a strategy and really try to visualize the dynamic programming nature Behind these problems so after we draw things out on the Whiteboard and get a really confident understanding of the structure behind a particular problem then we're going to head into my editor where we're actually going to code up a Java specific solution alright so that's enough introduction for now what I want to do is hop into our very for section on our exploration of dynamic programming we're going to work through and frame our Fibonacci problem through our dynamic programming lens hey programmers Alvin here right now I want to work through this FIB problem of course we're referring to the classic Fibonacci Sequence this is a really really important you know computer science problem and to me it serves as the foundation to really unlocking a few harder Concepts down the line so even if you've done this FIB problem before it helps to review it together right now we're gonna see this core pattern uh show up a lot during the course together and so let's start by understanding what we should do in this problem well we know that the Fibonacci sequence has a few certain seed values we say that the first number of the sequence is zero and the second number of the sequence is one and then to generate further numbers of the sequence we just take the sum of the previous two in other words I can take zero plus one and that gives me the next number one right so the sequence starts zero one one then from there I continue this pattern right I can take the one plus one that gives me two I can take the one plus two and of course that gives me three and so on so forth and of course I can generate uh the sequence of infinite length in this way and so overall in this rendition of Fibonacci what we want to do is actually return the number at the specified index of the sequence right and so a really key insight about the Fibonacci sequence is to generate any particular number of the sequence we must know some other numbers of the sequence right I can get eight by just doing the previous three plus five if I wanted to actually formalize this problem a little bit better what we'll have to do is understand that these numbers I have listed are really the elements of the sequence and of course I can assign some indices to those elements so up top I'll just label these increasing by one of course but starting at zero so I can say something like hey the zeroth number of the sequence is zero and the first number of the sequence is one and also the second number of the sequence is one and so on and so forth so kind of jumping ahead a little bit if I look at this particular position what I see is all right it seems to be that the seventh number of the Fibonacci sequence is exactly 13. that's going to be overall the shape of this problem all right so how can we go about solving this one and so for this particular approach what I want us to do is actually work through this one recursively I think the iterative solution is pretty straightforward but I'm going to force us to solve this one recursively because it's going to help us I'll learn some new topics along the way so we'll kind of stick to a recursive mindset and if you hate recursion you know too bad he'll learn to love it right now and so looking at a particular example let's say I wanted to figure out how I can come up with the solution for FIB of six in other words the sixth Fibonacci number is exactly eight and so what I can start to do is figure out how to break down this problem I know in general to generate the sixth number of the sequence I can take the fifth number and add that to the fourth number right it's exactly the rule of the Fibonacci sequence let me try to visualize this one a little bit better so I'll represent uh the problem FIB of six using somewhat of a tree and I'll represent an instance of the problem as a note of this tree so I have my top level problem of six that'll be the root of this tree and this is a really important way to actually visualize recursion because it really shows us how we're going to utilize our return values and reconstruct our final answer so if this is a new pattern for you don't worry we'll walk through it pretty slowly together and so now that I have this root of six I have to figure out how do I break down this problem well like we just said to solve above six what I need to do is break that down into fibbo five so that'll appear as a child of that sixth node in the same way for before also needs to be solved to solve our main problem over here and notice how I have these you know children nodes of course below the FIB of six right as I go downward in this tree I should be getting smaller and smaller numbers in blue right that would represent a smaller problem because I know once I have a small enough input in blue then I would have somewhat of a base case kind of inherent the Fibonacci sequence so let's take a closer look at this five note over here right this node represents the problem of FIB of five right what is the fifth number of the sequence and I know in general my pattern is all right if I want to calculate FIB of n then I take the sum of N minus 1 and N minus two so I'm just going to apply that pattern to this five node in other words on fives left it's going to have a node of four and a five is right it's going to have a note of three right doing a minus one and minus two respectively and it's a similar trend for the four node on the right hand side over here right it's going to have two children of course doing -1 on the left and minus two on the right giving three and two respectively so let's keep applying this pattern we're going to do is fill out the next level of the tree until we can't fill it out anymore we have to notice here is when it comes to actually building on the full tree we have to stop at certain nodes in other words once I have an instance like zero as my input to this little sub problem I can actually shrink that problem size any further let's all highlight all of these nodes whose input is zero right that represents the zeroth number of the Fibonacci sequence and something inherent in the problem is I can't really break that problem down any further I know that for those particular nodes they ought to return zero right because a zero number of the Fibonacci sequence is exactly zero so in green I'm going to represent the result or the answer to those sub problems right I'm going to put their answers above the problem itself right so I'm trying to be very very particular in my drawing I'm always going to write a return value above a node here and I have a similar case for all of my nodes who have an input of one those are also a base case right because the first number of the Fibonacci sequence is exactly one so we'll also fill in those ones above cool now that I have some floating return values I can start to reconstruct my larger problems at hand so let's stay focused on the left hand side of my tree let's look at this particular node so I'm looking at this node of two and I have a left hand value and a right hand value are ready to compute I know that if I look at this this node of 2 it's trying to figure out what's the second number of the Fibonacci sequence and so at this node of 2 in blue what I can do is just take the sum of its children right of those green values so 1 plus 0 gives me one and if I do a quick Sandy check that must mean that the second number of the Fibonacci sequence is exactly one and this pattern continues up the tree right at this node of three I take the sum of the one plus one and I get two if I do a quick Sandy check that must mean the third number of the Fibonacci sequence is two what we're doing right now is really stepping through how a recursive code would actually return right return means return to your caller right so return to your parent node and so I'll fill in the rest of the values over here and bear in mind you know as you kind of uh draw out these diagrams maybe for yourself hopefully on pen and paper or even on a whiteboard it's really important at least for me that you check for correctness as you build the tree so if you're in an interview it really helps to not just check for your top level answer being correct but at any points of your Trace you should have logical information in other words by just looking at this node right I have a blue note of three over here whose return value is two that logically implies that the third Fibonacci number is two and that's totally correct so I'm good to go for now right it would really be a drag if I kind of sketch through this entire drawing only to realize I had a little like typo or miscalculation somewhere Below in the tree so I highly recommend that you stay very aware of your sub results as you kind of Trace through a diagram like this so let's continue to build up these sub Solutions so I know that this node of 2 is going to take the sum of one plus zero that gives me one and finally at the parent of four it's also going to take the sum so two plus one is three and that must mean that the fourth of a notch a number is of course three so let's speed this up a little bit for every other uh node in the tree so we're gonna add all these up so on and so forth now at the tippy top we see that this note of six at the root is going to take the sum of five and three and of course that gives me eight which is exactly the punch line right the sixth Fibonacci number is indeed eight and so looking at this pretty large tree you might realize that hey you know our top level problem was asking for the sixth Fibonacci number not a very large number in the sequence however we have to use a lot of nodes to actually represent that problem how we broke it down that's something really important about this Fibonacci Sequence right it has a pretty interesting complexity a pretty large one at that so let's try to analyze the complexity of this we know that every node of this like visual tree represents a recursive call right and so the number of recursive calls I make over here or the number of nodes of the tree should roughly represent the time complexity of this solution you're probably already recognizing that it's going to be a very very large one let's go step by step over here and so to analyze the complexity of recursion like this I think it's really important to notice any patterns in the tree to me it's all about looking in the tree right I can kind of figure out at least the ballpark of the type complexity without even writing the code right just using this visual and so at first glance you might notice that this one is pretty hard to analyze because the tree is asymmetric in other words notice that it's a little taller or deeper on the left hand side then toward the right hand side of the tree it's actually much more shallow and that kind of asymmetry makes us feel a little uncomfortable when it comes to figuring out any patterns so here's what we'll do let's actually try to analyze this one by drawing an analogy so let's ignore this exact Fibonacci tree right now and go for a more symmetric example so let's say I had a similar recursive code that had a more symmetric recursion so let's say I had some top level call with a value of four and let's say that this top level call to four I actually made two more recursive calls but both on a minus one in other words the left child is the same as the right child which is different from our classic Fibonacci right Fibonacci our left was minus one and our right was minus two but now I'm just doing minus one on both sides if I continue that pattern that should give me a nice symmetric tree let's say I had some base case roughly when my value is one so I can stop building the tree from here and so this has a nice symmetry to it let's try to notice any patterns now if I look at the different levels of this tree let me look at how many nodes there are across a level so for example my very very top level and there's one note on that level on the next level there's two nodes and then four nodes and then eight nodes you can probably see how this pattern scales right if I drew more of this tree let's say I had a farther a base case it would be 16 nodes and then 32 nodes and so on and so you probably realize the obvious pattern here right the very top at the root of my you know recursive tree I have one note or one call and then from one level to the next I doubled I multiply by two right and I do this process basically for every level of this tree so that begs the question you know how many levels are there in this tree well just looking at this kind of particular concrete example there's definitely about four levels right and I can kind of understand uh how to designate each level by just looking along this left-hand path right so colored in yellow notice that I have four three two one that's just a decreasing pattern so when it comes to the number of levels it's pretty obvious to me that it's exactly n levels right if my top level problem at the root is where n equals four then I have you know four levels or in general n levels so it's pretty clear to me that when it comes to figuring out the total number of nodes in this tree which implies the total number of recursive calls we make for this kind of toy problem it looks like I would multiply two by itself n times over which is a definition of an exponential 2 to the nth power cool so maybe you're a little bit skeptical and here's where we can either you know really buy into kind of the Big O complexity or we can get bogged down by the finer details something that you might fall into sometimes but you have to kind of be very aware of it is Big O is really just an estimate so if you actually plug in some values here you might notice all right if I did 2 to the fourth power right because 4 is my n in this particular example that would be 16. and so if we actually counted the quantity of nodes in this visual tree it would not be exactly 16. I'll label them over here starting at one there's actually going to be 15 nodes so it's off a little bit but if we you know understand Big O complexity we know that if we have something that's of the shape of like 2 to the N minus 1 we can ignore the minus one what's more is even if it was off by like five right if it's a minus five that's still a constant that we're subtracting that still is dropped from the Big O notation so overall I would consider this particular example as having o of the 2 to the N Run time which would be exponential pretty pretty slow right so while we're here looking at this symmetric example before we hop back into FIB let's try to recognize what the space complexity is we know how the space complexity for recursive code is going to be more or less the number of Stack frames that we use right for our recursion because whenever we make a recursive call that information has to be stored on the call stack right so we kind of make different function calls and also return from function calls and so this is actually something I notice students have quite a difficult time uh analyzing and so what I'm going to do is really Trace through how we would make these recursive calls as well as how to visualize the call stack right so this top level call of four that would be added to the stack all right so stack will be just a little a little rectangular block right and then as I make recursive calls let's say now I call upon three that's my input that's also added to the stack notice that it's added on top of the four right and really we have to recognize here is every time we make a call we're adding a new stack frame and we only get to remove something from the call stack when it returns so so far none of my calls have returned right until I have one at the top of my stack right at this point I've kind of bottomed out at like a base case so I can return from that call which also means I remove it from the stack at this point I need to evaluate two's right child so I make another call to one and this process continues right now I'm done with both of twos call so it can return now I'm back at three but three has to call upon it's right and the same thing happens well you'll notice that at this point is although there are many you know different stack frames we would have to eventually push onto the call stack at any point in time there's only about a four different stack frames on the call stack right it's not as if that we store like all of these different stack frames simultaneously right it doesn't really make any sense to add certain stack frames you must have returned from other ones so it's actually the case that the space complexity due to the call stack would just be o of n overall we're looking at an exponential runtime and a linear space complexity alright so for this particular symmetric example it has an exponential runtime and a linear space complexity but how about for our actual Fibonacci tree we know our Fibonacci tree is more lopsided it's roughly going to be like half the size of that and you can take my word for it it would actually be the same Big O complexity right still 2 to the n and then just an O of n space complexity and so kind of taking a lay the land over here the space complexity seems reasonable right however whenever we have an exponential usually that's not good enough and there is actually a better or faster way to solve this one recursively which is what I want to expose this to uh right now so let's go back to the recursion tree for our FIB problem right and so what we can do is try to recognize any patterns within this tree do you notice any duplicate work right this is all about understanding you know what this diagram represents right every node I have drawn in here with its corresponding number represents a problem as you can see I have many duplicate problems so for example if I look at this subtree that sub tree represents a sub problem right rooted in four so I'm asking for the fourth Fibonacci number not only do I need to calculate that on the left hand side of the tree but at some other point down the line on the right hand side I need to calculate that same exact sub problem right these two subtrees are identical and they both represent the same problem the fourth Fibonacci number and this pattern actually applies recursively because the strategy is recursive right so you can notice probably some other different duplicate sub problems right if I root myself at three I have to calculate this sub tree three different times right and notice that that three subtree is also internal uh to the fit before so it's a really a really duplicate and there are a few other duplicate sub trees you can recognize over here so we have a lot of duplicate work in this kind of Brute Force recursion and if we actually store some sub results then we can forego having to recalculate any of these subtrees down the line and so really what we're looking to do is kind of prune out some branches of this tree to avoid some duplication so what I'm going to do is kind of ignore this right hand tree of four so I'm going to take that out because I would have calculated it on the left hand side somewhere I'll do the same thing for this kind of middle tree of three so I can ignore that as well cool likewise for this too and so at this point we don't really have any full duplicate sub trees right I kind of took them out of my drawing so if we actually store some results as we calculate these sub problems this really represents all of the recursive calls that we'll have to make right and so you're wondering how can I actually Implement you know that kind of pattern in my code well it's all about just storing some additional information so let's step through still FIB of six so I want the six Fibonacci number in the long run we should get eight and the strategy I'm introducing right now is called memoization and so when it comes to implementing memoization in your language of choice it's all about storing some additional data in a memo and your memo is typically going to be your like hashed data structure so it could be like a hash map or a dictionary or object depending on your weapon of choice here right it's really important that I choose some data structure that gives me an O of one lookup time right so usually that would be your hashed data structures whatever that is in your particular language and so let's step through this one again but now we're going to store some data inside of our memo so we have the same base cases as before right we know that the first Fibonacci number is one and the zero Fibonacci number is zero and when these values return to the parent of two we're still going to calculate the sum over here so 1 plus 0 is just one but now that I have this result I can store it in the memo so I'm going to make the key represent the input to that node or that recursive call and then its value is going to be that return value and so if I look inside of my memo it's a reminder that the second Fibonacci number is one so we'll continue this process I know that I have a basically server here still the case that the first Fibonacci number is one and I return to the parent I calculate that hey the third Fibonacci number is two and I'm going to store that in my memo as well and here's where things get a little more interesting if I look at this node of 2 over here I've actually calculated uh this sub problem before right I can check that by just looking inside of my memo my memo says Hey the second Fibonacci number is one so without having to recurse and build the full subtree once again I'll just go ahead and fetch on the stored value in my memo so I'm just going to jot down a one above this node of two I'm not going to return to my parent and I figure out that hey the fourth Fibonacci number is three and of course I want to be sure to return that but also store it in my memo for the future and same thing happens at this three note right this three note is again in my memo so without you know re-cursing through my tree I'm going to just fetch that value from my memo I already know that hey the third Fibonacci number is two and so I can calculate the value at my parent right fifth for Notch number is five be sure to store that in your memo and so on and so forth by the time we get to the very top of our tree of course we have the fact that the six Fibonacci number is indeed eight and I avoided a lot of the duplicate recursive calls so it's clear to me that we avoid a lot of duplicate work what exactly is the run time now right and so we'll try to notice uh some patterns so this visual tree represents our Fibonacci recursion after we implement this memoization strategy right I'll try to generalize it over here so I'll kind of tidy up these edges over here and let's say I increased the size of this problem so instead of FIB of six what if I asked you for FIB of seven that recursion tree would look something like this right notice that the root is now seven of course and it's still the case that the left child is -1 so a six and the right child of the seven is a minus two or a five right still being the rules of Fibonacci and I only added two more nodes if I increase the problem size to FIB of eight I would still add two more nodes so every time I increase my input by one I only add two nodes it's always adding a constant number of nodes at this point our problem scales linearly right in general we're going to notice that we have basically two times n nodes and notice that that's not 2 to the N where I'm saying 2 times n and so we can simplify that to a runtime of O of N and the space complexity is still the same right notice that the space complexity for this algorithm is really just going to be the height of the visual tree it still looks like a linear chain right if I go along the left-hand path it just goes eight seven six five four and so on so definitely an O of n space complexity and this is actually a pretty efficient solution for our Fibonacci and so I think from this point let's go ahead and implement this in some code now we can have this core pattern under our belts so I highly recommend that you try to implement this one in some code on your own but don't forget we also have the video walkthrough available if you get stuck or just want to code along now that we're done sketching out a strategy for this problem on the Whiteboard what you want to do is follow the link in the description for this FIB problem so you can follow along and code up our solution in Java with me hey programmers Alvin here what I want to do right now is go over the Java walkthrough for this FIB problem this is going to be our very first problem in the dynamic programming section now I am going to teach you to solve dynamic programming problems is using recursion plus memoization so we're going to start just by warming up here and solving this Fibonacci problem uh using recursion and then we're going to apply our memoization strategy on top of it and this is going to be a really great strategy that can scale to a lot of different dynamic programming problems obviously you might be thinking that you could solve a Fibonacci using some you know pretty classic iterative code and you definitely can however I'm going to show you how to solve this recursively with memorization because it's really going to set you up for harder problems later on so let's Jump Right In when it comes to setting up the recursive code here I want to start with my base cases and they tell us that the zeroth number the Fibonacci sequence is zero and the first number of the Fibonacci sequence is one so I'll turn those into base cases so I can just go ahead and check hey if n equals zero then I know I need to return zero like wise if n is equal to 1 I know I want to return one so to kind of combine those into a single base case here I can check if n equals zero or n equals one well there's return n itself right because the zeroth number of the sequence is zero and the first number of sequence is one and that'll give me my two base cases to start then from there I only need one more line of code the recursive definition of Fibonacci is to get some further a number of the sequence you just take the sum of the previous two right so I know that the previous number of the sequence would be Fibonacci of n minus one right because n represents the number I'm asking for so the number in the sequence that comes before would be n minus 1. I want to add that to Fibonacci of n minus two right so that would be the number two steps ago right take the sum of them and that would give me my current number so let's give that a test run this will be correct but it won't scale in terms of the time complexity like we said in the approach video the time complexity of this Fibonacci function although it's very short code is exponential right it's 2 to the n and so the growth of this function as we increase the input number n is very very large so you're actually going to get a timeout for this one and so to make this faster we're going to layer on a memoization strategy right and so what's really important in the way I teach monetization is we always start by solving the brute force and here I have the Brute Force right I can identify that I've correctly implemented The Brute Force when I get correct results for my method except it's slow right so it times out for some very large input for example if I take a look at the test case I'm feeling right now it would be calling Fibonacci with an N of 46 right it would give me some large value and because this has an exponential time complexity that's far too large for me to wait around for and so when it comes to creating a memoization around this Brute Force solution in Java what I usually do is create two separate methods I'll have my main method I also have my recursive helper method that also takes in a memo and so let me create another version of this method above that would be the main method and it's just gonna really call and pass control into my recursive method I'm going to overload it with an additional argument here right so FIB the recursive method is going to take in not only the integer n but my memo and for you in Java it'd be nice if you implement your memo using a fast lookup data structure right because you want to improve the runtime of this code so you want to store your sub results in a fast lookup data structure so for you that could be as simple as a hash map so I'm going to import up top Java util hashmap so I know that a hashmap has o of one insertion and ov1 lookup and I'll take in a hash mark over here and when it comes to how I design the structure of the hash map I know that the keys of my hashmap need to be input arguments to My Method here right so I know the input argument is a number or integer n so I'm going to make the key integer I make the corresponding value in the hash map the return value for my method it's going to have integer values as well I'll just call this argument memo so that means when I in my main function call my recursive method here I'll pass in the original n but I'll give it a new hash map nice I could just return whatever the recursive method returns so do bear in mind that this circus of method now line 9 is taking in my original argument n as well as this memo hashmap right and this memo hashmap is going to be shared for the entire recursion right so what I need to be sure to do is I'm taking in the memo that's an argument here when I call recursively on FIB I want to pass along the same memo right you're passing it by reference so you can have all of your recursive calls share the same memo object right think of it as if when you visualize like the recursion tree like we did in our approach video you want all of your nodes in the tree to refer to the same memo awesome so that's just me adding an additional argument into FIB but now I actually want to use that memo object and so what you should do is check if your argument is already a key in your memo right so I'm going to check it over here it kind of acts like another base case here so I put it at the top so I'm going to check if my memo already contains key of my argument n right what I can do is then just return the stored value of that key so I can do memo dot get n obviously this only works if I you know over time store values into my memo which I'll do in a moment right so I know my memo is going to map right arguments of my method to their return values so if I find an argument in the memo that matches my current argument I'm just going to return its stored value in the memo but that means I need to be storing things over time into the memo and so now you should locate wherever you return recursively for your method so that'd be the line 19 return right those are my recursive return values right I know that line 11 is not a recursive return value because it's literally my base case right so I know that this value here I know it's really composed of you know two separate or cursive calls but I know that this will ultimately evaluate to a number right and we're turning a number here that number is like the answer so what I'll do is I'll save it in a variable I'll just call it result and you know that this result is going to be the answer for Fibonacci of n so what I want to do is in my memo before I leave I want to store using the key of n I want to make the corresponding value this result again what I'm doing here is I'm making sure my memo Maps arguments of my method to their return values I know the answer for like FIB of n is this result and what you want to be sure to do is just complete the return value like before so I just want to return result so I'm still returning the same data as before I'm just additionally storing into a memo for later on and what's great is later on you know somewhere in your recursion when you encounter an N that you've seen before I mean you know that's going to happen in this problem because we you know demoed it in the approach video when you see an input and you want to evaluate an input and that you've seen before then you'll actually hit this base case on line 14. you're going to find that that argument is already in the memo and you're just going to return the stored value inside and that happens in constant time right because I know getting you know from a hash map is constant time so with that change let's go ahead and give this a test run really important thing to remember to do is be sure to pass your memo you know to your recursive calls over here that way you get that shared information across all of your recursive calls awesome and there we have it so by implementing this memoization strategy on top of our Brute Force we really improve the time complexity of this solution right like we said in the approach video now we're looking at an O of n runtime right space complexity is also going to be o of n because we have to store all of these calls on the call stack and even if we consider the size of our memo we know that our memo is just going to have a number of entries that could be at most equal to our input n right because I'm using my input n as the keys of my hash map and I know that keys are unique all right programmers so what I want you to do is take a moment really be sure to redo this problem and understand how we solved it in two steps right first I solve just the Brute Force recursion and then I apply my memoization on top of it this is going to be a really really important pattern moving forward we're going to scale it to solve some pretty interesting and difficult uh dynamic programming problems but I always follows this core pattern of solving a Brute Force recursion then additionally adding a memo hash map to it I'll do a variation of this in the next video I'll see you there hey programmers Alvin here right now I want to show you the approach for this Fibonacci problem and so I know you're thinking you know why is he having us do basically a ripoff of Fibonacci well I think it's really important that if you want to get good at these algorithm things then you have to have a certain level of repetition as the saying goes one is none right so even though you know we've just done another Fibonacci problem doesn't mean that it's completely something that we've mastered so if anything this should be a quick little review right of course I want you to solve this tribonacci problem uh recursively and so let's take a look at the sequence so here is a few numbers of the Fibonacci sequence all you'll notice is in this particular problem like before I want you to give me back a particular number of the sequence so imagine that we had corresponding indices for each of these numbers when it comes to the tribonacci sequence we're going to have three separate base cases right the zeroth number of the sequence is zero and also the first number of the sequence is zero and the second number of the sequence is one so with those three seed values we can come up with our general rule right just like before to calculate a number of the sequence or the next number of the sequence you just take the sum of the previous three numbers right or in general to calculate trip of n you do the sum of N minus one n minus two and N minus three and there you'll have your final answer right it's kind of jumping at a particular spot within the sequence if I took the sum of 4 plus 7 plus 13 that would give me exactly 24. so you should feel red at home in this particular problem so let's start to draw this one now I don't want to skip any steps and so before we start building this one let's have some foresight and figure out how to visualize a problem like this right and what's great about visualizing it is at least if we spend some time you know sketching out you know a structure of the problem like visually it can also help us figure out the complexity of this particular problem so right now I want to step through calculating the fifth number of the sequence which should be four in the long run so like before I'm going to represent an instance of this problem just with a tree and so my top level problem will be the root of this tree I want to find a trip of five and I know that I have to break this problem down into three sub problems right in other words I can generate three children by doing a minus one minus two and minus three respectively I'm just going to carry over that pattern for as many nodes as I can and of course whenever I hit like a base case I can't break that node down any further we know that when it comes to our tribonacci problem we have three separate base cases right representing these particular return values so I'm just going to plug in these sub results so I should have all of these calculated values right zeroth number is zero first number is zero and also the second number is one now I can start reconstructing my sub Solutions right so if I take a look at the particular uh to the left the three node I take the sum of its three children one plus zero plus zero gives me one right so the third Fibonacci number is one and I'll just continue this pattern right every parent node just takes the sum of its three children return values so I get values that look like this and finally at the root I just take the sum of two plus one plus one which gives me a final answer of 4 right very similar to our classic a fib problem so this would be a working solution basically just doing the same a recursive code except we're going to have three recursive calls which makes sense because every call we make corresponds to a branch that we have in this visual tree however what's the complexity of this one it's pretty pretty slow for the same reasons our Fibonacci code was slow before right so take a look at this particular tree I can derive the time complexity of it because I know that for my recursive code the time complexity is at least going to be the number of recursive calls that I make And if every recursive call corresponds to a note of this tree I have to figure out what the long term pattern for the number of nodes is in this recursion tree so I know that the height of this tree is pretty obvious looks like it's going to be along the order of N and how do I know that well if you look along the left-hand path it just goes five four three two and in general that's roughly N Things right now just think about how many nodes are across on every level at the top level there's one node and to get to the next level I multiply it by three I continue this pattern right as a tree gets bigger and bigger from one level to the next I would continue by tripling the number of nodes right very similar to our Fibonacci problem and so you guessed it the complexity of this is 3 to the N so an exponential but with a base of three right and it is a case that our space complexity is a pretty reasonable o of n right of course we're referring to the space complexity due to the call stack right and in general we can figure out the space complexity from the call stack if we draw out the tree and we can just look at the height of the tree the height of the tree being basically the number of levels and there's roughly you know four levels here so I guess it's off by one even though our input was five right so to make this one a little faster of course we can just notice any duplicate sub problems right so same story like we're used to look at this sub tree rooted in three I have this sub tree appearing here as well and so I want to avoid resolving that sub problem we're going to use the same scratch as before but this I want to use a different word to describe it really what we're utilizing here is dynamic programming so dynamic programming is really a type of problem solving where we utilize any overlapping sub problems right in other words I have this sub problem of calculating the third tribonacci number and if I can store that information the first time I solve that problem I can utilize it later on because I'm probably going to encounter that same sub problem all right so this is in the family of a dynamic programming strategies and so far we've been working with memoization so really memoization is just one way we can Implement dynamic programming and so if we use dynamic programming wisely we should be able to forego that duplicate subtree right and overall we'd be looking at an O of n runtime and O of n space complexity if we implemented that correctly right and so to implement that of course we're going to use some hash data structure to build that memo so for my python people you're going to use like a dictionary for my JavaScript people you're going to use an object for my Java people I'm going to use a hash map right any fast lookup data structure and at this point we have a pretty optimal solution for this tribonacci sequence right it should be able to run in a pretty decent time and so with that what I want you to do is I give this code a shot on your own but don't forget if you get stuck we do have a Code walkthrough available as well so give it a go now that we're done sketching out this tribonacci problem on our whiteboard what you want to do is head down to the links in description and click on the tribonacci link that way you can follow along and code up the Java solution with me hey programmers welcome back right now I want to go over the Java walkthrough for this Fibonacci problem so it's going to be another dynamic programming problem just to kind of ease us into the core pattern that I'm trying to teach you guys in this course and that'll help you solve almost any dynamic programming problem and so this is going to be a variation Alpha Fibonacci just called Fibonacci it's really the same pattern except to generate a further number of the sequence you need to use the sum of the previous three numbers and here I'll start with my base cases right I know the Fibonacci sequence has some different seed values we see that the zeroth and first numbers are both zero right so I'm going to actually just go ahead and jump right in here I'll start with that as my base case I'm going to solve this one for now with a Brute Force recursion so I'm going to check hey if my n is zero or my n is one well the 0 and 1 elements of the sequence how about zero so I return 0 in either case then additionally I need another base case if n is two I return the number one really just arbitrary values for this sequence here so if n equals two and return the value of one those would be my two base cases when it comes to creating the recursive case here you just take the sum of the last three numbers of the sequence so for me that's as simple as I take the tribonacci of n minus one and I add that to tribonacci of n minus 2. and also add a 2 triple Notch of n minus three cool so let's give that a test run this is a really important step never ever skip it right whenever you're solving a dynamic programming problem using memorization you ought to solve it Brute Force first and verify that your code is correct for me correct means that I always get a correct result for my method right a timeout is okay right eventually if we had more time all right to use up here you would be able to pass test k07 you will get the correct answer but this code is just far too slow as it is right so now that I've verified that okay this code is just a matter of speed right it's just slow I can add memoization on top of it so just like before for you and job I think the best way to solve this one the structure of code is to overload this method and your recursive method your brute force is now going to take in a new argument it's going to be a hash map and when it comes to how I set up the keys and values keys are going to be the arguments here method here I just have a single argument n so I'll make that an integer key the corresponding return value is going to also be an integer so it's going to have integer value I like to call it memo awesome from there in my main method you just want to delegate to your recursive Helper and you should pass in you know a new hash map instance here so at the top I should import the right thing here so I'll import Java util hash map and you can pass it in inline be sure instantiated here so new hash map awesome and now when it comes to my recipe for memorization I have the Brute Force I'll start by adding a base case that checks if my key or my input argument is already in the memo so I'll add over here along my base cases I'll say if my memo contains the key of n right and if it's there that means I would have also stored the value that is the answer for that input n I'm just going to return whatever that stored answer that stored value is I'll do memo dot get and in that case awesome so I have the logic that looks into my memory like my memo fetching logic now I need my memo insertion logic right so now I need to locate my recursive return value right this is where I return the final answer for n right this would be a number technically I'm going to store it to a variable call it result and before I leave and return the result I actually want to store that result into my memo so I actually do memo dot put and you should always use the key that's your current input argument right so this result is the answer for Fibonacci of n right because I'm returning it for a call to n and so n is going to be my key here right so I'll do n I'll make the value the result a very important design choice that we make when we solve our memoization this way is we're only going to memoize our current call right so in other words all of my memo keying happens with the argument n right I check if it contains n and if it doesn't then I put a new key of N I don't write any like awkward heavy-handed logic like doing memo dot put I try to Cache like n minus 1 with some subresult right that gets very very messy right because we're solving this recursively if we handle all of the memoization for our argument n then everything else will actually be memorized as well right because you know that for this particular call when we jump in and evaluate that call recursively this n minus one Whatever actual number that is that is an n in some other frame of reference right so you're only going to want to memorize to keep your code very clean adjust your current argument n right don't try to do any of like the the sub problems with the children here awesome and one final thing to do if I actually test this it's a very common mistake it won't actually be any faster that's because these calls are Fibonacci in my recursive case they need to actually refer to my overloaded method here which takes in my memo I obviously I want to share this memo hash map for the entire recursion tree here so I'm going to add that into the mix just pass along the memo and that should do the trick awesome and there we have it hey programmers Alvin here right now let's go over the approach for this some possible problem so this probably want to take in two arguments we're going to be given a amount as well as a array filled with numbers and we want to do is return true or false indicating whether or not we can use some numbers of the array to generate the amount by adding them together in this particular example I should return true because I can totally make 5 by adding up some numbers in the array there are a few different ways to do that I could have done two plus three or three plus one plus one we're also two plus one plus two and there are actually a whole bunch of other different ways you can sum up to five but since I have at least one way to generate five I'm going to return true so overall we're just looking for a Boolean return type for a function here it could be the case that based on the inputs we're given it might not be possible so if I gave you a Target amount of 15 and I gave you numbers to choose from like 6 4 and 10 that would actually be impossible so you should return false all right so how do we start attacking this one we'll step through an example where you want to generate a Target amount of four and we have numbers one two and three this should be a sufficiently large example to step through here my intuition tells me that smaller amounts are easier to calculate late than larger amounts so what I can do is try to shrink my amount as much as possible until I get to a trivially small amount for which I know the answer for so let's say I start with my amount of four what options do I have here well if I think about my first choice what I could do is take a one so this one is going to represent the first number I can choose right and what I can do from there is actually subtract that one from the four that would give me a new amount of three but still at the four note over there what I can do is also maybe consider taking a two if I do 4 minus 2 then my next minus 2. and the final option would be taking a 3. if I do 4 minus 3 that'd give me one and at this point I'm starting to shrink my problem size so inside of the nodes in blue we're going to have listed the amount that we're trying to break down and then the numbers in yellow on the edges represent the choice of numbers that we choose we're starting to shrink our problem size so let's say we took a look at the three note on the left we can break it down further right using my options of one two and three and that would yield two one and zero respectively if I take a look at this two note over here in the middle I have to watch out because I can only use some of my numbers for valid moves right in other words I can do two minus one or two minus two and that'll give me a one and zero respectively but what I should not do is 2 minus three right although I have a third option of doing a three that would be too large right now and that would actually bring me to a negative quantity so we're gonna need to watch out for that in our drawing as well as when we implement the code similarly for this right hand note of one I can only subtract one for it because using any of the other numbers would bring me to a negative quantity so I'll continue this pattern for all of our nodes until we can't break them down any further and this would be the complete tree really what we're describing is the decision tree for all of the options that we can possibly make right so although I'm saying tree here I'm really referring to the fact that we're breaking this problem down recursively we go ahead and implement this we're not going to have to build any like tree data structure but we're going to solve it using recursion right I use this tree as a way to actually understand all the options I can take so since we know that this tree visualizes the recursion or where can we locate the base case well that would really be just the leaves of this tree what we can do is recognize that we have a bunch of zero nodes over here and to me that would be a trivially small amount that I can always know the answer for so that's going to be my base case right in other words if someone gave me an amount of zero I'm just going to return true why does that make sense well I can always generate Zero by just taking no elements of the numbers array I can always return true regardless of what numbers you give me you can even give me no numbers and that'd be totally fine I can still generate Zero by taking none of those numbers and so what I'll do is jot down this return value above all of my zero nodes those are going to be my base cases right my base case calls and I know that if I see a single true anywhere in the tree then it should be possible to generate the amount obviously here we can't really go wrong and we have a lot of different ways to generate the amounts if you look within this tree not only do you know that there are a bunch of different ways to make our amounts of four but you can actually see what numbers you added to generate that amount for example if I look at this path this represents doing a one plus two plus one to generate four right I'm just adding the numbers that I have along the edges here so this tree tells you a lot of information and you can use it to solve a bunch of different variations of this problem so now let's start to look at how the values return here so given a parent note if it receives a true from any of its children then it's also going to return true so that would evaluate something like this until we get a true at the top as our final answer so far we've described The Brute Force way to calculate the answer here I think it's worth going through the complexity so here I have two arguments to my function if we say that a is the amount and N is the length of numbers you can see that the time complexity is going to be n to the a power so this is going to be exponential so we're doing here is putting n in the base of the exponent because we know given a node it's going to give at most n children because I have to Branch for every option of number in the numbers array and I'm putting a in the exponent because I know that the height of the tree is at worse going to be a you can easily see that in this particular example if you start at the root and just keep going to the left it goes four three two one zero which would mean that the height of the tree in the worst case is exactly a if I had to keep subtracting 1 from my node so overall I'm looking at an N to the a complexity which is an exponential and typically going to be too large to actually run for reasonably large inputs we talk about the space complexity it's just going to be o of a right now based on the heights of our tree right we know the height of the visual tree would give us the maximal stack depth so how can we do better well you should probably catch the drift by now take a look at this tree and notice if you see any duplicate work what I can notice here is I have some duplicate subtrees right I can see these sub trees rooted in two that are identical and even have smaller sub trees that are the same like the ones rooted in one and I know that if I have duplicate sub trees in this visual that means I'm trying to solve duplicate problems right if someone asks me is it possible to generate two for the first time then later on if someone asks me again I should have just memorized that answer right and so here we're going to use that memoization strategy just store some solutions and some cash that way I can fetch them later on if you implemented memoization like we've seen previously then you would be able to trim out some branches of this tree ending up with this smaller structure what would this memoized complexity be well we'll still say that a is the amount and N is the length of numbers what we did was actually remove the exponential nature of this problem now we'll say that the time complexity is O of a times n so it's no longer an exponent I'm simply multiplying them right so a still represents the number of levels within my tree right the height of the tree and then n represents the width of my tree right for every level I will have at most n nodes and it would still be the case that our space complexity is O of a we would still use a a stack frames on our call stack due to the recursion and in terms of storing our memo we know that's also going to be linear in a and when it comes to the hash map we use to store our memo the space complexity for that is still going to be o of a because we're just going to use every amount every possible amount as a key of that memo before I let you go let's step through an amount that would not be possible given some numbers so we'll step through a scenario that should return false so my amount is 15 and I have numbers of 4 6 and 10. if we attack this one the same way we'll start with 15 in the root and we'll subtract each option of number giving us 11 9 and 5 and I'm going to carry this over as much as I can until I can't reduce my amount anymore so the full tree will look like this the nodes highlighted in red are the nodes that I can't break down any further because it would bring me to a negative quantity so if I have any remaining quantities in those red nodes then I know that that would mean those quantities are not possible to be generated so those should be a base case that return false now I can evaluate my returns in the same way as usual right I just bubble these up to their parents a parent is going to return true only if one of its children calls also returned true but everyone here is false so I'll get false all the way back up the tree all right programmers I think that's all I got for this approach video what you want to do is possibly give this one a shot on your own see if you can translate our visual diagrams into some code and then if you got stuck you can find me in the walkthrough videos I'll see you there now that we're done drawing up are some possible solution what you want to do is head down to the links in description below where you can find the link to the some possible problem because we're going to code up the Java solution right now together hey programmers Alvin from structure here what I want to do is go over the Java walkthrough for the some possible problem so you definitely want to make sure you watch the approach video for this one this is going to be what I consider like our first like actually difficult uh dynamic programming problem and so those previous toy problems of like fib and Fibonacci those have all been building up to a problem like this right what I really want to emphasize is we kind of write the code for this is try to compare the process for solving it similar to how we solved Fibonacci and Fibonacci right meaning that we're going to start by solving just some Brute Force recursion check that it works check that it's correct it's probably going to be too slow and then we add our memoization on top of it right we're going to scale out the solution here and so let's Jump Right In and so to solve this one I know I need a Brute Force recursion and with any recursion I like to think about my base cases right so when it comes to my base cases I have to think about all right what are some like trivially small inputs for which I automatically know the answer like we said in the approach video The Great base case here is going to be if your amount is really small so if my amount is zero if your amount to zero then what you want to do is kind of give back a Boolean representing all right is it possible to add up numbers such that their sum is zero and that's always possible right you're going to always get a sum of Zero by adding no numbers together right that's trivially true and so I'm going to return true here so if you hit an amount of zero just return true awesome but from there I know I have some positive amount and I need to break it down smaller and smaller toward this base case and I know that to shrink the amount I must subtract some value from the numbers list so I'm going to start iterating through the possibilities here so I'm going to iterate through every int I'll say none within the numbers list and I know that I'm going to take my current amount and subtract it by this number so just for some clarity I'm going to label this variable as my sub amount right because it's my original amount just with some number reduced out of it awesome and now what I want to do is keep solving this problem recursively so now I want to figure out is it possible to have a sum that adds up to this sum amount and I have a method to do that it's the current method I'm writing right so I'm going to call some possible and check if the sub amount is possible Right the second argument to this recursive method should be the same argument right numbers you can reuse the numbers as much as you want so I can pass in the same numbers awesome but now recursively have to think about all right what does this give back well I know that it definitely gives back a Boolean and that Boolean represents whether or not it's possible to create these sub amount right if it is possible so if this comes back as true then I know that it must be possible to sum up to the entire full amount so I'm going to return true here and why does that logically make sense well if it's possible to make my sub amount right it must also be possible to make my full amounts because to make my full amount I can just add one additional number to it right because to get the sub amount in the first place I took out one valid choice of number but on the flip side if it's not possible so if this a recursive call returns false then you want to keep looking and consider if another choice of number would be possible right so something to watch out for is you don't want to write like a else return false right because you would exit too early right you only want to return true if you find a valid amount right the place you should return false is only after you're done checking every possible amount and you don't find one right so you want to write a late return false here all right if I don't find any uh sub amount that's possible and I checked all of them so after my for Loop then you can return false hey it must not be possible to create my amount awesome so this looks like my Brute Force solution but we are missing a one kind of glaring case we'll want to pay special attention to our subtraction on line 10. right based on what our amounts and number is we could get like a negative value for sub amount imagine my amount is two and maybe my number is five well if I do two minus five I get negative three and things will get kind of nasty from there because at that point I've already overshot my base case of zero and so you'd get increasingly more negative numbers right as your amount and so we never really want to let our amount become negative so I like to turn that into a base case so if my amount becomes negative and I can return false right it's not going to be possible to create a negative amount using a sum because they tell us in the problem that our numbers are all going to be positive right you can never generate a negative quantity by summing up positive numbers awesome so now I'll make sure we don't overshoot right we'll get just return false here that'll help us complete The Brute Force recursive here so let's give that a shot always want to make sure that it gets a correct answer and it just times out right so now I know that this is a great candidate for applying memoization right we know that like we said in the approach video this currently has an exponential run time so it's far too slow so to structure the optimize solution here I like to split up into my main method and my recursive method that also takes in a new argument which like we're used to from our last two problems right it should be a hash map cool the keys of the hashmap are just going to be the argument of My Method but it's only going to be the argument that changes right so if I look at the recursion here I know that amount is really the argument that changes over time right the numbers argument or the list of numbers doesn't change right so I know that that list of numbers in my recursion doesn't really dictate the result right because another changes I always return based on what the amount is and so I'm just going to make the integer amount my key right the corresponding value is going to be just the return type of your method so Boolean here I know that corresponds with you know the return values online like 20 and 24 and even in the base case awesome I'm going to call this my memo once again so let me go ahead and do some of the housekeeping here so I want to get the hashmap and when I I'm in my main method I'm just going to invoke my overloaded helper method give it the same amount give it the same numbers but you should give it a new hash map that's going to populate over time so it's nice and fast awesome at this point what I want to do now is add my base case to check hey maybe an input amount I've seen before right so I'm going to add as a base case here so if my memo contains a key that corresponds to the current amount I'm looking for I just want to return its stored value because I would have stored the answer there so return memo dot get amount all right very reminiscent of your Fibonacci and Fibonacci awesome other things I need to do is need to be sure to pass this memo by reference to all of my recursive calls and I know that there are actually multiple recursive calls here because on line 25 I have a recursive call and it's in a loop right so you make a recursive call for every num of the list I'm going to over here pass in the memo and now the only thing I'm missing is I need to find a way or find a location where I should add information into the memo right when do I put some keys and values into the memo like I said in the previous videos I always locate my recursive return values right so that would be line 26 and line 30 right to be safe you can memorize both of those return values right there's no points of memorizing your base case return values because those already occur in constant time right so there's no need to do it there so over here before I return true you want to store in your memo for the key of amount the same value would have returned right so if you return true then your stored value is true or if you return false then in that case your stored value is going to be false right and like we always say the key that you kind of refer to through your entire memo logic is going to be the argument amount right so I'm not writing any keys that have to do with the sub amounts to keep your code nice and clean you write about your current amount you're passed in right you know when you make your recursive call on the sub amount that will become its own like full amount and then it will get cached anyway in the memo so this should be good to go let's give this a test run see how we optimize our solution great and there we have it hey programmers Alvin here right now let's go over the approach for this Min change problem so in this problem we want to do is take in two things as input we're going to be given a Target amount as well as an array containing some coin values what we want to do is return the minimum number of coins required to create the amount so for example since my target amount is 5 one way I can give back five cents would be to do one plus one plus one plus one or I can do one plus two plus two or I could even do one plus one plus three and also two plus three in this problem what we want to do is choose the way that requires the least number of coins so that would be the two plus three that would use only two total coins and my function should just return that number of coins which would be two as my final answer all right so let's start attacking this one by visualizing it let's sketch out what we would do for an amount of four that way we can actually finish it because we're going to see that as we moderately increase the amount the size of our problem actually grows pretty large and so if you're doing all these problems in order and I always recommend that you do you should recognize this one as a dynamic programming problem so I'm going to try to do is shrink my problem size then also notice any overlapping sub problems in the long run and so I'm going to sketch things out as a tree what I'll do in the nodes of my tree is write down my current amount that I need to generate and I can break my current amount down into smaller sub amounts so let's say I start with 4 at my root to generate amount to 4 what I could do is use a one cent coin if I did that my remaining quantity would be three as my amount I could have also taken a 2 which case I need to generate two where I could have taken the three cent coin in which case my remaining amount would have been one so let's continue this pattern let's say I was at this three node this node would have three more children just branching for one cent two cents and three cent respectively if I take a look at this two note over here I can't actually use every option here I certainly Branch twice because if I took the three cent coin that would give me a remaining amount of negative one which I should probably avoid similarly for this note of one I can only Branch using the one cent coin so let's say we continue this pattern for the entire tree you would end up with this structure and what we see visually is the decision tree that represents every choice of a coin we can make until we hit zero and so this is a tree structure that we've seen a few times in the course what I'm going to argue is within the visual of this tree you should actually be able to recognize what the answer is for this amount of four so take a moment see if you can recognize any properties within this tree where can I find the answer to this problem what we should do is interpret each path of this tree so let's say I looked at this path that would represent the sum of one plus two plus one in other words I took a one cent coin and a two cent coin and then another one cent coin what I can say is that would represent the answer of three like a possible answer of three because I used three coins to generate my target amount of four that's only one possibility we know in this problem we really want the minimal a number of coins used so that should translate into one of these shortest paths like this one this would represent my sum of three plus one and that would have a length of two you could probably notice that there are a few other paths with a length of two that's okay we just want to return the smallest length possible which would be two and so what we're really recognizing here is the minimum number of coins required to generate our amount would really be the shortest path from the root to any Leaf within this tree assuming a leaf terminates at a zero so how can I do this more programmatically maybe we'll sketch this out as some recursion tree right so what I'll do is think of a return value for all of these zero nodes we can say is our base case if our amount is zero then I should return zero and so zero is a great choice because it's a small number and I can't break it down any further and I should also return 0 for that instance because the minimum number of coins required to make zero sense would be to use zero coins right just use no coins so above all of these base case nodes I'm going to jot down my result of zero and what I can do is start to evaluate these as return values so let's say I was at this node of 1 over here what I'll do is just receive Zero from my child call what I should also do is add 1 to it if I add one that would actually count the edge between myself and my child node because remember when it comes to counting the number of coins we're really counting the number of edges in a path through this visual tree so let's say I was at this two node now I was ready to evaluate it what I do is receive both of these values of 1 and 0 for my children and because I want the shortest path or the minimum number of coins my nodeans to choose a smaller between the two so I do one versus zero I pick the smaller one of zero but then what I need to do is actually increment that by one to count the edge between us and what that would represent this one designates the shortest way I can make two cents which would represent this path highlighted in pink let's continue this pattern so let's say I was at this one node the zero would just bubble up then I add one to it because there's no decision to make but now it can be at this three node this three node is going to receive three options it's going to choose the smallest among them so just zero but then it needs to add one to it and at this point I should be able to check for correctness I have a green number of one above my three node which means the minimum number of coins I need to make three cents would be just using one coin which makes perfect logical sense because I have a three available in my coins array so I could just take a single three cent coin let's continue this pattern elsewhere in the tree at the root note of four in this tree it's going to receive a bunch of ones technically it would choose the smallest among them which would be a tie given one and what I should do is always increment it by one to count the edge between myself and the children nodes and this too represents the fact that I have a few different paths that could only take two coins or two edges it could represent this path or this path or even this path so as we evaluated this tree something really important we did was whenever we received multiple values from our children so when we received multiple sub Solutions what I do is choose the smallest among them right I know I need some Min value logic present in this implementation because I want to choose the minimum number of coins possible so I'll just keep that in mind when we implement the code we talk about the complexity of this we've seen the structure before right now we're going to describe the Brute Force complexity if we say that c is the length of the coins array and a is the target amount then the time complexity is going to be exponential right we know that the branching factor of this tree is going to be based on the number of coins so C right branching Factor refers to given a node at most how many times will it yield children and I know what my ratchet Factor here is three and in the worst case I have three branches coming out of a single node my exponent here is going to be a because that would be the height of the tree we'll say that the space complexity is going to be o of a due to the call stack because if you look at the height of this tree it would be in the worst case a we say the worst case would be the scenario where I keep taking a bunch of one cent coins giving me the deepest recursion possible so if you start the root node here and you just keep going left you're going to see a sequence like four three two one zero and that definitely is a linear pattern in a so overall we're looking at an exponential runtime and a linear space complexity for this solution the time complexity definitely needs some work there right we want to bring it down from an exponential so like we usually do we just want to memorize this one we'll try to notice any duplicate sub problems so looking at this tree there are some duplicate sub trees I can notice I can see these sub trees rooted in two so instead of recalculating that subsolution I can save it and just reuse it so I can trim out that piece of the tree I also have other sub trees rooted in one and I can also ignore those right the way I'll implement this is by using some constant time data structure like a hash map I can store sub results as I compute them in that hash map and then reuse them later on if that high level strategy seems confusing don't worry you'll want to wait until the walkthrough video will actually show you the details on how to implement this in some code so let's do a re-analysis of this now we're going to analyze this dynamic programming solution that uses memoization the time complexity is just going to be a times C so it's no longer exponential it's really a sort of multi-linear right just multiplying my two terms together we know that time complexity is going to be based on the number of recursive calls we make and in this visual diagram every node represents a recursive call we still have a tree of height a so that's where the a comes from what we're saying is across every level of this tree we have at most C nodes so I think of a as the height and C is the width that would give me a times C nodes overall it's actually pretty easy to spot in this particular example in the worst case scenario at a particular level we have only three nodes at most that's because our coin array only has three options inside of it the space complexity for a solution is just going to be o of a due to the call stack and we'd be storing at most a different keys inside of our memo hash map all right I think I'm ready to code this one up you want to join me in the walkthrough video now at this point we're done with the planning phase for our Min change solution what you want to do is head down to the links in description below where you can find the link to the Min change problem where you can code up the solution in Java with me hey programmers Alvin Constructor here what I want to do is go over the Java walk new for this Min change problem so you definitely want to make sure you watch the approach video first this is going to be another dynamic programming problem similar to our previous some possible problem like we said in the approach video what we want to do here is optimize for the number of coins that we take into our sum and so I'll Implement that strategy exactly what I want to do is start by laying out a base case we know that in this problem our base case should be about an input amount that is trivially small and for me the amount is going to be zero so I'm going to check if the current amount that I'm looking for is equal to zero then I want to return the answer for that amount of zero I want to return an integer representing the number of coins I need to create that amount so if someone asked you to generate zero cents what's the least number of coins you need to generate zero cents the answer there is zero coins so I'm just going to return zero then from there I want to start writing my recursive scenarios so I know that I need to take one of my choice of coins to reduce the amount so I'm going to iterate over all the possibilities so for me that means I'll iterate for every int coin within the coins list and what I'm going to do is I'm going to take the input amount and subtract this coin from it that smaller quantity that'll give me my sub amount we'll call it and from there I want to recursively find the minimum number of coins needed to make that sub amount so I can call my recursive method pass in that sub amount could pass in these same old coins in the problem they tell us that we can reuse a coin as many times as we need awesome but now from here I need to do some thinking I know that this method call should give me back a number representing the minimum number of coins needed to make the sub amount I'm going to save that number into a variable here just readability I'll call it sub coins because that's the number of coins needed to make the sub amount and I know I need to find the minimum subcoins for every choice of coin that I can take so I need to perform some Min value logic here you know generally A Min value logic means as we iterate over the possibilities we maintain some outer variable here I'll call it the mincoins I have to think about a good default value for it here well I know that in the context of the problem they tell us that all right if it's not possible to make the amount with the coins then you want to return negative one so I actually use that as an initial value here so I'm going to set this up as negative one and I know that after the foil at the end of my function if I never find a mount that works I'm going to return mint coins which should still be the negative one right but besides that what if it is possible to make the sub amount well if it's possible to make the sub amount that means that subcoins would be a non-negative number right so I'm going to check if subcoins is not equal to negative one that means it was possible to make the sub amount since subcoins is the number of coins needed to make the sub amount if I do subcoins plus one that should be the number of coins needed to make the full amount and why do I know that this additional plus one here is counting the single coin I took to get the sub amount I'll save it to a variable called int num coins so this is the number of coins needed to make the full amount over here and now I could compare this against the mincoins variable right so I'm going to check hey if this number of coins is less than the mint coins well then I can replace the mint coins with this new number of coins right but it's pretty obvious here that when we initialize the mint coins to negative one this negative one may persist over any valid number of coins here right because negative one is already a negative quantity right so this negative one just acts like a placeholder right to represent an invalid quantity or the fact that we haven't found any valid number of coins yet and so if the number of coins is less than Min coins or the Mint coin still contains that default value then I can replace that default value with this number of coins right so I'm performing A Min value logic over my minimum coins so this code is looking pretty good one thing we need to be aware of is when we calculate this difference here we do a mount minus coin that could give us a negative amount right sub amount could be negative so if we call Min change with a negative number we already overshot the Space Case here so what I can do is just cache that with the base case so if ever my input amount is less than zero then what I want to do is return some value I'll return negative one here because again negative 1 in this problem represents the the fact that the amount cannot be generated with the coins we're given right you cannot generate a negative amount when all of the coins that you're given are positive so that's going to be a good extra base case there so let's give this a test one this should be our Brute Force solution for Min change if all is well we'll add some memo into it and make it a little faster so I'm getting an area it looks like I have a random typo current subcoins that should just be subcoins plus one right let's give that a test once again nice and this looks like our Brute Force solution we know that an algorithm like this so far has an exponential run time just like we said in the approach video so to speed this up I'm going to use our memoization strategy so like I always love to do I'm going to separate it into a main function and then a recursive helper right so my main over here will just call my recursive helper it's going to take in the amount as well as the coins but also my memo which will be a new hash map I'll be sure to take that hash map as an argument here so it's going to be a hash map and I have to think about what the keys of this hash map are going to be they should just be the argument that changes during the recursion which is the amount notice that the amount is the only ARG that changes coins stays the same so I don't need to add it as a key into my map here so I'll say my keys are going to be integer and then the corresponding values are going to be just the return type of this method which is also integer I'll call that memo got to be sure to import hashmap above looking pretty good and be sure to pass along that memo through the entire recursion now I need to add an additional base case right I need to check hey if the memo already contains the amount well then I've solved this sub problem before just return the stored value in the memo so I'll return memo dot get the amount awesome but if it's not then I'll go ahead and actually perform the true logic and calculate recursively of the answer right and I know that now I need to actually add data into the memo where I return the result so I look for the literal return line in my recursive case and it's only one return statement here in the recursive case that's line 35. so literally what I should do is I ought to save this into my memo so I can do memo dot put I'm going to use the input amount as my key always use the original argument make the corresponding value mincoins and you still need to complete the return value so like before still logically return mint coins you're just making sure you store it in the memo before you leave this recursive call nice so with that logic built around my Brute Force by adding the memo we should get a better run time here awesome there we have it here we start to really see the power of this strategy of first solving a Brute Force recursion and then applying our memoization trick right around it really the hardest part of a situation like this is to solve The Brute Force recursion in the first place right but that lets you focus on just the correct logic and then afterwards you speed up that logic using this additional data structure all right programmers that's all I got for this one why don't you do is practice this and I'll see you in the next one hey programmers I just want to take a little break from our dynamic programming material to tell you about structi Shruti is a complete data structures and algorithm course that you can use to prepare for all of your technical interviews it's actually the course you've been seeing me use throughout the video tutorials I'm going to be your teacher through the entire instructed curriculum and in the structure course we cover all of those essential interview topics like graphs trees dynamic programming and more and like you expect for every single problem like you've seen in this dynamic programming course we're going to support it with animations as well as code walkthroughs and you'll be able to code up all of these Solutions on the platform tester code in Java C plus plus JavaScript and python so if you're enjoying this dynamic programming material I recommend you head over to structure where you can practice things further whether it's dynamic programming or those other essential topics and of course you're going to be joining me for all of those video walkthroughs so I'll see you there without any further Ado let's hop back into our course hey programmers Alvin here right now let's go over the approach for this count paths problem so in this problem we're going to be given a grid what we want to do is travel from the top left corner down to the bottom right corner and here we want to return the number of ways that's possible to Traverse through this grid the caveat is we can only move to the right or downward that means we can go up and we can't go to the left and so for this particular grid let's talk about the different ways we can travel through it one way would be to go right right down another way would be to go right down right and finally the last way would be to go down right right and since there are three possible ways to travel through this grid we should just return the number of three so this should be a counting problem for us however this problem is a little more nuanced they say that some positions are going to be occupied by walls and we can't travel through them so if I had a wall like this in the top right corner then one way to travel to the grid would be right down right and the only other way would be downright right so let's Trace through the strategy for this one by looking at a larger example if I was given this 3x3 grid I'll also put a wall in the top right corner let's start by labeling the indices for our rows and columns we know that we start in the top left corner so that would mean row 0 column zero and what I want to start to do is try to give myself a way where I can denote every option I have right how can I Mark the decisions I can make by traveling through this grid so I'm going to visualize this one as a tree so if I start at position 0 0 I can make that the root of my tree if I'm at this position I'll think about my options that I have I can either move downward if I move downward that would increase my row by one but keep my column the same giving me one comma 0 or if I went to the right I keep my Row the same at 0 and I increase my column by one and that would be the only two options I have from this root position and I can just apply this logic recursively so let's say I was situated at the zero one node right now so I'm over here I know that my options are more limited now I can't move to the right because I have a wall in my way so I'm going to need to make sure I code that one up and I can only move downward here and that would mean increasing my row by one and keeping a column the same and so let's carry over this pattern to draw out the rest of this tree we know that given a node at most it's going to have two children representing my downward or rightward movement and that would mean either incrementing the row by exactly one or incrementing the column by one however we should not do that move if we go out of bounds or run into a wall so the full tree would look something like this what's great about this tree is if I start at the roots and travel to a leaf node that would represent one of the paths I can take through my grid in other words if I look at this path in my grid I can represent that using this path in my tree which is a really nice way to interpret this problem and so let's start to realize how we can encode the base case in this problem what you should be realizing is we're visualizing this as a tree which usually gives us a nice way to implement this as recursion right so if I've got all the leaf nodes here I always terminate at 2 comma two because that would represent the bottom right corner of my grid which is the goal and so if I'm at the bottom right position of 2 2 what should I do here well I have to think about the return value for my function here right they say they want a count and so what I should do is treat this to comma 2 position as if it's its own input so if someone asks me in how many ways can you get from the bottom right position to the bottom right position the answer would be one right there's only one way to do that that would be to just stay there right because you're already at your goal point and so I'm going to make all of these Leaf nodes or all these base cases return one now having these calls return one seems useful because I know I need to tally up a count in this problem so how do we start reconstructing our larger Solutions here well I would just really Bubble Up these ones right so let's slow down at this one comma one node over here we know that this node has a little more work to do because it's going to receive two values and so what I should do is bubble up both of these values right and then this note should just add them together so one plus one gives me two and so what are we saying here if I pause I should have some logical information in the subtree what it should be saying is that there are two ways to get from the position one comma one to the bottom right corner I have this path or I have this path there are two different ways to get from one one down to your bottom right corner so I'll just carry over this pattern keep reconstructing all of my Solutions and as we get toward the top of our tree we are going to get the final count of all of the ways to travel from the top left to the bottom right giving us our final answer of five what's great about visualizing this one as a tree is it really describes the decisions we can make as we travel through the grid right we know that this gives us a binary tree because for the most part when we're on the inside of the grid we only have two options right you can either move downward or to the right that'll help us decide the complexity of this Brute Force algorithm so if we implement this algorithm as it is just with some baseline recursion we say that R is the number of rows and sees a number of columns this will give us an exponential runtime meaning they're an exponential number of nodes in this tree really it's 2 to the r plus C power so the base of 2 comes from the fact that this is a binary tree and in the context of a problem that means I can only move downward to the right so you only have two options I'm saying that the height of this tree is R plus C right because you know you want to start in the top left corner 0 0 and travel to the bottom right corner what you have to do is actually Traverse a path that is exactly R plus C moves along right because you need to move through all of your rows and all of your columns for the same reason I can say that the space complexity is going to be R plus C just due to the stack depth right stack depth is equal to the height of this tree which we just said is roughly R plus C and so overall we shouldn't be too satisfied with the time complexity of this one right typically something exponential would be too slow for our liking and so what we should do is recognize that we actually have this visualized as a nice dynamic programming problem what you should do is take a moment look at our visual tree and notice if you can spot any duplicate sub problems right are there any overlapping sub problems here that I can memorize so we actually have a duplicate sub tree over here rooted in one comma one what I could do is just save the first time I calculated that way I don't have to fully recurse down my tree the second time around effectively memorizing my duplicate function calls which in the context is my tree visual just means that I prune out some branches there are some other subtrees here I can look at this two comma one subtree I can also memorize that away and we know as we grow the problem size in other words if someone gave me a larger and larger grid I would have more and more overlapping sub problems so I'd benefit more and more from memoization like usual for us the way we'll implement this is by using some hash map data structure I'll save that detail for the Code walkthrough though so what do we know about the new and improved complexity of this one right we're going to implement our dynamic programming using our classic memoization strategy so like usual R is the number of rows and C is a number of columns now would be the case that our time complexity is R times C right it's still the case that our time complexity is driven by the number of recursive calls we make and now we would be making roughly R times C different recursive calls right and how do I know that well in the context of what I'm going to memorize into my hatch map I'm going to put positions right notice that each node in this visual is a position of row and column and I know that there are exactly R times C different rows and columns so once I store a row and column into my memo I would never have to fully recompute it which gives me my time complexity of R times C likewise now is the case that my space complexities R times C taken mostly from the size of that memo right every position is going to be a key and so I have R times C different keys in my memo object all right programmers I'm sure itching to see how we actually implement this one in some code so right now you'll want to join me in the walkthrough videos I'll see you there now that we're done sketching out the solution behind this count pass problem what you want to do is head down to the links in description below where you can actually access the prompt and the test cases for this count pass problem and we'll code up the solution in Java together hey programmers Alvin from structure here what I want to do is go over the account pass problem in Java so like we said in the approach video we're going to frame this problem like a dynamic programming one this is going to be a little different compared to our very classic like graph like grid problems because in this problem you can only move rightward or downward that means that we can't get caught in any Cycles right so I don't have to do any visited logic or anything like that however what I will do is solve this one with a Brute Force recursion and then apply our memoization strategy on top of it to get a really fast dynamic programming optimized solution so to get the ball rolling on this one I know I need to start tracking like a current position as I Traverse uh through the grid so I'm going to split this one up into my main method as well as my helper and my helper is going to take in my current row and current column information and then in my main method I'll just pass control to my helper and I'll give it the starting point which is a top left corner which means row 0 column zero pass along the entire grid to reference then from here I'm going to structure this one as like a depth first recursive solution more or less so I'm going to start with the base case so what's my goal here well my goal is to find the bottom right corner of my grid so I can stop traversing if my row and column is the bottom right so be careful of the math here right to be in the bottom of most row that would mean that the row is equal to grid dot size minus one that means the bottom row similarly you want to check if the column is equal to the rightmost column so that would mean grid dot get 0 dot size minus one right so this is checking if I'm in the bottom right position then what do I want to do what I want to return overall the number of ways to reach the bottom right corner from this current position well if you're already in the Target position then you don't need to do anything so that's one way that you can get to the bottom right corner you just do nothing right because you're already there so I'll return one in this instance we have to think about some other scenarios right it could be the case that maybe my row and column is out of bounds so I want to avoid that and so I'll check very a very similar condition here I'm going to check if I'm out of bounds that would mean that my row is equal to grid size or my column is equal to grid.get0 dot size right notice that I'm turning this into an or right because if your row is too large or your column is too large well in the theater those are true or both of those are true then it's an invalid position so you're out of bounds right and if that's the case I still need to give a logical return value right I always want to have consistent return types so even in the space case if I'm out of bounds I want to return an integer and an integer needs to represent how many ways from this position I can travel to the bottom right corner well if you're out of bounds there's no possible way to ever get to the bottom right corner at that point so you want to return zero right there are zero ways to travel from an out of bounds position to the bottom right corner so I have my base cases looking pretty good but there's one more to capture here they also tell us that all right some positions of your grid are not open o stands for an open position if a grid position contains an X that's a wall that I cannot travel through so I'm going to actually add that into the mix here right it might be the case that if my grid dot get r dot get C so if my current position is equal to an X well then I can't Traverse through it right that's also a dead end kind of I like out of bounds so I'm similarly going to return zero awesome do note the important order of these two cases over here right I'm making sure that I only try to access like the innermost element of my a 2d grid after I check that the row and column are valid right I know that I'm using some valid RNC to get a position of my grid it's just that that position contains an X so these are all of my base cases here now I can start structuring my recursive case and I know that from any position that I'm at I have you know two options to take and those two options will turn into my two recursive calls right so I'm going to call account paths you could move downwards so you could move down a row keep the column the same but you can also move to the right so you can do count Paths of the same row but increase the column nice I have to think about what these two recursive calls return they return a number right this one on the left returns to me the number of ways I can get to the bottom right corner or get to the goal if I move downward this tells me the number of ways I can get to the goal if right now I move to the right if I take the sum of them that gives me the total ways I can get to the goal from this position because from this position you can only either move down or move to the right so this is looking like some core logic this looks like the shape of my brute force not much logic to it overall just some tricky edge cases here for my base case and so let me give this a test run I'm looking for some correct output so I'm passing some test cases but probably timing out for large inputs and there we see it so like I always love to do now I need to apply my memoization to it so I'm going to set that up you always want to use some fast lookup data structure to store your memo right and so for us use something like a hashmap and I'll pass along that hash map inline over here so new hash map and I'll take it as an argument and here where I design the hash map have to be a little more particular right so generally for the keys of my hashmap I always use the changing arguments into my recursive method here right so if I look at the arguments that change during my recursion it's the row and the column right the grid itself is always the same throughout the full recursion so I don't need to encode it into the keys of my hash map and so I really need to represent a row and column pair or like position as keys of my hash map because depending on their own column you get a different answer and so to actually store that key I'm going to use just a list of only two things of a row and column so it'll be a list of integer and I'll just guarantee that I'd make sure that those sub lists are always going to be of length two right just pairs of row and column and corresponding value is going to be the return type for my method which is just integer as well nice call this memo and now let's add our memo checking logic so pass these base cases what I like to do is form the key I'm going to use into my memo so create that key here it's going to be a list of integer let me just a pair I'll call it my position it's going to be just a list of the row and column nice and I can check hey if this position is in the memo so if memo dot contains key position and I can return the associated value with it because that means I've seen this not recursive call before so I can just instantly find the old result so return memo dot get position again the key trick here is I'm using this position because it contains the row and column arguments right so I'm using that entire entity as a key into my memo nice then from there like we're used to I should be sure to pass the memo to my calls here and whenever you see your recursive return value which is line 30 for me you want to store that result in your memo before you leave right so I'm just going to store this into an INT result be sure to put that in your memo so memo dot put this is uh put a key of position with the result and then just return the result nice so with those changes pretty classic changes to the previous problems that we've been doing except we're having a little more complex of a memo key here let's give that a shot awesome there's our solution for count paths hey programmers Alvin here right now let's go over the approach for this maxpath sum problem so in this problem we're going to be given a grid and we start in the top left corner and we want to make our way to the bottom right corner this grid is going to be populated with some numbers though we want to do here is return the path containing the maximal path sum in other words there are a few ways we can travel through this grid one way would be to use this path in which case there's sum would be 14. another way would be to use this path in which case your sum would be 12 and finally you can use this path in which case your sum would be 18. and between these three options I should choose the 18 right and so that would be the max path sum for this grid so let's cut to the Chase and describe the strategy for this one and we'll step through exactly this example so we'll label the row and columns and we also know that we start of course in the top left corner the SE are really just a spin-off of our last problem so hopefully you visualize this one as a tree right a binary tree because we only have two options at any point in time right you can either move downward or to the right and sometimes in just one of those directions depending on whether or not you're at the border of our grid right so we'll start at zero zero from this position I have two options if I went downward I would increase my row by one notice that each pair within a node here is a row and column or I could have moved to the right in which case I would be at zero comma one now to present my two moves let's say I was situated at this one comma zero node here I only have one move possible to make I must move to one comma one right that represents a move to the right if you look at my row and column indices that's because I can't go downward anymore because I'm already in the last row if I take a look at this position over here I do have two options right I can go downward or to the right giving me one comma one and zero comma two respectively we can build out the full tree from this point we know that we must terminate at position one comma two because that would be the bottom right corner so I know that that is our ending point right so that's going to be my base case I know in this problem I want to choose the maximal path sum so I want to Max some but how can I start accumulating a sum in the first place and so what you have to do is ask yourself if I'm already at the end position what is its Max path sum to the end position that would just be the value of 2 right that's exactly the number in that ending position so for my base cases I'm just going to return whatever number is in that final position then from here I know that these values are going to return so let's say we were situated at this one comma one node it's going to receive a value from its child call because we know we're visualizing this in a recursive way and what I should do here is note what position I'm at so 1 comma 1 would be this position containing a six I want to accumulate a sum here so I should do 2 plus 6 giving me eight so this node is going to return 8 to its parent so it's 8 it's going to Bubble up a little bit more if I think about this one comma zero node that represents my current value of 5 over in yellow and I would do my 8 plus 5 giving me 13. so that would be a partial path so far so we'll continue this process on our right hand side we know that these would just Bubble Up and we would add the respective values at those positions things came more interesting when we're at this zero comma one node though so for this note it's going to receive both 8 and 14 right it's just going to return back up like we always do and I have to make a decision here since I want the max path sum this node should choose the larger of those two values so 14 is bigger than 8. so I prefer the 14 here but I should also still add the value stored at my current position so if I look at position 0 1 within my grid that would be this value of 3. so I add 3 to the 14 giving me 17. finally this takes place again at the root so if I'm at 0 0 I'm going to receive the 13 and the 17 for my children I choose the bigger value of 17 and then I add my position itself which has a value of 1 inside that gives me a final answer of 18. so the way we reconstructed our sub Solutions into higher level Solutions was to choose the larger of our two children and then add ourselves to it that way I get some max value logic while also summing our path we talk about the Brute Force complexity of this algorithm we say that R is the number of rows and sees the number of columns then our time complex is going to be exponential just like we saw in the last problem the base of 2 comes from the fact that given any position we have two options right we can either go down or to the right and I make R plus C the exponent because that would be the height of this tree right that would be the length of any particular path I know any path that travels from the top left to the bottom right must cover all of the rows R and all of the columns C and so the entire path length would be R plus C in a similar way I'll say the space complexities R plus C due to the stack space required by this recursion right if the height of this tree is R plus C that means the stack space used by my recursion is also going to be R plus C but a keen Observer would know that I can do better because this is a dynamic programming problem so what I'll do is take a moment look at this tree see if you can find any overlapping sub problems and although this example was small I can already see some overlap if I look at this node rooted in one comma one I see it here and you also see it here I know the punch line is I should only have to calculate these nodes exactly once so I should be able to trim out a little bit of the tree by using some memoization and as we actually increase the size of our input as I get a larger and larger grid I would have more and more overlap that I'm able to kind of forego using some memoization like usual we're going to implement this using a hash map but I'll say those finer implementation details in the walkthrough video if we Implement memoization properly for this one we're going to bring our complexity down to linear right so we're going to have a Time complexity of R times C that's because there are R times C different nodes to actually cover now right I know I'm going to put the positions as the keys of my memo and there are R times C unique positions in a similar way it's now the case that my space complexity is taken over by the size of my memo which is also R times C because of the number of keys right I have R times C keys because I have R times C positions all right I think I'm ready to code this one up you'll want to join me in the walkthrough videos now hey programmers welcome back what I want to do right now is go over the Java walkthrough for this Max path sum problem so it's going to be a small variation of the previous you know grid dynamic programming problem except this time you want to find the maximum as we travel from the top left of our grid to the bottom right so I'm going to start by setting up the same initial structure so you'll want to track a position as you kind of Traverse through your grid and so I'm going to add additional arguments to this method so I'm going to track my current row as well as my current column nice and then from there what I want to do is start laying down my base cases right so for my base cases like you expect there are a few I need to check if I'm out of bounds so if my row is equal to grid dot size that means I'm just outside of the grid or maybe my column is equal to grid dot size or rather grid dot get zero dot size or I'm out of the column range right either case you want to return a sum integer right how can you represent an invalid integer meaning it's not possible to travel to the bottom right corner using this particular position well because I want to perform overall like a Max path logic or max value logic I know my logic is going to be preferring any larger integers and so whenever I encounter like an out of balance or invalid position I need to return some very small number right and so for me I think the best way to solve this one is going to be to use like a negative Infinity concept so in Java really your only choice for like a true negative Infinity is going to be in the double type so I'm going to say double dot negative Infinity which means I have to adjust some of my types here right so I guess I'm going to make this return a double that's totally fine I'll just be sure to cast it back in my main method here right so what am I saying well just so I can have access to like negative Infinity in my recursive over here in my main method it's going to call maxpath sum with the initial row initial column as well as the grid and I know that this is now defined to return a double you're going to get an error in Java if you try to return a double from an integer return method so I'm just going to cast into integer I'm just doing that really straightforward so I'm only going to convert at the very end which is fine all right so beyond that I need to just handle the case where I actually hit my Target in a base case so that'll be a similar condition right you want to check in English if you're in the bottom right position so if your row is the last row and your column is the last column and so you want to return some number here and overall you want to be adding up the values in your grid as you travel along them so in your base case you want to return an actual value you want to return the value of your current position so you want to return grid.get r dot get C so what am I really saying here so let's say that we're performing our recursion and we hit this base case meaning we're at the bottom right corner so that means I'm at this position what I'm going to do here is return the value at this position so I'm returning the value of one I'm going to return it because I need to eventually add up all the values along my winning path and the end goal is still part of my winning path here nice and so now that I have these base cases in line what I want to do is start forming my recursive case so I know I'm going to have two recursive calls right because at any position I have two options I can either go down or go to the right so I'm going to call maxpath sum going downward would be R plus 1 C grid and going to the right would be maxpath sum of the same row increase the column same old grid nice and here what I want to do is prefer the larger sub answer right because when I take a path through my grid you either go right or you go down right and I know that these recursive calls can be back a number they represent the sum of the a path if I travel through the right or if I travel downward and I want to choose whichever sub result is bigger right because right might give you a bigger sum or going down might be a bigger Sum It could only take one of them and so to choose just the maximal between these two numbers that I get back I'm just going to use the built-in math.max you can also write some conditional logic this is probably the easiest way to write this though so just choose the bigger value between these two methods but I should also be sure to add my current position into uh that answer right so I'm going to do grid dot get our dot get C add it into the bigger between my going down choice or my going rightward choice right this gives me the logic of summing up all the values along a particular path awesome so let's give this code a run this should be our Brute Force solution it looks like nice and if all is well we should start timing out and there we have it so let's improve the runtime of this one by adding in our memo so that's going to be a hashmap this is going to have us use a hash map where the keys are going to be positions right because the row and column is what determines the answer here because those are the arguments that change so I should have passed along a new hash map here and over here I'll Define the type so hash map keys are going to be positions so just kind of list pairs to integers corresponding value is going to be looks like double I'll call that memo so like we always do we want to add our memo checking logic as an additional base case so I'll start by forming the key first which is really just a position pair list of the row and column and then start by checking if it's in the memo so if memo contains the key of position then return its corresponding stored value so I'll return memo dot get position nice and then beyond that I need to be sure to pass along this memo so it's shared through the entire recursion so just pass it by reference here not a big deal and like I always say right the key is to now just find your recursive return value which is this thing over here you want to store it in your memo before you return right so this long expression just is a double it's like just a sum right so I'll save that as a result and this is going to be double how do I know it's double well it's obviously double because of this over here what I want to do is store it in my memo so memo dot put use your original arguments the original key here make the corresponding value the result and then like before still return the same old result the only additional step you took was to store it for a rainy day because I know later on if I ever encounter this position again I would hit this conditional and I can return that sub result in constant time which gives me a much better performance here give that a test run added our dynamic programming strategy there we have our very Snappy code hey programmers Alvin here right now let's go over the approach for this non-adjacent sum problem from this problem you're going to do is take in an array containing some numbers what you want to do is return the maximal sum of non-adjacent elements in this array so that means we can never take two numbers that are next to each other within the array for this particular input the answer should be 16 because the max non-adjacent sum would contain the 4 plus 12. here we should notice that we can't take a sum like 12 plus 7 because those two elements are adjacent within the array let's take a look at another example let's say I was given 7 5 5 and 12. in this particular scenario the output should be 19 representing the sum of 7 and 12 which is totally fine because they are non-adjacent in the array so let's come up with the strategy for this one we'll step through the example of 2 4 5 12 and 7. what I want to do is figure out a way I can come up with all the possibilities for numbers I take into my sum and numbers I exclude from my sum because we know that based on the numbers we take that would actually limit our options later on so let's say we started to encode this as a recursion tree right so I'm going to describe all the decisions that we could take as we come up with a sum for this problem so I'm going to start with my original array at the root what I have to do is come up with a decision right now let's say I was making a decision for the first element of this array so if I took 2 into my sum then I know my resulting elements I can choose from is really just 5 12 and 7. so notice how I did this left Branch over here right I'm writing 2 along the edge to represent that I'm taking 2 into the sum and notice how I make my array smaller in that left child I just have 5 12 and 7 because I cannot include 4 in that next call right because including four would actually mean that we're giving ourselves the opportunity to take an adjacent sum right if you take two right now then you can never ever take four so that's why I exclude it however at the root we could have also just not taken two altogether in which case when you look at your next subarray that would just be 4 5 12 and 7 right if I don't take the two that means I'm excluding it along the edge on the right hand side then I can totally give myself the opportunity to take four in the future so I'm going to include it in the next array so let's carry this pattern further let's say we looked at this left note over here what I have to do is always make a decision about the first element of this array so for the five note if I decide to take it what I can do is then look at the remaining elements of just seven right I don't pass 12 until the remaining subarray because if I take 5 I cannot take 12. however I could have also just not taken 5 altogether which case my remaining elements are just 12 and 7. so by now it should be clear how we generalize the steps here right given any particular array what I can do is either take the first element or not take the first element and that would decide what remaining elements I can choose from either slicing off one or two elements from the front of my array let's say we evaluated this node over here if I take 4 then I would give me a remainder of 12 and 7. if I don't take 4 then my remainder is 5 12 and 7. something interesting happens at the seven node right so in one scenario I can take the seven in which case I really just have an empty array left over right there's nothing else to choose for because that's my last element and the scenario that I don't take seven you would still have an empty array left over so notice how the seven node terminates and really two empty arrays finally we'll evaluate this 12 comma 7 node if I took the 12 then I would have an empty array because if I take the 12 you cannot take the 7 anymore and if I don't take the 12 well then I can totally take the 7 for my next decision at this point we would actually have a larger tree right there are still some nodes I need to evaluate here fully but what's great about this is I can actually notice that those are all duplicate nodes in other words I've noticed that this is a dynamic programming problem right if something has dynamic programming present in it then I should be able to recognize any overlapping sub problems in the context of this tree I just have to notice any duplicate nodes any duplicate subtrees I can notice a duplicate sub tree rooted in seven right so I don't need to re-explore the seven node again likewise I can notice a duplicate subtributed in 12 comma 7. there's even more than that I even have a very large subtree rooted in 5 12 and 7. and so I'm going to save a lot of complexity by saving some of these sub Solutions as I compute them so let's talk about how you can recompute our final answer from the problem now that we broke it down what we should notice is toward the bottom of our tree we're going to have leaves that represent empty arrays which does feel good because we know as our problem size gets smaller and smaller that would mean a smaller and smaller array right less and less numbers to choose from let's make our base case about the empty array in other words if someone gave me an empty array then the max non-adjacent sum would be zero right just take no elements of the array because you don't really have an option here so for all of these empty nodes or the empty arrays I'm going to have them return zero I know I'm going to make that a base case let's say we wanted to evaluate now at the seven node how will it use those sub Solutions well if I take a look at the left return value that's going to Bubble up but what I should also do is add the 7 along the edge right the yellow seven that represents the fact that I was taking and including 7 into that sum so I have a 7 on my left and for the right hand child that just bubbles up as it is right because I did not include seven for that particular sub problem and at this point I have this node choosing between seven and zero since I want the max non-adjacent sum I choose the larger between the two so I should return 7 in this instance so now let's evaluate this 12 comma 7 node since I just evaluated the seven node into its result I'm just going to jot down that answer here and I know I would Implement that probably using some memorization but as I carry on my return values here the left-hand0 is going to Bubble Up but I add the value along the edge because I was including 12 to that sum so I have 12 on my left and 7 on my right I choose a large between the two and I should return 12. which makes sense because if you think about it given just the small sub array of 12 comma 7 the Max on adjacent sum would be 12 right just choose 12. definitely don't choose 7 because that'd be smaller now that I've evaluated this 12 comma 7 node I know I can save this result for later on so I'm going to jot it down on that duplicate node over here now let's evaluate a little higher up we'll carry over the same logic as before so I return these values and I add the 5 along the left hand Edge giving me 12. at this point I choose the larger between 12 and 12. it's really a tie here so I'll just return 12. so I've just computed the subsolution for the array 5127 and I actually have a duplicate node on the right hand side so I'm going to jot that down if I evaluate this node now things Bubble Up along the left hand Edge I add a 4 giving me 16. so I do 16 versus 12. I choose a larger one which of course be 16. finally at the ultimate root I return these two values but the left hand Edge gets a plus two I choose a larger between 14 and 16 giving me my final answer of 16 which would be the correct answer let's talk about the complexity for this one so if you say that n is the length of the numbers what we could do is analyze the Brute Force complexity of this right so if you did not optimize this by trimming out some duplicate nodes in your sub tree you would have an exponential runtime in other words your time complexity is 2 to the n and your space complexity is just o of n we can say that the time complexity is 2 to the N here because for every node of this tree it's going to give at most two children right so in the worst case from one level of the tree to the next I double the number of nodes and I also know that the height of this tree is going to be n right the height of the tree is going to be n because in some scenario I could just keep removing the first elements of my array again and again and that means that the deepest recursion would require n stack frames on the call stack like we said we can optimize this with some dynamic programming with some memoization if you did things correctly here you would get a runtime of just o event so linear and a space complexity of also o of n one thing to note for this one is if you really want to get the linear runtime out of this problem you're going to have to figure out a clever way to actually represent a logical shrinkage of your array in other words if you look at the nodes of my tree I'm representing the array and I'm chopping off some elements of the array at any point in time what you don't want to do is create many copies of the array because I know creating a copy of an array would itself run in a linear time if you're creating a copy within every recursive call it's going to be pretty inefficient I will actually save that detail for the implementation video and so if you're wondering how to exactly Implement that pattern you'll want to join me in the walkthrough video I think let's hop to it hey programmers Alvin here what I want to do right now is go over the Java solution for this non-adjacent sum problem so like we said in the approach video to solve this one we're going to solve it using some recursive Brute Force algorithm then apply some amylization on top of it and so to get the ball rolling here I'm gonna need a way to give myself the ability to look at different pieces of my input list here I know at any point in time I want to shrink my input list smaller and smaller toward my base case and so to set up that structure I think it's good to have access to like a starting index so I'm going to overload the method name here I'm going to give it another argument I'll say int I and this will represent the starting index of the sub list that I'm considering for example if I is the number two that means I should be analyzing the list starting at index two so index two all the way through the end that means top level over here when I call my helper method I'll call nine adjacent sum given the same nums list and then initialize I to be zero because you want to start considering the full list starting index 0 going through the end this will help us avoid any slicing or creating copies of the list as we go giving us a faster solution and so to get the ball rolling on our Brute Force let's consider some base cases here and so I know I want to check a base case if my list that I'm considering is empty right so I'm gonna check for me a logical like empty linked list would mean that my index I is at the end or past the end of the list here so I'll check if I is greater than or equal to num's dot size notice that here I'm technically checking if I is out of bounds of the nums list because I know the last valid index of a list would be size minus one so if that's the case what I want to do is return 0. for what I'm trying to be consistent with the return type of this method which would be of type integer and zero is definitely an integer and I'm returning 0 because it represents an empty sum because I know overall in the context of this problem I want to maximize the sum that I take and so with that let me also start forming my recursive calls and these recursive calls should really mimic the logic that we express when we drew the approach video tree right so we have really two options here I'll kind of lay them out well what you could do is take the number at the front of your list so for me the front of my logical list would be the item at index I so if you took that number you could say nums.get I and you want to recursively add it to the sum of the remaining part of the list that you can take from if you take the element at position I and when you call non-jacent sum they'll give him the same nums list but you want to manipulate I obviously I want to increase I giving myself like a smaller a logical list what you want to do is pass in I plus 2 here and so it's pretty clear why we're not just passing in the same old I well for one we already took the element that index I into our sum and we're adding it to our recursive sum here we shouldn't pass in I plus 1 because that would be a number adjacent to I right and if we take I right now we know we can't take I plus 1 later on because the whole point of this problem is you can't take two elements that are adjacent in the list and so the earliest number we could take from there would be I Plus 2. and this is a very indicative of the logic we expressed when we drew the tree so that's only half of the pattern here could also be a scenario where I don't take my current element at index I and instead I just do non-adjacent sum of nums and then I pass in I plus 1 here right so now I do have the option of taking the element that's right after I nice and I know that these two variables over here are these two expressions they give me back a number right they represent a sum what I want to do is now work in my max value logic I want to choose the maximum answer between these two choices right the choices you make are either you take your element index I or you don't take your element in x i so I'm going to choose the maximum between them for me I could just use the built-in math.max just takes into arguments and Returns the bigger value between them and now that I'm choosing the maximum between these two quantities you just want to return whatever that maximum is so this code's looking pretty good let's give this a test run so far really short logic but we do want to optimize this in a moment so we're passing our initial test cases and we're timing out test case zero four so we're in good shape here we know that you know the problem like this does have an exponential runtime so it's too slow to run but I can add some memosization logic into the mix here to improve that so like we're always used to should know this formula by now I'm going to bring in the hash map I'm going to pass it into my recursive method here when it comes to the structure of this hashmap its keys are always going to be like the changing arguments to my recursor method so I'll pass in a hash map here for me the keys need to represent my integer's I right so I'll make the key type integer corresponding value is going to be the return type of the method which is also integer so this hashmap Maps integers to integers and let me add my base case to check if a key already exists in the memo and for me the key is really the argument I right so if the memo contains the key of I then just return the stored value because I would have stored the subsolution previously so return memo dot get I now on the flip side I have to locate my recursive return value which is this expression over here and I want to store it in the memo before I leave right so I'll just save this thing to a variable I'll call it result I'm still going to complete the return value that way we don't change any of the actual arithmetic in this evaluation but I do want to save this result so before I leave I'm going to do memo dot put use your argument I the plain old I as their key make the corresponding value the result and always be sure to pass along that memo by reference into your recursive method here does that mean right here pass along the memo so I have that shared data structure and so just by adding this layer on top of our Brute Force let's give that a test run we should get a much better run time here cool and there we have it hey programmers Allen here right now let's go over the approach for the summing squares problem so the first thing we'll want to do is review what a perfect square is you can create a perfect square by just taking some positive number and multiplying it by itself in other words I can do one times one to give me one two times two to give me four three by three to give me 9 and 4x4 to give me 16 and so on so in this problem we're going to take in a number as input and we want to do is figure out the minimum perfect squares that sum up to our Target number so for this input of 12 the least number of perfect squares I can use would be doing four plus four plus four notice that this is a valid perfect square sum because 4 is of course a perfect square another way that uses perfect squares to add up to 12 would be nine plus one plus one plus one however that would be a longer way right I want to use the minimum number of perfect squares and so here I should return the answer of three and the reason behind it is because I do 4 plus 4 plus 4 which is three perfect squares all right so how can we break down this problem let's step through the example as if our input was 10. we're going to start at 10 at my root and what I know I have to do is get this number to be smaller and smaller because decreasing the size of our input would mean an easier and easier problem to solve so what I have to do is subtract different perfect squares from this 10. so what I can do is subtract one that'll give me 9 or I could subtract 4 giving me six and finally I could subtract 9 giving me one notice that there are no other perfect squares to try the next perfect square would be 16 but that would be too large for my 10. so I don't need to go over it over here let's say I now wanted to expand this nine node I would get children like this again branching for every perfect square that I can take out of that quantity and so on and so forth if we look at the right hand side of my tree I actually just discovered a way to create my input of 10. in other words I can look at this path since this path terminates in a zero that must mean that we have just found a way to sum up perfect squares such that we get 10. if I look at the numbers along this path I'm really saying nine plus one so let's expand this five node as well as this two node and we'll build the full tree for the subtree rooted in six that would look something like this so you can probably foresee that this tree grows very quickly and so we're going to avoid drawing the left hand side of the tree although now we know the core pattern that we can use to generate it so if I look at this sub tray I have a few different paths that terminate at zero right I can look at this path which represents another way I can create my input of 10 but I should obviously prefer a shorter path right if I count the number of edges within a path that would tell me the number of perfect scores I use to accumulate that sum and obviously the shortest path we should return here is two because we're using a nine and a one let's go through how we can actually code this one up so as always if I have this visualized as a tree I should be able to frame it as some recursion so in my base case if my number my input is zero then what I should do is return zero zero is a great return value because what we're saying is to create zero you need to sum up zero different perfect squares so I'm going to plug in that return value for all these Leaf nodes and as I return these values to their parents what I have to do is add one to them always that way I can start counting the number of edges so if I look at the very bottom right now the zero returns then I add one to it then it returns upward add one to it and one more time to get over here notice that I have a three over the three now which means that I need three perfect squares to create three which makes sense because you have to do one plus one plus one let's say we return at this four node since this node is receiving two different values what it should do is choose these smaller between the two right because this problem is asking us for the least number of perfect squares so I need to minimize here so I should prefer the zero what I should also do is add one to it to count the edge and so what I'm saying right now is there must be only one perfect square that I need to get a quantity of four which makes sense because 4 itself is a perfect square so I should be able to notice any correctness even as I evaluate these sub trees so we'll take some time to evaluate this further until finally at the sixth node we get a result of three and this three represents a few different paths we can take that are of minimal length so I think by now you understand the logic we need to evaluate this tree this tree is going to be a little large so I won't step through the full example we can already foresee the complexity of this though right whenever I have a tree structure like this I'm describing all the different recursive calls that I make so if I'm able to figure out the number of nodes in this tree that would tell me the time complexity that stems from the recursion what I know is the height of this tree is definitely going to be n right because the longest path from the root to a zero would be just by taking a minus one again and again right so the height of this tree is going to be n when it comes to the branching factor it's actually Dynamic so given a node we know that we Branch for every perfect square that we can fit inside of it we know that given a node n there would be square root of n different perfect squares so that'll tell us our total complexity we'll say that the time complexity is going to be the square root of n raised to the nth power like usual the branching factor of our tree is going to be the base of that exponent in this problem the base is no longer two right we were dealing with a lot of problems we just have a base of 2. now we have a branching Factor that's based on the square root of that number so that's why we say we have square root of n raised to the nth power the exponent of n of course represents the number of levels in this tree or the height of the tree in a similar way the spacing Plex is just linear o of n because of the height of our tree we know that we're going to need at most n stack frames in our deepest call stack and like you could probably guess this is actually going to be framed as a dynamic programming problem right what we can do is notice some overlapping sub problems looking at our tree you can capture a few I'll just point out this duplicate 5 node and of course as we grew our input larger and larger you would have more and more overlap so if you do things properly here and you implement memoization to capture the dynamic programming nature of this problem which you should be able to do is bring it to some sort of a multi-linear function overall your time complexity would be n times the square root of n interspacing Plexi would still be o of n I'm sure wondering exactly how we implement this one so maybe what you want to do is try to code it up on your own if you get stuck you can find me in the Code walkthrough I'll see you there hey programmers after construct be here what I want to do is go over the Java walkthrough for the summing squares problem so you definitely want to make sure you watch the approach video first and we'll Jump Right In Here we want to solve this one using a Brute Force recursion and apply some memoization on top of it so let's start with a base case here like we said in the approach video we know we want to deal with an input that's very small right for us we have integer inputs so we'll just check if our number n is equal to zero if our number n is equal to zero then we want to return zero because we know that generally our method should give us back the number representing the minimum the number of squares used to build up our n right if your n is zero that means you can use the empty sum right you can add up no perfect squares and you still get the correct answer of zero so that's the logic behind our base case here but now the recursive case is much trickier we know we want to have the logic of subtracting out some perfect squares from n that gives us a smaller and smaller argument so I'm going to give myself a loop that just iterates over some possible squares so what I can do here is I can iterate for it's I equals one and I'm starting at 1 because I know that one is the smallest perfect square right so I might as well start there I'm going to iterate up to I less than or equal to the square root of n and then hit every I in between I plus equals one cool that's because as I evaluate this Loop what I'm going to do is take my integer I am going to create a square number out of it a square is just the number multiplied by itself notice that on the last iteration of this for loop I know that I is going to be exactly the square root of n so when I do I times I I'm definitely going to get the full value of N and this could be the biggest number we ever subtract out of our argument n here nice and so with that out of the way we want to do is now build our recursive call so I'm going to call summing squares and I'm going to do n minus this choice of square that I have over here we know that this recursive call is going to give us back the minimum number of squares required to sum up to this quantity right I'll call that my int num squares however if I wanted to figure out the number of squares to build up for our argument n we need to add 1 to that sub quantity right that's because this one over here corresponds to the single Square I have on line 9. nice and then I know I need to find the minimal sum and so what I want to do is some Min value logic here so I'm going to do int I'll say Min squares and here it would be nice if I can use some like Infinity value because I want to do Min value logic overall and so unfortunately like integer type doesn't have a built-in infinity and so what I'll do is I'll actually create this as my recursive helper and so the main method will have the original signature but my recursive method I'll think I'll make it actually return double because then I can start defaulting these values over here right so for line 13 I can make this default to double dot positive Infinity and I get some safe comparison over here right so I can say things like hey if this number of squares is less than the Min squares and on the first iteration this is guaranteed to be true because Min square roots is positive Infinity then you can go ahead and replace them in squares with that value then after that full loop is done running like you expect we return whatever Min squares is and since we're storing positive Infinity in this variable over here this should be of course type double which means that now we're summing squares recursive method is returning a double which is totally fine however when we actually call this helper method in our main method here we know that this call to summing squares that's actually going to give us a double I want to just cast it into an INT like so I'll pass along the same end here do bear in mind that right now because these methods of summing squares although I want to overload them they will probably get a conflict here because they both take in the same types of arguments and the return type is kind of ambiguous here so just for now I'm going to rename the helper method I'll call it underscore or something Square so that represents my recursive helper method nice and so with that let's give this a run here I'm just getting a little reference here for the typing this should be positive in fin it t and while I'm here I also noticed that when I add one to the results of the recursive method here that of course gives me back a double and that's because the method returns a double I'm adding one to it which should still give a double let's give that a test run nice and this looks like our Brute Force recursion is starting to time out though on test case zero six so you know the drill at this point we have our Brute Force let's add our memosization into it so I'm going to start by importing the hashmap and I'll pass it along to my cursor method here so it'll be a new hash map I'll take in this argument here so hashmap keys are going to be just the numbers n so integer corresponding value right now is going to be double I'll call that my memo and we'll add a base case like we always do if our argument n is in the memo so if memo dot contains a key of n then return ammo.get and right return the stored value for it then I need to locate where I call My Method recursively which is over here be sure to share the memo and then whenever you do your return value in the recursion you want to store that result before you leave right so here I return Min squares I'll want to save that in a variable I'll say result equals mint squares I'm going to still return that same old result but before I leave I store it in memo so memo dot put use the original argument as the key right so I just use n here make resolve the value nice and so now that the overloaded version of this method has a different argument of hashmap it should be unambiguous now so I'm going to actually change the name here it's just a summing squares right it's easily to identify now because there's two arguments for the recursive version right only one argument for the main version here so let's give that a test run always solving these dynamic programming problems and layers great there we have it hey programmers Alvin here right now let's go over the approach for this counting change problem so this problem we're going to be given two arguments we're going to be given a Target amount as well as an array filled with some coin values what we want to do in this problem is return the number of ways that's possible to make the amount given the coins in the array and we can reuse the coin value as many times as we want and so for this particular example let's go through the ways we can make an amount of four one way would be to use just a bunch of one cent coins or you could do a three plus a one you can also do a two plus a two and finally you can use one two cent coin and then two one cent coins and so that means there are four distinct ways to generate our amount so let's Trace through an algorithm you can use to solve this one we'll start by structuring the different decisions we can make when it comes to building our amounts of four so I'm going to use four at the root and like we're used to let's go ahead and Branch for every coin value that we have available in other words what I could do is take a one cent coin in which case I reduce my target amount from four to three or I could take a two cent coin in which case I have two cents remaining or I could take a three cent coin in which case I have one cent remaining you've seen this pattern a few times in the course already if we built out the full tree we'd end up with a structure like this notice that we terminate wherever we have zero because that must mean we actually successfully built our Target amounts we know that a zero Leaf would represent one of the ways to create our mount looks like we have too many zeros here you're going to see that we have seven zeros but we said that there are only four ways to create our Target amount let's start by interpreting one of these paths so let's say I looked at this path this path will represent me taking coins one plus two plus one and if I look at another path like this one in pink this is represent the way of taking two plus one plus one if we look at those two paths they actually represent the same coins right I'm using a single two cent coin and then two one cent coins I just took them in a different order and that's why we have a high count right now we're actually counting duplicate ways and so I don't want to return seven although my tree says that I should really return four so actually structuring our tree like this is not going to be the way to solve this problem so what would be a better way well we can still use our tree structure so we're going to break this one down recursively but we want to build it in a way where we don't have any duplicate paths right and so what we'll do is starting at the root of our tree we're going to make a decision for just a single type of coin so at this top level of my tree I'm only writing a decision for my one cent coins and so for this coin with a value of one what I'm deciding on is how much of this coin to take so I could take zero one cent coins in which case my quantity that I'm targeting my target amount still stays at four or I could take a single one cent coin in which case my amount is now three if I take two one cent coins then now my amount is two and this would just carry further until I've exhausted all the possibilities for my differing quantities of one cent coins so notice here along the edges of my tree now I'm denoting the quantity of the coin I'm taking and at this first level I'm taking coin one what I can notice immediately is I already have a node that terminates at zero so this must mean that represents one way I can generate my amounts of four and what this path represents is really me taking four one cent coins and on the next level of the tree I'll wanna do is make the same decisions but for our two cent coins so let's say I wanted to expand this note of four what I do is Branch for different quantities for my coin value too so I can take zero two cent coins one two cent coins or two two cent coins and that would give me four two and zero as my reigning amount respectively so we're gonna need some more room here our tree's getting a little wide what I can do is notice this amount of one since I'm trying to decide how many two cent coins to take I actually can't take any two cent coins out of that amount so this darkened node basically is going to be a dead end so we can effectively ignore it that's going to be true throughout this tree whenever we have an amount that we can no longer shrink we actually don't need to expand that node anymore and so let's reorganize things over here now let's expand this node of three and again I'm branching for different quantities of two cent coins right so I can take a zero two cent coin or I can take just one two cent coin which case I result in amount of three and are amounts of one I'll carry this further for the other nodes at this level notice at this point we've just encountered more zero amounts which means they represent other ways to create our Target so so far we've counted three distinct ways to create our initial Target amounts of four finally at the bottom level we choose different quantities for our coin value of three notice that some of the leaves here don't terminate in a zero which means that they don't represent valid ways to make my initial amount what I can notice at the bottom level though is I have an additional zero this would actually give me all of the four different ways I can create my target amount so the key pattern here is we want to make sure that up front we choose different quantities for a single coin value before moving to the next coin value altogether what I don't want to do is flip back and forth between different coin values because then I would end up looking at duplicate ways if you think about how we have the tree structured now we have a very short tree right this tree's height is just going to be the length of the coins array because at every level of this tree I'm choosing for a different coin value so although my tree is very short I actually have now a very wide tree because now I'm iterating through differing quantities it's like you can probably foresee we can totally structure this problem like a dynamic programming problem meaning you could spot duplicate subtrees here let's take into account the shape of our tree to come up with the complexity of this so if we implement this wisely with some dynamic programming via some memoization we should end up with a time complexity that's a multi-linear so just a times c and a space complexity that's also a times C we say that the time complexity is a times C because is a is the width of the tree and c is now the height of the tree and in general the number of nodes would be the height times the width the space complexity is also going to be a times C because of the different keys we're going to need to put inside of our memo hash map you're probably wondering exactly how we implement this and why the complexity is the way it is and to do that we're going to actually have to implement the code together so at this point you'll want to join me in the walkthrough videos I'll see you there hey programmers welcome back what I want to do right now is go over the Java walkthrough for this counting change problem so in this problem like we said it's going to be a variation of our you know coin changing problems and what we want to do is this time return a number of ways that we could generate our Target amounts like we said in the approach video the thing to watch out for here is to make sure that you don't count any duplicate ways and so the structure of this recurs is going to be a little bit different I'm going to need an additional argument into my recursive method here and so I'm going to Define it down below it's going to have mostly the same signature I'm still going to take in the amount as well as all the option of coins I'm also going to take in an index I'll call it coin index this is going to represent the index of the current coin I'm going to consider which means top level over here when I call my recursive method I'm going to give in the same old Target amount I'm going to give it an initial coin index of zero and of course pass along the original choice of coins here and so what I get to do now with this coin index is now vary the quantity that I'm going to take the coin of the given index like we said the approach video we want to count the number of ways to generate the amount so recursively I want to be reducing this amount over time toward my base case in other words once my target amount is zero I have to think about how many different ways can I give back zero cents and the answer there is one right there's exactly one way you can give back zero cents and that way is to do nothing right so this one represents me counting a valid way right there's one way to make zero sense good and then from there what I want to do is now iterate over the possibilities so I know that given this coin index if I use it to access some value out of the coins list I can do coins.get coin index and I'm going to create a variable to store it I'll call it int value so this is the value of the current coin I'm considering so if I take a look at the first example in the event that coin index is zero that means my value is one it's like a one cent coin in the case that my coin index is one that means the value I get is two what I want to do is take varying amounts of this coin value so I'm going to start iterating here and this Loop is going to be different from our previous coin prompts in that we want to iterate over a different quantity right so I'm going to say int quantity if I think about what the lowest quantity of a coin I can take is well the answer there is zero you could take no instances of a coin and I know I'm going to increase that quantity over time to go through the possibilities but I have to think about how far I need to go what I want to do is iterate this Loop while the quantity times value is less than or equal to the Target amount so here I'm checking that my quantity times value is less than or equal to the amount because I don't want to overshoot my amount so for example let's say that right now my coin index is 1 right so that means I'm looking at the element of 2 over here right if I do my quantity times the value I have to think about what's the most number of two cent coins I can take right now if my target amount is four right well in the first iteration this is going to be valid because I'm going to check if 0 times 2 is less than or equal to 4 right and that's true so I keep running the iterations I'm going to check if 1 times 2 is less than or equal to 4. that's still true then I check if 2 times 2 is less than or equal to 4 and that's still true but on the next iteration when my quantity is 3 I'm going to do my 3 times 2 which is 6 and that's no longer less than or equal to my target amount of four because I don't want to take out six cents for my target of 4 cents that'll give me a negative quantity right so this condition ensures that I only iterate up to a valid point here so what I want to do now is generate my sub amount so I can do my int sub amount and I'll make that equal to the original amount but just minus the quantity times the value right I'm reducing the amount by the number of coins that I'm taking then from there I have this reduced quantity I want to call recursively on Counting chain now given that sub amounts and because I just made a choice for how many instances of this coin index I'm going to take what I want to do is now move to the next coin so here's where I increment my coin index so coin in X plus one right notice that this for Loop is going to iterate through all the possibilities for my given coin index and once I make a choice of that coin index I can never go back to it and so that's why I increment my coin index in the next recursive call along with that I can pass along these same coins right that doesn't change awesome now I have to think about the logic of my my problem here I know that in the approach video I wanted to have the effect of taking a total right I wanted to add up the sum of all of the branches through my tree so I know that counting change is going to return an integer that integer represents all of the ways that I can generate these sub amount so what I want to do is take the grand total of that so I'll say int total ways equals zero and I'm going to add the results over here nice so I'm getting the grand total number of ways and after my for loop I just want to turn the total ways just a little type over here I should be saying total ways so this looks mostly good except I should consider also adding a base case regarding my coin index in other words what if it's the case that you actually exhaust all of your different options for your coin index but your amount is still not zero so let's say after this if statement if I get past this if statement I know my amount is not zero right I also want to check hey if my coin index has no other options in it in other words if my coin index is greater than or equal to coins dot size then I have no more options right I know the last valid index of coins is coins.size minus one so if coin index is equal to coins that size I know I don't have any more coins I can possibly take so if you hit this case you want to return zero right there's no possible ways to generate your amount from this point because you already chose all of your quantities for your different coin indices nice the order of these conditions is really important right because I have this if statement of line 13 after line 9 this is technically checking all right if my amount is not zero and my coin index is out of bounds right and I'm able to accomplish that logically by the order of these two conditionals so what the let's give this a test run this could be our initial Brute Force solution looks like we're going to timeout nice because we get that not so great exponential runtime here so like where you see we'll go ahead and memorize this right so I'm going to bring in my hashmap and I'll be sure to pass it in over here it's our new hashmap when it comes to designing the hash map over here I have to think about what the keys need to be as always the keys need to be the changing arguments through my recursive method and here it's actually interesting that two arguments change right my amount changes because I have some reduced sub amount that I'm passing along and also my coin index changes because from one call to the next it would be increasing the coin index and because those arguments change during the recursion those are the ones I want to encode into my hash keys right so my keys here will actually be a list of integer I'll just make sure that that sub list or those sub lists just contain a pair of a Mountain Coin Index right corresponding return value is going to be integer so integer will be the values of my map I'll call that my memo nice so what I'm saying is I'll enter the base case and I'll form my key I'll just say list of integer it's going to just be a list of the amounts followed by the coin index I'm going to use this entire pair as the keys in my memo so I'm going to check if my memo contains a key a key then I want to return its stored value so return memo dot get key because that means I've seen this is a problem before so I can return the previously saved subresult and now what I want to do is make sure I pass along this memo by reference through the entire recursion and also be sure to store your recursive return value into the memo before you leave so that would be line 31 here what I do is I can say memo dot put you always want to make the key for your stored value the original key that encodes the arguments right so a Mountain Coin index are part of my key here so I use that in my memo and I store the total ways then just be sure to return the old value so return total ways all the same right that shouldn't change so with this let's go and give this a test run we should now be using our memo to solve this dynamic programming problem quite quickly see what we get awesome and there we have it hey programmers so you've reached the end of a dynamic programming crash course but the learning doesn't stop here if you head over to structney.net you'll be able to practice some dynamic programming problems further we have a full module on dynamic programming a lot of the problems that you've covered not in this video series for free code cam but I have a lot more in store as well so whether you're looking to really hone in on your skills of dynamic programming or you want to cover and go through all the other topics we have featured on structi I recommend you head to structie.net you're going to have access to video tutorials as well as animations with me for every single problem I'll see you there "
    },
    {
        "title": "4.9 Longest Common Subsequence (LCS)  - Recursion and Dynamic Programming",
        "link": "https://www.youtube.com/watch?v=sSno9rV8Rhg",
        "transcript": "hi the topic is longest common sub sequence in short lcs in this video I will explain what is the problem (LCS problem) then I will solve it using recursion I will write an algorithm and show you how it can be solved using recursion Then Recursion are time consuming So to save the time We can use memoisation                                                                                                 'e' has appeared here then 'c' should be following that 'e' not at that backside of 'e'                 instead of starting from 'e', I will start from 'c' yes, matching. 'd'- yes matching. 'g' and 'i' - yes. c-d-g-i is also there         sub-sequence I'll take one more example and show you                                             which are the same length yes there can be multiple sub-sequences of the same length also so that's it- the problem is finding whether the set of characters in these two strings are matching or not                                                                         and 'A'         This is one call where       Otherwise- one more is                                                         trace the other nodes also they are not the same                                                                                                     A[1] and B[3] and this is d,d and here it is 1 + A[2] and B[4]                     exponential time-taking algorithm         this is a top-down approach   here- there is an overlapping problem                   to improve recursion you can take the help of memoization   overlapping, but if a problem is big with a lot of branches will be overlapping. So let us finally understand how memoization can make this algorithm faster. I will not change the code a table and show you how memoization can help this one.     for memoization     and I have taken the indexes from 0, onwards. Now let us see how this algorithm can utilize this table to work faster. So first we will start from [0,0], then [1,0], then [2,1]                                                                                                                                                                         no- they are not matching so take the maximum of these two. This condition. So- that is 0,0 is 0 Then B is matching with this one. Yes- matching. 0 + 1 ... 1 then         B and D they are not matching so previous column with previous row- here - maximum of this that is 1 only. Now next row           maximum of these two                                                                                                                                                 and the maximum of these two is 2.   N is matching here     add one two so when there's a match, take the diagonal add one then E   previous column, previous row - two. previous column, previous row - two. Now here, E is matching with this one                                                       LCS algorithm using dynamic programming is m cross n that's it the matching characters need not be continuous and you can reduce its time. D A Not matching. E is matching here "
    },
    {
        "title": "46 Dynamic programming on Trees Introduction and Identification",
        "link": "https://www.youtube.com/watch?v=qZ5zayHSH2g",
        "transcript": "Hi, so now we are moving on to the next chapter which is dp on trees, right? okay so now let's see the flow that how we are going to read and this is very important you must have heard the name of diameter of tree question right? if you haven't heard then listen to it because this is a very important question and this is important because this is the first question of our type dp on trees is the first question the most basic question and this is a different question in our type that's why this is important so basically what we are going to read in dp on trees that we are going to apply dp in trees we are going to apply dp in trees this is a tree how can we apply dp in this we will see that before that let's see what we are going to read so first of all we will read its general syntax that what will be the general syntax of dp on tree that how we can solve any question by using this syntax then we will see that basically how we are going to identify that trees that in this question dp will be applied in this question dp will not be applied how we are going to identify that then we will do some questions I have chosen 4 questions on which dp on trees is used okay so I have grouped it together so that you can understand what is the general syntax of dp on trees and the same syntax I will write one syntax here and that same syntax you can change and do all the questions this is the theme of my channel that I teach one syntax and teach many questions so I am doing the same for all so the first question is what is the diameter of binary tree this is a very important question if you haven't seen it, you can see it and then what I will teach maximum pass term from any node to any and diameter of n-ary tree diameter of n-ary tree is very difficult to understand but it is a good question so I will teach it in n-ary tree okay so where we will start we will start from here that how we are going to identify the first question we don't know that in this question dp will be applied or not, we will understand tree question we don't know that tree question is there or not tree is simple node star root is different we will know that but we don't know that dp question is there or not in this tree question we can apply dp or not right so we will start from how dp can be applied to trees from identification after that in next video I will teach you the general syntax after finishing the general syntax we will use the general syntax right so let's start the identification let's start the identification identification identification right so how to do identification sometimes what happens let me give you an example let me introduce you the diameter of tree right let me introduce you the diameter of tree because I need this question to teach you the identification let me give you a tree let me make a tree ok so let me make a big tree this is a tree so I have to find longest path in this tree between two leaves so I have to find longest path between two leaves so if I see this leaf and this leaf so this will be the longest path 1,2,3,4,5,6,7,8 8 so if you see more longest path in any other leaf let's say this leaf and this leaf 1,2,3,4,5,6 1,2,3,4,5,6,7 1,2,3,4,5,6,7 so this is the longest path I hope you understood so we have to find longest path in two leaves this is one leaf node and this is another we have to find longest path so basically do you understand that for any leaf node this longest path is not necessary to pass through root this is not necessary to pass through root let's consider one more thing when I will come to this I will explain this so for now I will take one more example and try to cover this so that I can increase my identity so here longest path is between this node and this node I have removed it which will go from here you can see this path here it was this path are you understanding so here it is not necessary to pass from here so how to remove basically for every node if I check for this node in this node maximum height of left tree will come from here so I will add 1 so I will get answer 1,2,3,4 1,2,3,4 so total will be 1,2,3,4,5,6,7,8 so it will be 8 so it depends on height so what I am saying for every node I will check left tree and remove left height and remove right height so to remove diameter I will get enough resources to remove this resources so what I have to do I have to cover this tree I have to traverse this tree it is not necessary to pass from node if it was passing from root I would have removed left height and right height but sometimes it is not passing from root so for every node I have to remove left height and right height to remove height it will be O of n so I will do this for every node for example, I will remove left height and right height for every node I will do n time so height will be O of n to remove height and I am doing n time so it will be O of n square so you can understand repetitive work I have removed height so I will remove height for every node I will traverse this tree and I will remove height so it will be O of n square so what I want I have to do this repetitive work for every node and after every node I have to remove height and height basically I am doing repetitive work I am traversing every node and removing height I don't want to do repetitive work so I want to store height so I will use this whenever we talk about store we think about DEP so in this way if you think that I have to traverse whole tree so first tree traverser will be O of n and for every tree I have to do this which is O of n basically O of n square so as you can understand I have to traverse every tree and for every node I have to do this O of n so I hope you understand how to identify whenever you have to traverse whole tree and for every node you have to do this and after every node you have to do this and after every node you have to do this so basically if you want to store value of every node you can use DEP diameter of tree can you understand diameter of tree is longest path between two leaves now I will start next question next will be my general syntax from where we will start reading main ok you have done one more yes so in next 3-4 questions it will be very easy right so thanks for now we will study syntax in next video"
    },
    {
        "title": "I gave 127 interviews. Top 5 Algorithms they asked me.",
        "link": "https://www.youtube.com/watch?v=EM8IgIIiOdY",
        "transcript": "Bellman-Ford algorithm, A* algorithm and Floyd\nWarshall algorithm. If you have never heard about any of these,\ndon\u2019t worry about it. You see, I have interviewed at all these companies\nand got offers from Google, Facebook, Amazon and some others. If there\u2019s one thing I have learnt from\nmy experience, it\u2019s this. You do not need to know every algorithm in\nthis world to crack coding interviews. In most interviews, they are asking you very\nsimilar kinds of questions. And if you have heard of the 80-20 rule or\nPareto\u2019s principle, you know that 20% of algorithms will be asked in 80% of the interviews. In this video, I will tell you the top 5 algorithms\nI was asked in my interviews so that you can pick the top 20% algorithms by yourself. I will also share exact problems where these\nalgorithms can be applied. This video is going to be very information\ndense. At number 5, we have the \u201ctop k elements\u201d\nalgorithm. \u201ctop k elements\u201d algorithm shows up in\nmany different problems. Finding k largest or smallest numbers in an\narray or finding the k most frequent numbers in an array are some examples where you would\nneed to know this algorithm. It also shows up in some \u201cSliding Window\u201d\nproblems. We will cover \u201csliding window\u201d shortly. For the purpose of this video, let\u2019s look\ninto finding k largest numbers in an array. Sorting the array and taking k largest elements\nis one way of doing it but it\u2019s not optimal because the big O of doing this would be nlogn. That\u2019s why, in the \u201ctop k elements\u201d\nalgorithm, we use a heap data structure to track top k largest numbers. Now if you don\u2019t know what a heap is and\nwant me to make a video on the top 5 most asked Data structures, let me know in the\ncomments. For simplicity, just know that a heap makes\ngetting the maximum or minimum number very efficient. In the \u201ctop k elements\u201d algorithm, we\nadd the first k numbers of the array on a heap. For every number after that, we put it on\nthe array and right after doing that, we remove the minimum number from the heap. This way, we maintain the heap size of K and\nthe heap always contains the largest K numbers we have seen so far. This step of adding and removing the number\nfrom the heap has a big O of logK and we do this for every number of the array which is\nn times. So, the big O of the \u201ctop k elements\u201d\nalgorithm is nlog(K) instead of nlogn. At number 4, we have the \u201cSliding window\u201d\nalgorithm. This algorithm shows up in many problems like\nLargest Substring without repeating characters, Maximum Sum subarray of size k and Largest\nsubstring with k distinct characters etc. Here, we will learn the \u201cSliding window\u201d\nalgorithm using the Largest Substring without repeating \ncharacters problem. You can pause the video if you need some time\nto understand the problem better. In the first step, we initialize two pointers:\nleft and right at the beginning of the array. Now, we increment the right pointer to expand\nthe window between left and right. As we do this, we store the information of\nall the characters present inside the window. We keep incrementing the right pointer and\nupdating this information until we find a character that\u2019s already present in the\nwindow. We have reached the maximum window size because\nthe right index can not be part of this window due to the repeating character. So, we will update the answer and start shrinking\nthe window by incrementing the left pointer until the repeating character goes outside\nthe window. As we increment the left pointer, we will\nremove the characters that are no longer there in the window from the stored information. Once the left pointer reaches its final state,\nwe start incrementing the right pointer again to expand the window and repeat this process. To help you understand this algorithm better,\nI will provide the link to this code in the description. At number 3, we have Backtracking. In Backtracking, we explore all possible solutions\nby building them step by step. When we reach an invalid state, we backtrack\nor go back and start exploring other possible solutions. Backtracking is usually implemented using\nrecursion. I know that none of this makes sense right\nnow. So, let\u2019s understand backtracking with the\nhelp of this very famous problem called Combination sum. In this problem, you are given a list of positive\nnumbers and a target sum. You need to pick some numbers from the list\nso that they add up to the target sum. In the end, you have to return all unique\nways or combinations that satisfy this condition. You are allowed to pick a number more than\nonce. In this example, 2, 3 and 3 add up to the\ntarget sum of 8. So, it\u2019s one of the combinations in the\nanswer. Pause the video if you need more time to understand\nthe problem. Let\u2019s create different combinations from\nscratch. We start at index 0 with an empty combination\nand current combination sum of zero. Wherever the total sum of a combination is\nmore than target, we backtrack or return because adding more positive numbers to the combination\nwill only increase the combination sum and can\u2019t lead to a valid answer. If the combination sum is the same as the\ntarget, we add it to the answer and return. Otherwise, for every number that comes after\nthe current index, we add it to the combination, update the combination sum, update the current\nindex and call the function recursively. Updating the current index ensures that we\nonly get unique combinations in the answer. I will link this code in the description for\nyou to check out. Backtracking is used in many problems like\nWord Ladder, Permutations and Sudoku Solver. At number 2, we have Dynamic Programming. In Backtracking, we explored all possible\nsolutions from scratch piece by piece. In Dynamic programming, we are more thoughtful\nabout the solutions that we explore while still building our solutions from scratch. And we do this by breaking a problem into\nsmaller subproblems. Let\u2019s take the example of Combination sum\nand see how we can solve it with Dynamic Programming. The problem asks us to find all possible unique\ncombinations that add up to target sum using all the numbers or candidates. But let me change this problem a little bit. Imagine that I give you all the combinations\nthat add up to target sum, target sum - 1, target sum - 2 using all the given numbers\nexcept the last one. And now, I will give you the last number. Can you use this new information to find all\nthe combinations that add up to the target sum using all the numbers? You can pause the video and take a moment\nto think. You can start from the left. Until you reach the target sum equal to the\nlast number, do nothing. For the target sum equal to the last number,\nyou can simply add the last number by itself as a new combination. For the target sum equal to last number +\n1, you can just add the last number to all the combinations that add up to 1 and all\nthose combinations would now add up to the last number + 1. Add the last number to all the combinations\nwith target sum equal to 2 and all those combinations would now add up to the last number + 2. And you can keep doing this until you reach\nthe target sum. And voila! You have found your answer. If you look at the code, you keep track for\nall sums from 1 to target with this array. For target sum equal to 0, add a combination\nwhich is an empty list. Now start with the first number and keep adding\nmore numbers with this for loop. And for a particular target sum, just add\nmore combinations by using all the combinations for target sum - current number. I will leave a link to this code in the description. At the very top, we have Breadth First Search\nand Depth First Search. I have kept them together because both of\nthem are used for graph traversal and are very similar. Let's start with Depth First Search or DFS. In DFS, you start from a vertex and explore\nas far as possible along each branch. If you reach a point where there is no unvisited\nneighboring vertex to explore, you backtrack and try to find another branch that is unvisited. In BFS, you explore the neighboring vertices\nfirst before moving onto the other deeper univisited vertices. DFS is implemented using a Stack whereas BFS\nis implemented using a queue. That\u2019s because in DFS, you want to explore\nthe neighbors of the last vertex that you visited first. So, you want Last in First Out which is what\nStack does. In BFS however, you want to explore the neighbors\nof the first vertex you visited first. So, you want First in First out which is what\nQueues are for. I will link a couple videos in the description\nthat explain this in much more detail. BFS is used to find the shortest path from\nVertex A to Vertex B. Another famous algorithm that does the same is Dijkstra\u2019s algorithm. An algorithm that is closely related to DFS\nand is a must for coding interviews is Topological sort. I recommend you to read Dijkstra\u2019s algorithm\nand Topological sort on your own. To master all the algorithms we discussed\ntoday, you need to have a deep understanding of Data Structures. And you can not crack coding interviews just\nwith these 5 algorithms obviously. If you want to know how I mastered Data Structures\nand Algorithms, watch this video. My name is Sahil and I will see you in the\nnext one. "
    },
    {
        "title": "Most Common Concepts for Coding Interviews",
        "link": "https://www.youtube.com/watch?v=UrcwDOEBzZE",
        "transcript": "coding interviews are hard so much so that there's nerds out there solving hundreds of leak code problems just to get ahead but is that really necessary do we really live in a world where you need to solve Cherry pickup a three-dimensional dynamic programming problem just to get a job I don't think so yes technically anything can come up in an interview but I think there's a smarter way to prepare why not prioritize the concepts that are easiest to learn but also are most likely to come up in interviews Well because most people don't know what those are but with my background I think I do arrays are the first data structure that we all learn about and that's because they're simple but there's surprisingly a lot of non-trivial algorithms relevant to arrays I'm not just talking about binary search and sorting but also two-pointers the sliding window and if we want to get fancy we can even do some pre-processing by Computing the prefix sums of an array to solve certain problems more efficiently and the good thing is most of these algorithms are actually not very complicated once you understand them but if I were you I wouldn't just understand them I would get so good at them that solving a simple binary search or a sliding window problem feels as easy as writing a for Loop even if that means you have to go back and resolve the same easy problem multiple times a lot of people will struggle with more ult problems and that's because they don't have a really really good grasp of the basics and actually arrays are so all-encompassing that many other patterns can also be applied to them like Stacks greedy algorithms and of course everyone's favorite dynamic programming another broad concept is recursive decision trees you might be thinking doesn't the specific pattern actually matter like recursion can be applied to trees it can be applied to backtracking well yes no one is born knowing those Concepts you'll have to learn them but if you have a very strong fundamental understanding of decision trees you can solve a wide variety of problems from binary trees backtracking problems combinatorics dynamic programming and sometimes even graph problems if you've gone through the N code 150 list or road map and watched my videos you've probably got tired of me talking about decision trees decision tree decision tree decision tree so we have but that's because there are such an easy way for us humans to understand the intuition of complex algorithms graphs are a massive topic it's literally a sub branch of mathematics that's why some of the craziest problems you might have seen are graph problems but at the heart of graph problems are two relatively simple algorithms DFS and BFS you probably first learned about these algorithms with binary trees because trees are just a special type of graph but I really can't overstate how important these two algorithms are you should definitely be able to apply these two on both Matrix graphs as well as adjacency lists because even though you may be implementing the same algorithm depending on the structure of the graph the code can be quite different but again don't just get surface level knowledge I would recommend you to really understand them like you should be able to tell me what would go wrong if I removed any of these lines of code without this we might get an index out of bounds error without this one we might get stuck in an infinite Loop without this one we might overcount the solution I know some people will say who cares this sucks it's not relevant to my job anyway and that's a fair point but I don't think it's bad to be able to deeply understand a pretty fundamental algorithm like depth first search The Forbidden Jutsu of the algorithm's world is definitely the hashmap whether you're using it to count the occurrences of characters in a string or using it to build an adjacency list for graph problems it's almost certainly going to be useful in your interviews there's not much to talk about because thankfully hashmaps are pretty easy to use but if you're struggling to optimize your solution the first question you should ask yourself is would a hashmap be helpful here heaps are also pretty simple they have a sorted property either as a minimum Heap or a maximum Heap they support log and time insertions log and time removals of either the minimum or the maximum element constant lookup time and lastly heapify can transform a set of values into a heap in O of n time that's relevant because it's more efficient than inserting elements one by one if you're given all the elements up front we can't end this video without talking about dynamic programming we all know that it's difficult to learn but it's not as common as people think it is I would definitely prioritize it after all of the other Concepts I've talked about in this video but if you are going to learn it I would mainly focus on the most common and famous dynamic programming problems like the longest common subsequence problem the coin change problem and several others that are included in the neat code 150 list yeah it's theoretically possible you'll get asked a question like Cherry pickup 2 yeah Cherry pickup 2 because the first one wasn't hard enough but let's be honest even if you've literally solved this problem before there's still a high chance you won't be able to solve this in a real interview but that's all I really wanted to talk about I see a lot of people nowadays solving hundreds and hundreds of problems and there's nothing wrong with that but if your goal is just to prepare for interviews and maximize your chances with the least amount of effort possible like doing a reasonable amount of preparation I would highly recommend focusing on the most important Concepts that I talked about "
    },
    {
        "title": "Top 6 Coding Interview Concepts (Data Structures & Algorithms)",
        "link": "https://www.youtube.com/watch?v=ft0owvS5tQA",
        "transcript": "hey everyone welcome back and today let's do something a little bit different let's talk about the top six coding interview concepts that you need for interviews and by top six i mean the top six most common at least in my experience i think some people might disagree with a couple of these but overall these are definitely not controversial i think generally speaking these are six of the most common uh you know things that come up in interviews and spoiler alert dynamic programming is not gonna show up on my list for how difficult dynamic programming is and how much it's talked about it actually doesn't show up that much in interviews i think it's kind of funny people spend so much time studying that because they think it's really difficult and they feel like it's definitely going to show up in their interview well chances are it's actually not going to show up in your interview there's a lot of companies that have actually banned asking dynamic programming questions and even the ones that do ask it don't ask it super frequently so i think your time would be better invested studying some of these other more common patterns and concepts and definitely feel free to let me know if you'd like to see more videos like this or maybe other videos i've seen a lot of suggestions for people asking about my google interview experience and other videos like that so feel free to suggest it but okay now let's get into the top six list let's start with number six and that is going to be a data structure called a heap you may or may not be familiar with heaps but they are a very common data structure that comes up there's some problems where actually the entire problem itself is just using a heap like okay you know there's some operation you're trying to do maybe you're trying to get the minimum value or the maximum value or one problem that comes up very frequently is the top k values or something like that and that's really what a heap is designed to do because with a heap there's two variations a minimum heap and a maximum heap if you were doing a minimum heap for example you could get the minimum value from the heap in big o of one time which is very efficient but when it comes to actually popping that minimum value or adding a value to a heap that is done in log n time which is also very efficient one thing about the heap that i see a lot of people get wrong and even i've had interviews where the interviewer didn't know this and it was kind of an awkward situation because i was trying to explain my solution but it's that if you're building a heap you have 10 values or n values let's say and you're building a heap you can build that heap in big o of n time as long as you have all the values available from the start you can build the heap and big of and time but if you're actually manually adding each value to the heap you don't have them available all at once but you have to like you know go through some kind of data stream to add each value to the heap then that will take n log n time because adding a value to a heap is log n if you have to do that n times that's how you're going to get that time complexity but heaps actually also show up in a lot of standard algorithms like graph algorithms shortest path algorithms and things like that so i think it's a very very good data structure to definitely understand because the implementation is a little bit complex but usually you don't have to implement a heap you can just use it and it's very easy to use this data structure okay next up is sliding window when i actually first learned this algorithm i didn't even know it was a standard algorithm i was just doing some leak code problems i couldn't figure out the problem so i looked at the solution and saw okay there's this algorithm where you use two pointers to iterate through a array and i remember thinking wow this is a really clever technique if only i had known that it's actually a very standard algorithm it would actually have been easier to understand because this is the type of algorithm you can memorize and then apply it in many many different places the idea is usually that you know to solve some problem you have to iterate through a array n times so if you have to do that n times the overall time complexity becomes n squared but there's a lot of problems where you can have two pointers and then use them kind of intelligently and in that way you only end up iterating through the entire array once well twice if you count the two pointers but that's still big o of n time you don't have to do nested for loops with a sliding window you just keep track of two pointers you increment them in an intelligent way and then you get a very efficient algorithm we've done a ton of sliding window problems on this channel so definitely take a look at the sliding window playlist if you want to see some examples the next algorithm is going to be binary search i think every cs major will learn this algorithm and usually think it's pretty simple at least conceptually right the whole idea comes from you know if you were guessing a number between one and a hundred and you got some kind of feedback right like if you got the wrong answer you knew if it was too high or too low of course if you were guessing between 1 and 100 you would guess 50 because if it was too big then you would eliminate all the numbers that are smaller than 50. if it's too small then you'd eliminate all the values larger than 50 and then just continue to do that just take the halfway point between whatever you're trying to determine so in that sense it's a very simple algorithm usually binary search problems are really obvious that you're supposed to use binary search you're given some kind of array and you have to search for a value usually you can search for that value in big o of n time which you might think is efficient but if there's a more efficient algorithm using binary search login is actually a lot more efficient than big o of n which is why binary search is you know an important algorithm but there's also a lot of problems that are easy once you know that you're supposed to use binary search but it's not obvious that you are supposed to use mine research sometimes there's a lot of data structures involved there's a lot of things going on you might think it's a sliding window problem but in actuality it's a binary search problem so i think that's kind of the hard part about binary search sometimes even identifying the problem needs binary search we've also solved a lot of binary search problems on this channel if you want to take a look at the playlist for that okay next up is going to be actually two algorithms that are very similar depth first search and breadth first search these are two incredibly common algorithms probably the most common algorithms you'll use in coding interviews because they can be applied in so many different places they can be applied to trees but they can also be applied to general graphs whether it's a 2d matrix type graph or a graph of nodes and edges and dfs and bfs are actually the building blocks for more complex algorithms things like jixtra's algorithm shortest path kruskal's prim's algorithm bellman ford right most graph algorithms build on top of dfs and bfs so if you have a very good understanding of dfs and bfs you can actually solve a very large number of problems not just graphs but also trees and even more and i would say if you can get to the point where you can write a dfs algorithm or bfs in your sleep you're going to be in very good shape for coding interviews because these are very standard algorithms once you've written them so many times it becomes like second nature but when you're a beginner these algorithms can be pretty daunting to learn we do have a trees playlist and a graph playlist on the channel if you want to practice some dfs or bfs okay next up is recursion recursion was super difficult for me when i learned it back in college but now it's actually very intuitive just like dfs and bfs recursion is applied in so many places and it's also used in graphs as well as many other categories like backtracking sometimes with dynamic programming if you're talking about the memoization solution and in so many other ways recursion is just a huge category i don't know how you would even prepare for coding interviews if you didn't know recursion and i definitely recommend getting pretty proficient with recursion you definitely want to have a good understanding of the base case the recursive step and just the general idea of what's going on with the recursion you should understand that recursion does take extra memory to do it's not free you should understand how what's going on with the call stack as you do recursive algorithms and i think this category is probably one of the most difficult for people to learn i think recursion is the reason why people think graphs are hard trees are hard backtracking is hard it's usually because they don't have a very good understanding of recursion okay last up the number one pattern i think you should understand for coding interviews is definitely hashmaps it's the most simple thing on this list probably but it's also the most common there are so many problems that can literally just be solved by using a hashmap the famous problem is probably twosome because instead of iterating through the entire array to search for a matching value with twosome you can just literally use a hash map that's the entire problem if you use a hashmap then you solve it efficiently and the important thing to know about a hashmap is basically that every operation that you do on it pretty much any operation at least can be done in big o of one time in constant time now technically that's not true in that technically it's amorotized because there's a lot of different ways to implement a hashmap under the hood but basically on average it'll take big o of one time and usually 99 of the time in real interviews people will just say okay yeah it takes big o of one time to do that in a hashmap you don't really need to get too technical with it adding removing and searching for values in a hashmap is very efficient and even in a lot of the other categories i was talking about dfs recursion and sliding window hash maps actually come in handy for those as well so even if the hashmap itself won't solve the entire problem hash maps are always used as utility data structures to do things efficiently if you don't have a good understanding of hash maps or know how efficient they are then pretty much any coding interview problem is going to be challenging for you so those are the top six coding interview concepts i think you should be preparing for let me know if you think there's anything that i missed or there's anything that you disagree with of course i could have made this list a lot longer but i like to be concise and i think if you are preparing for your coding interviews and you don't feel like you have a really good understanding of the six things that i talked about here definitely recommend studying that before you get into more complex things like dynamic programming or getting into those really advanced and obscure algorithms like kmp pattern matching or maybe kruskal's algorithm which most likely you're probably not going to see in a real coding interview you're more likely to see the things that i talked about here as always thank you so much for watching don't forget to like and subscribe if you found this helpful it really helps the channel a lot consider checking out my patreon if you'd like to further support the channel and hopefully i'll see you pretty soon thanks for watching "
    }
]
[
    {
        "title": "Dynamic Programming - Learn to Solve Algorithmic Problems & Coding Challenges",
        "link": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
        "transcript": "Hey programmers, I'm Alvin l come to our course\non dynamic programming. So dynamic programming is one of my most favorite topics to teach.\nBut unfortunately, I feel like dynamic programming also has a reputation for being a very difficult\ntopic. That being said, I think dynamic programming can be very intuitive. If we actually take\na nice gradual progression through the material, right? A lot of students have this habit of\njust trying to attempt a pretty hard dynamic programming problems, without going through\nthe necessary steps of really understanding the material, right? It goes without saying,\nif you want to do well on those data structure and algorithm interviews, you definitely need\nto know dynamic programming. So I hope to give you all the background knowledge, you\nneed to really crush those types of problems. Now, that being said, What problems are we\ngoing to solve throughout the course? Here are a few examples. So one question I can\nask you is to calculate the fourth number on the Fibonacci sequence seems like a very\neasy problem, can also ask you to count the number of different ways to move through a\nsix by nine grid, or something different, like given a set of coins? How can we make\n27 cents in the least number of coins? A final example would be given a set of substrings?\nWhat are the possible ways to construct a string potent pot? And all of these questions\nreally fall under the umbrella of dynamic programming. And this is really why I think\nthe topic has such a bad reputation or being very difficult, because the problems ranged\nso much, right? It looks like these problems are totally different. And there may not be\nany underlying mechanics that we can use to tackle all of them. But the short answer is,\nwe really can if we have the correct way of thinking about these problems. That being\nsaid, let's go over the overall format of this course, in this course, I think our key\nto victory is going to be to really visualize all of these algorithms, right? So we're going\nto spend a lot of time drawing things on the whiteboard, as well as visualizing things\nwith animations. To me all the heavy lifting on an algorithm interview is really done when\nyou come up with that picture, right? When you describe that process, and then translating\nit into some code is really the easy part. Right? The hard part is designing the algorithm\nin the first place, right? So we're going to draw out of things to make sure we understand\nthe structure of the problem, as well as coming up with a solution. And then once we're really\nhappy with that pen and paper process, then we'll hop into my editor, and we'll solve\nit in some code, we'll probably have to go back and forth, until we end up with an algorithm\nthat runs in an efficient amount of time, right. So it goes without saying, we're also\ngoing to analyze the time and space complexity of all of our solutions. I'll be writing my\ncode in JavaScript, but you'll find it very easy to translate our solutions into the language\nof your choice. So in this course, on dynamic programming, we're going to divide the material\ninto two main parts. Part one is going to be about memoization. And then Part two is\ngoing to be about tabulation. And don't sweat it if you have no idea what those two terms\nrefer to, don't worry, we'll reach all of that material step by step together, I think\nyou're going to realize if we actually learn these things in all very logical progression,\nwe're almost like discovering these algorithms. And I don't just have to tell us what the\nalgorithms are. So in terms of prerequisites, I won't assume you know anything about dynamic\nprogramming, but I will assume that you understand a little basic recursion, as well as some\nbasics of complexity analysis, right. So you're sort of familiar with big O notation. And\nI'm sure that we'll be able to review some of that notation as we move along. So I think\nwith all that out of the way, and no further ado, let's hop into the course. Alright, so\nwhere should we start? Well, I want us to really ease into this new topic. And so what\nwe'll do is we'll start by attacking a problem that you probably seen in the past that is\nI want to solve a Fibonacci problem. And so for us, we'll have a particular phrasing of\nthe Fibonacci problem. What I want to do is write a function fib of n that takes in a\nnumber as an argument, and I need to return the nth number of the Fibonacci sequence.\nAnd just to review, how does the sequence work? Well, the first and second number of\nthe sequence is just one. And then at any point in time to generate the next number\nof the sequence, you can just sum the previous two. So for example, these are the first few\nnumbers of the Fibonacci sequence, right starts 112358, and so on. What I'm saying is your\nnumber needs to take in like a position of the sequence. In other words, if I asked you\nfor the seventh Fibonacci number, you need to return the answer 13, right? Because the\nseventh bonacci number is 13. And how do we actually calculate that 13? Well, logically,\nit's just a sum of the previous two elements, that is five plus eight gives me the 13. So\nvery, very classic function here. And to really get us going for what we do later on in the\nlesson, I'm going to require us to solve this one recursively, right, it's really going\nto be at the heart of a topic for today. Why don't we kick things off by quickly implementing\nthe classic recursive implementation of a Fibonacci function, probably in this function\na few times in your programming career, usually one of the earliest examples of recursion\nthat we face. So we'll just lay out the classical notation here. So I want to take in a number\nand and I want to return the number of the Fibonacci sequence. Like we expect, the base\ncase is just about, you know, the first two numbers of the sequence. In other words, if\nI'm given some n, that's less than or equal to two, then what I should do is just returned\none. And I'm reading this because hey, the first two numbers of Fibonacci sequence are\nexactly one. But in the recursive case, in general, what I can do is just return the\nsum of the Fibonacci number right before the one I'm asking for, as well as the Fibonacci\nnumber two before the one I'm asking for, right? Again, the kind of baked in recursive\nnature Fibonacci is to calculate some Fibonacci number, you can take the sum of the previous\ntwo numbers in the sequence right. Now, of course, we should test our code for some correctness,\nwhat I'll do is call a few examples of this fib function. So I'll try fib of six, seven,\nand eight. And I shouldn't get the answers of 813 and 21, respectively, right. So let's\ngive this a go. I'll run this in some JavaScript. There we have it right. 813 and 21. So this\nis a very, very classic implementation of Fibonacci, you've probably seen this many\ntimes before. And we did solve it recursively. And really, what I want to do is give some\na larger number to this fib function. So what if I asked for, let's say, I don't know, the\n15th Fibonacci numbers seems like something reasonable to ask for. So if I give this code\na shot, it looks like the first three calls of bonacci do work fine, right, I get 813\nand 21. But the fourth call is actually still running, right, my program actually hasn't\nfinished. And this is a big issue with this type of implementation with Fibonacci. So\nobviously, this Fibonacci function needs some work. Let's go ahead and head to the drawing\nboard. Alright, so it's apparent that our Fibonacci function is correct. And that returns\na proper result. However, if we give it a large enough value of n, it's pretty slow.\nThat is our function has correctness but lacks some efficiency. In the long run, we definitely\nwant to improve this implementation of a recursive Fibonacci. But to do that, it's really important\nthat we identify exactly where there's even room for improvement. And to do that, I think\nwe should draw some things. This is something I think students actually need to work on.\nStudents have this habit of trying to like picture everything in their mind. And that\nworks for some easier problems. However, when we want to tackle more complex problems, if\nwe just try to capture all this information, just mentally without drawing it on, like\npen and paper, or marker and whiteboard, or chalk and chalkboard, you're going to really\nlose track of the finer details in these structures. So I want us to be very, very methodical,\nand we're going to draw really how you should visualize a problem like Fibonacci. And so\nover to my drawing, let's say that I wanted to trace through what happens when we call\na fib with the number seven. That is I'm asking for the seventh number in the Fibonacci sequence,\nI know that in the long run, I should get back to 13. Right. 13 is the seventh number\nin the sequence. So I'll keep that goal in mind. But over to my drawing, let's say I\ncalled fib of seven, I'll denote that by really drawing a circle with my value for n inside.\nSo I think about this call to fib of seven, what is it going to do? Well, I know that\nseven is not the base case, right? Seven is not less than or equal to two. So this call\nis going to branch out into some more recursive calls. In particular, on its left hand side,\nI'm going to call n minus one, which is six. On the right hand side, I'm going to do n\nminus two, which is five. And at this point, I carry over the same logic\nfor the other nodes have the structure, right, if I look at the six node, if I'm routed right\nthere, then that will have a left child of minus one, so five, it will also have a right\nchild of minus two. So four, you can start to see a pattern where really this recursive\nstructure just visualizes as a tree, which is really neat. I hop over to this five node,\nit will have some children, right, minus one on slept minus two on its right. And we will\nactually just continue this process for most of these nodes. But let's say we pause right\nhere. So you'll notice that these notes that have pointed to in red, they're actually the\nbase case, right? For those nodes, I have values of two or one. And I know that those\nfunction calls will return immediately. More importantly, that means they don't branch\ninto any further calls. So I don't want to start flushing out the tree of those nodes.\nInstead, I look at things that are not the base case, right? That is these nodes in yellow.\nSo I'll continue to flush out this tree, but not branch out further for the base cases. So at this point, I built out my entire tree,\nand I stopped fleshing out the tree whenever we had a base case scenario. So this is actually\nthe full recursive tree. Remember that the numbers inside of the nodes here represent\nthe end that we passed in. That being said, if we have this visualization, how does this\ntree really calculate the Fibonacci answer? Right, so let's start to break it down over\nhere. Let's say I looked at some note, in particular, this base case note of two, right?\nI know that this note is a base case, so it's going to return the value of one according\nto my base case, when we say return, that really just means return to your caller right\nreturn to your parent. So this note of two is going to return one to its parent of three.\nIn the same way, this node on the right hand side of one is also a base case, two will\nreturn one, both of those values that are returning, they go back to the parent of three,\nand three is actually going to add those two values up. One plus one is two. And this makes\na lot of sense because we know that the third Fibonacci number is two. So we can continue\nthis process. Okay, this node over here. This is also a base case. So it returns one. And\nnow the parent node of four is going to sum up both of its children values. Two plus one\nis three. And that makes sense in itself, because the fourth Fibonacci number is three.\nSo you probably got the picture. Now let's speed things up. For all of these base cases,\nI know that they're going to return one to their parent. And for all parent nodes that\nhave both of their children ready, that is both of their children returned, they're just\ngoing to add up those values. And this process just continues all the way up the tree, right?\nJust adding our left and right children. To get the answer that we should return the very\ntop of our tree at the root of our tree, we get the final result of 13, which makes a\nlot of sense, because at the start, we said that, hey, the seventh Fibonacci number is\nindeed 13. So now that we have a robust understanding of how to visualize this fib function, what\ndo we actually know about its speed? What do we know about time complexity. And so you\nmay have heard offhand people mentioned that a classic recursive implementation of fib\nis going to be two to the n in time complexity. And that is the case however, you really understand\nthe reason why. So hidden in this picture is the reason why Fibonacci for us is going\nto be two to the n in terms of its time complexity. However, something that's kind of unfortunate\nabout this drawing is it's asymmetric. And that's, I think, a big reason why students\nhave a really hard time convincing themselves that a function like this has a two to the\nn power time complexity. So here's what we'll do, why don't we warm up and kind of go through\nsome basic understanding of time complexity? And I promise we'll answer that Fibonacci\nquestion. So let's do a little warm up. Let's say that I gave you this foo function, notice\nthat it's different from our fib function, right? It's similar in that recursive, this\nfunction is kind of arbitrary, it actually doesn't calculate or solve any particular\nproblem. So if I wanted to visualize how this foo function behaves, let's draw it out. Let's\nsay I initially call it the top level foo of five. I know five is not a base case. So\nit's going to call upon n minus one, or it's going to call upon for four calls three, three\ncalls to two calls one, and then here, we've actually bottomed out at a base case. If you\nlook at the number of calls I made, I basically made exactly five function calls. Which makes\nsense, because in terms of our base case, where do we stop once we hit a number less\nthan or equal to one and every recursive step, we just subtract one from our current value\nof n. So overall, I have five calls here. But if I generalize that, for any arbitrary\ninput, I know that in the long run, I'm going to have about n different function calls recursively.\nAnd so for that reason, the time complexity of this is really just O of n time, right?\nI have to evaluate O of n different function calls. While we're at it, why don't we take\na look at the space complexity? Well, you may have heard in past that when we analyze\nthe space complexity of our recursive functions, we should include any of the additional stack\nspace that our function calls take up right, when we make a recursive call, we add that\nto the call stack, and those must be tracked by our computer. And so since we have about\nfive or n different function calls added to the stack, before we hit our base case, you\ncan see that the space complexity of this code is also O of n space, overall, we're\nlooking at O of n time and open space for this function. Pretty straightforward stuff,\nright? Let's look at another more involved function. So let's say I gave you now this\nbar function, it's another arbitrary function, it's very, very similar to foo, what you should\nnotice is, the only difference is when we make a recursive call, we do an n minus two\ninstead of an n minus one. So how does that actually change the time complexity of this\nfunction? So let's say I wanted to trace through this and I made a top level call to bar of\nsix, I know six is gonna call upon four four is gonna call upon to, to call zero and zero\nactually hits a base case. So this is very similar to our last example, except we kind\nof see that from one call to the next, we kind of take a bigger step in time, right.\nAnd so in a way, we can say that we're moving twice as far upon every recursive call. And\nthis would actually half the number of recursive calls we need overall. So I guess we might\nbe tempted to say that the time complexity of this one is N over two time, but a keen\nobserver would note that according to our bego, you know, understanding, we can remove\nany multiplicative constants when we have a time complexity, so N over two is the same\nas one half times n. So this simplifies nicely, it's just an O of n time complexity. Using\nthe same exact argument, we can also say that the space complexity from the stack is also\nopen space. All right, so let's take a lay of the land, I showed you two functions that\nare very similar, they really only differ in how they made their recursive calls, right?\nOne did minus one, the other did minus two. But in the grand scheme of things, we saw\nthat they had an identical complexity class, right? We have O of n time and O of n space\nfor both of these functions. So after these two examples, you may be able to see the reason\nI wanted to bring them up, right, maybe you're actually ready to make the logical leap and\nmake some conclusion about our classic Fibonacci recursive function. That being said, I don't\nwant to skip any steps. I want to be super methodical, I think, if we pay the cost of\nunderstanding fib right now, and I mean, truly, like Absolutely. Understanding fib. It's really\ngoing to pay off later on in the lesson when I slam me with some much harder problems.\nSo let's be nice and methodical over here. Let's take a look at some other functions.\nLet's say I gave you this did function now. very particular Right, we'll pay it no mind.\nWhat do we notice about this did function? Well, it has two recursive calls now right\ninside of every single call. And they both do an n minus one. How should we visualize\nthis one? Well, it's kind of similar to I guess, our initial fib drawing and shape,\nwhere if we start with some initial call, let's say five, five is going to branch to\nexactly two children, right? Because five is not yet the base case. And for this did\nfunction, it does a minus one on its left, and also it's a right child, right. So the\nnext level is just for next levels, just threes than twos, then just ones which would actually\nhit our base case over here. This is a really nice, like, beautifully symmetric tree, right?\nOkay, so this is a visualization for our dib function. But what does it tell us about the\ntime complexity of it? Something you'll hear me say a lot in this lesson is when we tackle\na quote, unquote, new problem, or a new pattern we're really trying to do is just leverage\nour past experience, right? So when I look at this tree structure, I'm trying to notice\nanything familiar, right? Is there some strand over here that I can grasp that to really\nfeel comfortable and kind of extend my previous learnings, right? Where can I find our base\ninside of this drawing? Boop, right here. So if I look at this path, I've highlighted\nin yellow, it's really just the path starting at the root node going down to some base case\nhere, I just designated the leftmost path. And what's really nice about this structure\nis just referring to the notes in yellow. It's a linear structure that we saw before,\nright? If I start at the root, it just goes 5432. And one. And so I know that in general,\nbased on my initial input of n, like the length of this path that has a number of nodes highlighted\nin yellow, there's going to be about n different nodes. If I kind of adapt that language for\nlike the tree, I can also say that the height of this tree is n. So the height of a tree\nis really just the distance from the root node all the way to the far this leaf, in\nthis case, that just means the distance from our top level called Five, all the way down\nto a base case, which is going to be exactly five here. Something you may also hear in\npassing is we can say that the number of levels in this tree is also n, this term is pretty\nstraightforward, right? When we say the number of levels, a level is just a collection of\nnodes that are the same distance away from the root. So for example, here in yellow,\nI have highlighted level zero, this is level one, this is level two, this is level three,\nand so on. But if I rewind things a bit, I look at the very, very top level, there's\none node here, on the next level, there's two nodes. On the next level, there's four\nnodes, then eight nodes, then 16 nodes, see the pattern? So let's try to generalize that. So I know\nno matter what, whenever we call some top level argument for dib, we know that we're\ngoing to have one node at the top level. But to get the number of nodes on the next level,\nwe'll just multiply that by two. And the level after that would also multiply by two and\nmultiply to again further levels after that. And I do this a total of n different times,\nright? Because I know that the height of the tree, or the number of levels in this tree\nis exactly n. And so what conclusion Can we make over here, we're basically saying that\nto get the total number of nodes, or the total number of calls a recursive function would\nmake, you would just take the number two, and multiply it by itself about n times over.\nAnd that is really the definition of an exponent, right? This is the same as two to the nth\npower. So we can say that this tree structure, this recursive function has a two to the N,\ntime complexity. Awesome. So we identified this dip function is having a two to the n\ntime complexity. But what do we know about the space complexity over here, I think a\ncommon mistake I've seen people make is kind of automatically assumed that the space complexity\nof a recursive function will be the same as the time complexity. And that might be a reasonable\ntrap to fall into, because we know that in the long run, we're gonna have to evaluate\ntwo to the n function calls. And so I guess that means you have to put two to the n function\ncalls on the stack. But there's actually some nuance to this, the time complexity of this\nis not the same as space complexity. So let's jump in. Let's say that we made our top level\ncall to dibba five, we know that that is added to the stack in the same way five calls for\nso it's that the stack, we add a stack frame for every call that we make down until just\nthe base case, right. So at this point, I reached a scenario where I have a base case,\nand I'd have about five stack frames on my call stack. And the important insight is when\nwe actually hit this base case that I have highlighted the left one over here, it actually\nwill return when something returns when a function returns, its stack frame is actually\nremoved or popped from the stack. And at this point, only after I have returned from that\nleft one, what I actually add the right one to the stack to be explored. And this process\ncontinues. Notice that any point in time the most number of stack frames that we use up,\nit's exactly five, right, it's not as if we throw all of these function calls on the stack\nat once. And because we have such a nice tree visual, we know that the number of stack frames\nthat we're ever going to use is really just the height of the tree, right, so the height\nof the tree is n like we said before, that means our maximum stack depth is also n. So\nwe have in space complexity coming from the call stack. So overall, for a dip function,\nwe're looking at two to the n time complexity, but only and space complexity. Alright, so\nlet's look at one more function. See, I gave you this very similar lib function. Notice\nthat in its recursive calls, it does an n minus two. So by now you should be able to\nvisualize what structure like this would look like, say we initially called lib with a value\nof eight, what would the full tree look like? Well, it would just look like this. Notice\nthat it's still a tree, right where every node branches to two children. But this time,\nwe go by twos, right, so if I look for some familiar ground here, I've noticed that from\none node to the next, I do one minus two. And this occurs all the way down to a base\ncase. So we already know that, hey, we can identify this tree as having a height of about\nN over two. So I guess that means that the time complexity is going to be two to the\nN over two power, right, because from one level of the tree to the next, we double the\nnumber of nodes. So that's that two times two times two repeating pattern for the number\nof levels and our number of levels is N over two, right? However, we can actually simplify\nthis time complexity, you can take that n over to in the exponent and simplify that\nto just an N. So overall, we're looking at a two to the n time complexity. And using\nour same arguments from last time, we know that the space complexity for this from the\nstack is also going to be N over two, which simplifies nicely to N space complexity. So\nwe see that overall for our loop function, we're looking at a two to the n time, but\nno space complexity. Alright, so now it's time to look at the big\npicture, we looked at two toy functions of dibben lib. And we saw that the only difference\nin how they made the recursive calls, right did did a minus one and lived in a minus two.\nAnd we saw that despite their differences, both functions had an exponential two to the\nn time complexity, and a linear and space complexity. That being said, Where does our\noriginal Fibonacci function fit in this picture? Well, you can imagine that kind of falls right\nin between, we know that for our fib function, it has two recursive calls for the first recursive\ncall, it makes it does n minus one like did did. But its second recursive call this n\nminus two like lib. So in a sense, it's kind of like smack in the middle, right? If you\nlet me abuse the notation a little bit, and just talking about the time complexity, we\ncan kind of say that the complexity of fib is somewhere between dibben lib, but we've\nalready plugged in some values, right? You know, that, hey, the lower bound that as Deb\nhas to to the end, and the upper bound, that is lib has to at the end as well. So that\nmeans that our fib function must have exactly two to the n time complexity as well, right?\nAll three of these functions have an exponential time complexity. Awesome. So that was a really\ncomplete analysis of why we have this fib function, it's evident that it has a two to\nthe n time complexity and an N space complexity. Right now, the bottleneck that we're experiencing\nis, of course, the time complexity, right two to the n overall, is not undesirable complexity.\nBut do we really have a nice feel for what this really implies? So let's take a look\nat this to to the end. So what's the implication of this? Well, you could kind of imagine that,\nhey, if I asked for the 50th Fibonacci number, that would take you know, roughly two to the\nfifth power number of steps. And so if you punch this exponent into a calculator, you're\ngonna end up with a result like this, this is roughly a 16 digit number. So you should\nhave a vi for you know, this being a very, very, very large quantity. But I think that,\nyou know, to really understand the gravity of what we're really saying here, if we expand\nthis number, that quantity is exactly this. That's over one quadrillion 125 trillion,\nwhich is really, really interesting, right? Because we just asked our Fibonacci function\nfor just you know, something relatively modest, right, the 50th Fibonacci number, and it's\ngonna take quite literally a quadrillion steps to do that. And of course, we can probably\ndo better. So let's work on making this faster. So if I recognize that the bottleneck for\nthis fib function is the time complexity, I know that that comes from the number of\nrecursive calls that I make. So what I want to do is look for any patterns that I see\nin the recursive nature of this problem, let's see a quick snapshot of what the recursion\nfor fib of seven would look like, we know that it looks like this tree just like we\nsaw before. So take a moment, look at this tree, do you notice any interesting patterns\nwithin it? Well, one thing that I noticed is I can see\nthis subtree rooted at three, there, I have two on the left and one on the right. And\nif I look at that subtree, I can actually see it in many different places in this tree,\nright? This subtree rooted at three appears in a bunch of different places, it's very\nduplicate. In a similar way, I can look at other sub trees, let's say I root myself at\nfour, and see that duplicate four sub tree all over the place. And it's even carries\nover for larger values of n like fib of five. So I see that this tree has a lot of duplicate\nsub trees, right? And I want to now draw a connection between this diagram and what happens\nin my code. I know that if I route myself in any of these sub trees of five, I know\nthat each sub tree is trying to answer the question. Hey, what's the fifth Fibonacci\nnumber? I know that the Fibonacci number never changes, right? If I calculate it once on\nthe left hand side, then the answer I should get back on the right hand side shouldn't\ndiffer at all. And so what I want to do is possibly reuse these calculations right? If\nI calculate the Fibonacci number over here, then I should just store that because later\non it might be useful when need to recalculate it over here. I would basically get rid of\na lot of the tree, I wouldn't have to travel down this entire recursive tree rooted at\nfive. This pattern of overlapping subproblems is known as dynamic programming. And so for\nus dynamic program is going to be any instance where we have some larger problem, in this\ncase, Fibonacci. And we can decompose it into smaller instances of the same problem, we\nalso have an overlapping structure. So for us, right, now, I see that I have to calculate\nnow let's say fib of five, twice over to calculate the larger a fib of seven a solution. And\nsomething we're going to be doing a lot in this lesson is really trying to visualize\nproblems in terms of like their recursive nature. So we're going to be drawing a lot\nof trees. And what I'm always going to do is try to really recognize, hey, what pattern\nin this tree is duplicate, right? If I do some duplicate work, if I do some duplicate\ndrawing that I know I can optimize that out later on. But that being said, let's go ahead\nand get to the punch line on this fib function and work on optimizing this solution. Alright,\nnow let me discuss the plan, I think we're ready to actually implement some code that\nwill actually carry that plan out. Here I have our classic bonacci implementation, this\nwas the one that we ran earlier. And it's definitely too slow, right has an exponential\ntime complexity. So I know that overall, when I want to do is kind of capture a duplicate\nsubproblems, I want to store any results that I get that way, if I have to recalculate those\nsubproblems. Later on, I can just use my stored data. And so the trick here, it's a very common\nprogramming pattern, we're going to implement some memorization. memorization is actually\none of the overarching strategies we can use to solve any dynamic programming problems.\nAnd so just look at the name like why is it called memoization? Well, this refers to like,\nmemo, right? So if I have like a memo, and let's say, like real life, it's really just\nlike a reminder for myself. So using memoization, I'm looking to do is store some duplicate\nsubproblems. That way, I can just get those results later on. I think a really neat way\nto implement memorization in JavaScript, as well as many languages is to use some sort\nof a fast access data structure usually be like your hash map equivalent in the programming\nlanguage of your choice. For us, that'll be a JavaScript object. And so our plan is to\nuse some JavaScript object. And so what do I want the keys to be, so the keys in the\nobject are going to be the argument to our function, right. And then the value will be\nthe return value, that we have a nice napping for a argument to the function that is a function\ncall, as well as its return value, right. And so what I can do for my existing function\nis, I kind of just bake in some optional arguments. So my favorite strategy is to do this, and\nassign a memo to be an empty object. So if you're unfamiliar with this syntax, in JavaScript,\nit's pretty useful. What I'm saying is, if I were to call our fib function, and not pass\nin a second argument, by default, it will create this memo, as containing a new JavaScript\nobject that is empty, of course, right? So it's gonna be useful that way, whoever is\nactually testing, my code doesn't have to deal with setting up any memo object. So well,\nI prefer this strategy over here. And what I want to do is treat it as if that, hey,\nthis memo is going to store n as the key and values are going to be just the return values\nfor this function. So what we're going to see us doing a lot in this lesson is at the\nstart, we're going to first check for existence inside of our memo. So let's say that we're\nsomewhere in the middle of recursion, the first thing I should do is kind of add an\nadditional base case and say, Hey, is my current argument n inside of the memo, and if it is,\nthen I can just get the stored value from that memo. And I'm done. So I'm going to do\nan early return here, I'm going to return the value that corresponds to that memos key,\nright, I'm just using the original argument and as a key in my memo, and this condition\nis really just some classic JavaScript syntax, I'm just checking if some key is inside of\na JavaScript object. So really quick, maybe just to warm us up, if\nyou haven't seen that syntax before. So let's say I had some object and had some properties\ninside and we had a name of Alvin, that's me, then it had a favorite color of like gray.\nAnd what I can do is check for an existence of a key in that object. So JavaScript keys\nare mostly strings, right? So I can check Hey, his name in the object. That's true,\nis the fav color in the object, make sure I spell it right. That is also true, I can\ncheck for a key that's not there, like I don't know, his location and the object that is\nfalse. And so here, I'm just using that same pattern, but for and right, which is going\nto be a number, technically, it'd be converted into a string key, which would still totally\nwork here. Awesome. So I have my memo fetching logic, right? I check, Hey, is this argument\nin the memo, but if it's not, I'm gonna have to actually manually do the calculation, which\nis okay, because I know I need to do a subtree at least once. So what I'll do is I'm going\nto take the exact return value, right, so this is my return value in the original brute\nforce. What I want to do is actually store that entire result inside of my memo and the\nkey is course and write, the key you use to access is always just what your argument is.\nAnd I want to complete the original return. So I can just go ahead and return what I just\nput in that memo. So I'm not really changing any return values, or I'm returning exactly\nthe expression that I returned before. But now I'm actually also saving that value inside\nof the memo object. What I want to do is make sure that all of these recursive function\ncalls are accessing the same memo. So what I'll do is I'll pass in that object to both\nof these calls are really important pattern here is, I know that I only receive a new\ntop level metal object, whenever I make a top level call, that's a fit, right, because\nI'm not passing in a second argument over here. However, if I look at my recursive calls,\nI do pass in explicit second arguments. And so they're actually going to receive the same\nmemo object, and it would be like passed by reference, right, because when you pass a\nJavaScript object to a function, you actually receive kind of that exact object, right,\nyou don't receive a copy of it, which is really neat. So basically, I'm giving my function\ncalls a way to sort of communicate to each other, they all have some sort of global information\nto reference across all the recursive trees. So this is looking good. Again, I just want\nto emphasize I only added a new argument over here, I added a new base case on line five,\nthen I added my memo storing logic on line seven, but I didn't change any of the functional\nlogic here. Let's go ahead and run these test cases. And we'll see how our code is doing\nnow. So moment of truth, I'm going to run this file. And notice how blazing fast our program was,\nI still get the results of 813 and 21. And the 50th Fibonacci number is indeed have this\nvery large number. And it basically executed almost instantly. So let's go ahead and head\nback to the drawing board. And really understand you know, what happens when we execute this\nsort of code. Alright, so it looks like we implemented the improved version of Fibonacci\nby memorizing it. And it's clear by running the program that we definitely had an impact\non the time complexity. However, I really don't want us to understand you know how the\nstructure of the recursion tree changes, once we implemented this memoized version of the\ncode. So let's say I want to step through an example of Fibonacci. And let's say I pass\nin a number six. So really, what I'm looking for here is to get back eight, because the\nsix number of the bonacci sequence is indeed eight. So we know that we're going to have\na tree that looks like this, right? This is a tree that would really be the full recursive\nnature. So this is how the tree would look like if I did not optimize it. And what impact\ndo we have by actually adding this memo object? Alright, so let's start tracing through this,\nI know that when I call fib of six at the top level, an important thing to know is I'm\nnot going to pass in some memo object. So by default, my code says it will initialize\nit to an empty object. And the really important aspect of this is I'm going to create a new\nobject just for the top level call. But then that same object is going to be passed down\nto my recursive calls, right noticing line five. And so I'm going to travel down my left\nhand path, right, six calls five, five calls for four calls three, and three calls to,\nand right now I've hit a base case. So I know that this note of two is going to return one.\nSo that's kind of business as usual, right? In the same way, now I need to evaluate this\nother note of one, which is also base case, it also returns one. And at this point, my\nparent of three is actually ready to compute the sum of its children, right. So one plus\none just gives me two. So I just add up those values. And now three is returning two. However,\nlooking at line five of my code, not only is this node going to return to to its parent,\nit's also going to store it in the memo object, right? So the key insight is, at this point,\nI would add a key to my memo of three, whose value is to basically in my memo, I kind of\nread as if I'm saying, hey, the third Fibonacci number is two, right? That in itself is logical.\nSo I can just continue this pattern right? Now I start to evaluate what happens when\nI'm at this note of t, which is also a base case, it returns one. Now my call to four\nis ready to compute, right? It's going to take the sum of its both children. So it's\ngoing to do two plus one gives me three. But of course, it's also going to store that inside\nof the memo, right? It's going to cash that result out to be used later on. So that means\nI make the N my key and I make the return value, the value, right, so I'm going to have\nfour points to three inside of my mental object. And now here's the beauty of this memoized\nsolution. At this point, I need to compute what happens for fib of three. However, this\nis actually going to hit one of the new base cases I added, right? I know that three is\nin the memo object looking at line two of my code, right? It's in the memo object. And\nso I just immediately return the stored value. And so this call to fib of three is just going\nto return the stored value of two. And if I do that, I won't have to travel down the\nfull, you know, recursive subtree rooted at three, right? I don't need to travel to these\nnodes at all. So I already used some stored value in my memo. At this point five is ready\nto return right five will take The summer both with children, three plus two is five.\nAnd it's going to store that in the memo, right? The fifth Fibonacci number happens\nto be five. And now the same thing happens for six is right child. So I have to evaluate\nthis node now. So what is the fourth of bonacci number up, that's actually stored directly\ninside of my memo. So this actually early returns the stored value of three, right.\nAnd again, the key insight is, it will return that stored memo value without having to travel\nthrough that full subtree. And at this point, I can return for fib of six, so I do five\nplus three, that gives me eight, this would actually technically be stored in my memo\nas well. So I have the six of bonacci number as eight and very happy, right? The answer\nis eight. So it's evident that by memorizing our Fibonacci\nfunction, we definitely cut down on the number of recursive calls, we want to visualize that\nwe ended up with this kind of structure. Here in light blue, I have a circle the nodes that\nwe technically didn't need to do the full recursion at, right? So these nodes of two,\nthree and four, for this small example of my initial fib of six, I was able to kind\nof fetch a value from my memo and kind of forego traveling down the recursive subtree.\nSo what do we actually know about the time complexity of this function now? Well, I think\nit's really important that we always try to generalize things. So we just stepped through\na relatively small example of fib of six. But how does this sort of scale? So this is\nthe same tree? Let's see, I kind of tidy it up a little bit. So I know that in general,\nfib of six kind of has this structure. So I want you to take a moment, look at this.\nAnd in your brain picture, what fib of seven would look like if I memorize with with seven,\nwhat would its sub trees look like? Well, it really just looked like this. Notice if\nI route myself at the seven node, its left child is still six, right minus one. Its right,\nCharles, still five minus two. So this still obeys the laws of Fibonacci. If I asked for\nfib of eight memoized, the structure would be like this. And nine would look like this.\nSee the pattern looks like at this point, we're just growing this like memoized chain\nin a linear kind of way. If you're not convinced by you know, that just like structural argument,\nlet's say we were a little more methodical, we know that in this drawing, there is some\ncommon ground, right? Again, like I always say, when you tackle these new problems, or\nnew patterns, try to find some familiar territory, right? Where can I recognize stuff I've seen\npreviously. So I look at this chain, I go 98765432, right. So this goes all the way\ndown in a very, very, very linear fashion, right, just counting down. So I know that\nif I just look at this highlighted chain in yellow, that's definitely just an notes, right,\nwhere n is my initial top level call. So I know that what I have highlighted in yellow\nis just a linear chain right there exactly n nodes. But I haven't accounted for everything\nin this picture, right, some of the nodes are still in white, meaning I need to kind\nof work them into my description of what the shape of this tree is, well, I know that each\nof those white nodes is actually connected to some of the nodes, I've colored in yellow,\nthey're kind of paired off in a way, right? For every node in my ello chain, it has exactly\nkind of one partner node one right hand node on its right hand edge. And overall, if I\nhave n pairs, that means I have to end things overall, right? There are two things in a\npair. So overall, the number of nodes is roughly two n. And I know that that can actually be\nsimplified, right? The time complexity here would be two n, which just simplifies to n\ntime complexity. And using the same arguments we did for our space complexity, we know that\nthe space is going to be n as well. And this is pretty powerful stuff. by memorizing our\nfib function, we brought it down from an exponential time complexity to just a linear time complexity.\nPretty cool stuff, right? All right, I think we're ready to graduate from Fibonacci. And\nwhat we'll do is work on a more involved problem, this one has more of a narrative to it. So\nsay that you're a traveler on a two dimensional grid, you begin in the top left corner, and\nyour goal is to travel to the bottom right corner of that grid. And the rule is you can\nonly move down or to the right, that means you can't move up or to the left, and you\ndefinitely can't move to AGL. That being said, In how many ways can you travel to the goal?\nThat is how many ways can you travel to the bottom rate if you had a grid of dimensions,\nm by n. So the first thing I recognize here is looks like the grid, maybe a rectangle,\nnot necessarily a square, right. And overall, what we want to do is implement a function\nthat calculates this that is our function is to take the dimensions of the grid. And\nso before we hop into sketching the strategy for this one, I think it's really important\nthat we make sure that we actually understand what this question is asking. So let's say\nthey asked us to calculate grid traveller of two comma three, that means they're asking\nus in how many ways can you travel from the top left to the bottom right, of a two by\nthree grid? I will tell you right now that the answer here should be three. Right? So\nthere are three ways to do that. And in particular, you can imagine that we had, you know, a two\nby three grid, so that means two rows, as well as three columns. And we start in the\ntop left, and our end goal is in the bottom right. And so why do we say that there are\nthree ways to get from the top left to the bottom right? Well, they told us in the problem\nthat we can only either take a right move or a down To move, so one of the ways would\nbe going right right down, right, that would bring us from the start to the end. And it\nwould kind of look like this. In a similar way, another path we can take is doing a write\ndown, right? It would kind of look like this. And the only other way would be going down,\nright, right, which would look like this path. And that's why we say there are only three\nunique ways to travel not through a two by three grid. All right, so that's just one example of how\nwe might call a grid traveler, I think what's really important to notice is try to also\nframe the problem as if you were given some relatively small inputs, but I think they're\nreally important case to think about is, what happens if they give us like, basically, the\nsmallest valid grid we can have that is a one by one grid. This one is kind of trivially\nsimple, right? A one by one grid only has one unique way to travel from the start to\nthe end. And it's kind of concise in that if you had a one by one grid, there's really\nonly one position, right? So that means that the start is really the same as the end, and\nkind of you already have the problem solved out the gate, because to travel from the start\nto the end, you kind of just do nothing, right? So the logic here is in a one by one grid,\nthere's only one way to travel from the start to the end, you're kind of already there.\nSo you don't need to take any moves. Something else we might think about is what happens\nwhen one of our dimensions is zero. So let's say someone asked us to calculate grid traveller\nof zero comma one, this is a kind of strange question to ask because for one, if there\nare zero rows and one column, that kind of means that the grid is empty. So I would consider\nthat as there being zero waste to travel through that grid because the grid is sort of invalid\nin a way. In a similar way, if I asked you for traveling through a one by zero grid,\nthere's still no grid to be found here. Right? So it should also return zero. And likewise,\nwhen either of the dimensions is zero, the answer should just be zero, right? If one\nof your dimensions is empty, then there really is no grid. So maybe you're catching on into why I brought\nup those trivially small grid examples, right? Those kind of sound like base cases, which\nwe can use to reconstruct a larger answer. But let's stay grounded and look at another\ngrid. So let's say I asked you to calculate grid traveler of three comma three, right?\nSo I want the answer for a three by three grid. Well, how can we reason that one out?\nAt this point, what I'm looking to do is sort of frame the problem in a way where I can\ndecrease the problem size, usually by mutating the arguments to my function call. So let's\nimagine this three by three grid, as always, I want to move from the top left to the bottom,\nright. So I begin at this position, let's say, and so I know that overall, I have this\ntop level problem of saying, how many ways can I travel through this entire three by\nthree grid, let's say I took one of the moves, right, I can move either right or downward.\nLet's say I made the decision to move downward. Well, if I move downward, then I would appear\nhere now, I know in the future, I can only move to the right or downward. So now it's\nas if my playable area has been reduced to just this shaded region. And if I look at\nwhat I've actually done to this problem, I'm still sort of in the top left corner of some\ngrid, where now I'm really trying to answer the question, hey, and how many ways can I\ntravel through this two by three grid. And this is a really important way that we're\nshrinking the problem size, right, I had a three by three grid initially. Now I have\na two by three grid. And this is really like the relative grid from my current position,\nwe'll say, spanning all the way to the end position. So if you look at this coordinate\nof like two comma three, technically, that is like not the coordinate of the person within\nthe larger grid. This is really the size of the rectangle that the person is trying to\ncover now. Right. So in a similar way, let's say that, hey, I want it to move to the right\nnow. Well, that would also shrink the grid along a different dimension. So I'd appear\nover here. And now I have a two by two grid that I'm trying to solve. And if I keep following\nthis pattern, we're gonna keep shrinking on the problem size over here. Now, I'm asking\nfor a grid traveller of one by two. And finally, if I take a right move over here, I'm asking\nfor grid traveller of one by one, which I know is one of those sort of base case scenarios\nthat I had previously. So that's going to be really useful when we actually implement\nthis in some code. And so the key insight here is when we make a move through the grid,\nthat is when we go right or downward, are basically shrinking the effective size of\nthe playable area, right, our grid gets smaller along one of its dimensions. Awesome. So I\nthink now we're able to see that, hey, this grid traveler problem definitely has some\noverlapping subproblems. Right. Let's say I tried to take more of like a programmatic\napproach, something that we'll be doing a ton, like, basically, for every problem in\nthis lesson is whenever we have a problem that we kind of know is going to be recursive.\nThe move is to really structure it like a tree, right? I want to really visualize this\nbecause I know that if I had a tree structure on pen and paper, I can implement that with\njust some recursive code using some JavaScript, right. So let's say that I wanted to take\nmore of a tree based visual understanding now a grid traveller of two comma three. So\nI know that usually the way we do this is we encode nodes of the tree Using the arguments\nto this function right? Now I have two arguments where I have the number of rows and number\nof columns. Whereas before for something simple like Fibonacci, I only had a single argument.\nSo in the long run, I know that the answer I should get back is three. So just keep that\ngoal in mind. Let's start to flesh out this diagram. So I'm going to start with that top\nlevel, column two comma three. And now I think about how this node can transition to other\nnodes, right? How does the State of my game actually change? Well, I know there are really\ntwo options I can take right? You can either have one child going downward, or another\nchild going the right word, right? Those are the two options based on the gameplay here.\nAnd so if I go down, how does that change of the number I put in the node? That is,\nhow does it change the dimensions of the playable grid area? Well, if I go downward, then I'm\nreducing the number of rows by one. So that means my left child is just one comma three.\nNow, if I had moved to the right, that would mean I'm reducing the number of columns by\none. So my right child is just two comma two. Notice that from parent to child, all I'm\ndoing is reducing a one of the dimensions by one, right, that means you're either going\ndownward or going to the right, and I can just carry over this pattern recursively,\nright. So let's say I'm fleshing out this node now, five, mat one comma three, then\nits children would be just 03. And one, two. And a similar way. If I wrote myself at two,\ntwo, then I have children of one, two, and two, one. But now let's notice something important.\nHere. I've kind of spotted a node where I have zero comma three, remember what we trace\nthrough in terms of the visual drawing? What is this? No trying to answer? Well, let's\nnotice saying in how many ways can you travel through a zero by three grid, but if you have\nzero rows, and there's really no grid to be dealt with. And so I think for this note of\nzero comma three, or really any node that contains zero, we don't need to actually flesh\nout its children. So instead, I'll work on recursively, drawing out these other nodes.\nSo we'll carry over this pattern. At this point, we've actually hit I think all of our\nbase scenarios, right. So if I look at these notes, that have one comma one that was exactly\nlike the affirmative base case, meaning that I know, trivially I can solve the one by one\ngrid. In other words, these function calls are going to return one, right, in a one by\none grid, there's exactly one way to travel from start to end, right, you kind of just\ndo nothing. And on the flip side of that, for all those notes that contain a zero, they're\nalso a base case. But they're kind of like the negative base case, meaning that there\nis no way to actually travel from start to end. So for all of these notes containing\nzero, they should return zero to their parent, right? There are zero ways to travel through\nthat grid. At this point, I just sum up these values at the parent node, right? So I just\nleft these and then I add them together. And I forget what these things are saying, right?\nIf I look at like the node one comma two, above, it is one meaning there is one way\nto travel through a one by two grid, right? You kind of just move rightward. And so I\ncarry this pattern over, I keep adding the children nodes at their parents. And this\ncarries up all the way to the root node. And what do I know, there are three ways to travel\nthrough a two by three grid. So although there's like a narrative, and there's some, you know,\ncute story behind this problem, it's really just a spin off of Fibonacci. And that's going\nto be the case with many of these dynamic programming problems. So we've confirmed that\nthere are three ways to travel through a two by three grid. And there's also some other\ninformation encoded in this tree. I know that whenever I took like a left hand edge in this\ntree that I presented the choice of going downward. And whenever I took a right hand\nedge in this tree, that represented the decision of moving rightward. And so if I have that\npattern in mind, that not only have I been able to count the number of ways that I can\nwin the game, but I also know exactly which combination of moves lead to a solution. One\nof the ways to win this game is to go down, right, right. Another way is to go right down,\nright, and the final ways to go right right down. So we can glean a lot of information\njust from the same tree structure. Cool. So I think that's enough drawing for now let's\ngo ahead and implement this in some code. Alright, programmers, here we are back in\nmy text editor. Let's go ahead and implement this grid traveler function. So you want to\ngo with that recursive strategy. So I'll start by just laying down my base cases, I already\nrefer to the fact that hey, one of our base cases is we have a one by one grid, just go\nahead and return to zero, right? So that's really easy to do. So I'll check Hey, if m\nis one, and n is one, then the answer is just trivially one. Right? Then along with that,\nI also have the base case when I had like an invalid grid. That means if either of my\ndimensions is zero, so I'm using an order here, right? If either dimension is zero,\nthen your grid is empty, which means there's definitely no way to travel from top left\nto bottom right of that grid. Cool. Then my recursive scenario is very straightforward.\nAll I need to do is get the sum between me going downward and me going rightward, right.\nSo if I go Down number n is the number of rows, if I go down that I'm decreasing the\nnumber of rows affected rows, that is by one, but I keep the same number of columns. And\nthen in a very symmetric way, if I move to the right, that means I still have the same\nnumber of rows. So I keep him, but I decrease n, right, I have one less column. So this\ncode is looking pretty sharp, really just some reminiscent Fibonacci style code. Let's\ngo ahead and give this a run. So I'm running a few examples over here. And these are the\nexpected results. In some comments, we'll go ahead and bang this one out, grid traveller.\nCool. So I get the first four results. 1336 looks like it's working just like a charm.\nHowever, for this last example of an 18 by 18 grid, looks like my programs hang right\nnow, it's actually a little too slow to calculate an 18 by 18 grid, so you probably see where\nthis one's heading. Let's go ahead back to the drawing board and really understand a\nwhy this code is fairly slow. Alright, so here we are back in the drawing board, because\nit looks like we hit a wall when it came to our recursive implementation of grid traveller.\nThat being said, I think implementing the brute force solution here is actually a really\nlogical first step. And now we can just focus in on where there is room for improvement.\nSo our first question is, you know, what is the actual time complexity of this implementation?\nWell, I know when I call a grid traveller of two, three, the full tree would explore\nis this right. And like we said, in our Fibonacci, to understand the time complexity here, it's\nreally about to understand the number of function calls we make, which is really the number\nof nodes in this tree. And of course, I want to generalize my understanding for any large\ninputs. So I know that this tree sort of looks, you know binary in a way, meaning that a node\ncan branch to up to two children, which makes sense, because from one position of the grid,\nI have two choices to make, right, I either go down or I go to the right. But that being\nsaid, I need to realize what the height of this tree is. And this one's pretty interesting,\nbecause out the gate, we actually have two input arguments to our function, I'm given\ntwo numbers, m and n. And since this function contains two inputs, it shouldn't be the case\nthat our final complexity analysis actually describes it in terms of those two number\ninputs. So what I'll do is try to recognize the height of this tree. And so I'll just\nchoose some path from the root to the leaf. And kind of in the recursive sense, that means\nI take some path from my top level call all the way down to the base case, and preferably\nthe far this base case. So I know my base cases are either when one of my arguments\nturns to zero, or when both of my arguments turn to one. And I think in general, the farther\nbase case would be a scenario where both of my arguments are one. So here I have a path\nhighlighted that ends in a one one. And in general, I know from one node to the next,\nwhat I do is either decrease the M by one, or I decrease the n by one, it's never the\ncase that I can decrease both of the numbers by one, because that would kind of entail\nthat you're moving diagonally across the grid, which is not allowed in the gameplay. So if\nI can either subtract one from em, or subtract one from n, and overall a path from my initial\ninput down to a space, like one one is going to have a distance of n plus m, we basically\nhad to subtract, you know, n and m from your initial node to reach that bottom level of\none comma one, that kind of tells me the number of levels in this tree, right using the same\narguments as before, it's still the case that most of this tree is going to be binary, meaning\nthat a node branches to two children. And so I have that two times two times two pattern\nfor the number of levels in this tree are saying that they're n plus m levels. So really,\nthe time complexity is two to the n plus m power, right. So still some sort of exponential,\nthat was just sort of the multi variable exponential, because I have two variables of m and n. And likewise, for the space complexity, you\nknow, the space complexity, in general for recursive code is just going to be the height\nof the tree, the height of the tree gives us the maximum stack depth of the recursion.\nIn this case, it'll just be the number of levels still, which is n plus m. Cool. So\nobviously, the limiting factor here seems to be that time complexity of two to the n\nplus m time. Alright, so you probably anticipated the time complexity of this one being exponential.\nThat being said, I think it's really important to still have a nice argument to you know,\nsay what the time complexity is. That way, you can get a massive buy in from your interviewer\nright. So don't skip the steps of trying to draw it out and actually defend your reason\nfor why the time complexity is exponential. But let's try to improve this now. Is there\nany room to actually improve the runtime of this function? Well, here's that same drawing,\nright? Just sort of cleaned up. So I have grid traveller of two comma three, and this\nwould be the full tree. We sort of already know now that I have this recursive tree structure.\nWhat I could possibly do is notice any duplicate work, right? Is there some work I can prevent\nmyself from doing here. So take a moment and really remind yourself of the actions we took\nin the Fibonacci problem. And see if there's any patterns in this tree, probably from the\ngate, you notice that? Oh, I have some duplicate sub trees right? Have one comma two. So in\nthese the two highlighted sub trees in blue, that's sort of asking the question, hey, what\nis the total number of ways I can travel through a one by two grid? That being said, I think\nthere's even more sub trees that correspond to that particular problem. What if you look\nat this far right subtree of two comma one, if you really, really think about it, asking\nthe number of ways to travel through a one by two grid is the same as the number of ways\nto travel through a two by one grid, you're just flipping the rows and the columns, but\nthe total number of ways should be exactly the same. So that's actually a pretty interesting\nway you can optimize this solution. So I can still memorize it. That is I have these duplicate\nsub problems. But possibly a really cool insight we can make in this problem is, you can also\nsort of flip of the arguments. In other words, if someone asked you, for grid traveler have\na comma b, then that would be the same answer for a grid traveler of B, comma a, write the\norder of the arguments technically doesn't matter here, until we can totally encode that\nin our memo object. That being said, punchline here is, we better memorize this one. So I\nthink let's hop to it. All right, here we are back in my text editor. And hopefully,\nthat diagram of how we can improve the time complexity for this one, make some sense,\nlet me go ahead and kill this program still running. And my computer's fan is actually\ngoing crazy. Now it's running the entire time. Let's go ahead and memorize this one to the\nbeauty of you know, solving these dynamic programming like problems is if we have the\ninitial strategy of implementing, like the brute force recursion, and we wrote like a\nvery well formed recursion, meaning that I actually use return values, and I reconstruct\nthe sub solutions all the way up to the tippy top. Because I have a really nice recursion\nhere. memoization is a very like formulaic pattern. So it's going to be almost the same\nstrategy, we did have Fibonacci, even other problems that we do in this lesson. So we're\ngoing to bake in my default mental as an empty object. And then along with that, I'm going\nto add my memo checking logic. So I know we're here in general, and to check, hey, are the\narguments in the memo, right, I need to key into my memory object using all of the arguments.\nNow I have two arguments. And since both of the arguments combined, sort of dictate the\noutput, I need a key that sort of contains both of those in JavaScript keys are either\nstrings or symbols. So for us right now, really, strings is the most relevant one. So what\nI'll do is I'll concatenate both of these integers together. That way, I have a string\nwhich I can key into the object with. And we'll all definitely want to do is also maybe\nseparate them with a comma, let's say, so I'll say like key equals m plus a comma, plus,\nand, and the reason that you probably want like some sort of separator between these\ntwo arguments in your key is to make sure the numbers don't get misinterpreted. So I've\nactually ran into this issue in the past, can you imagine like, if I had a scenario\nwhere, let's say m, was 42. And then we'll say n was a number\nthree. So what I don't want to do is just make my key, something like four to three,\nbecause this isn't going to uniquely identify the exact input argument, right? Because if\nthis was just my key, then I guess I have the same key for a totally separate set of\narguments. If I gave you four and 23, right, both of these combinations of very different\narguments would lead to the same key, they would collide at the same key. So instead,\nI'll prefer to put a comma between them right now I know without a doubt that this key corresponds\nto four comma 23. Right. So that's why I put a separator between them. And depending on\nthe language that you know, you're choosing for interviews, you can find a very similar\nconstruct. Cool. So now I'll go ahead and check, hey, if my key is in demo, then I have\nthe Result Cache already. So I could just return net cash value. So return memo at key.\nAnd then what I want to do is look for my old return value, right? So here's where I\nactually do the manual recursive calculation. Before I return that I want to store it in\nmy memo, using the same key and then return that thing, I just put in the memo just completing\nthe old return logic. Cool. So you've seen this pattern before, I just want to emphasize\na few things. Now it's the second time we're seeing it. memoization, for me, at least,\nis a very, very formulaic thing, right? So I always take the exact expression that I\nreturned previously, and I put that entire thing in the memo object, right? Notice that\nmy key encodes the arguments for this function, right? Mnn. Something that I've seen students\ndo in the past is do like very heavy handed logic, where they try to, you know, check\nif the child call is in the memo. In other words, don't write any pre emptive logic where\nyou check Hey, if you know m minus one And so if you like concatenate those two things\ntogether, don't check if like your child's key is in the memo, right? So imagine like,\nthis was my key right now. Right? don't check if that is in a memo. When you write logic\nlike that, it ends up being very, very duplicate and a little harder to debug, right? Instead\nof writing your function as if it's, you know, reasoning for its children calls, you know\nthat once you actually evaluate those child calls, they're going to cache themselves,\nright, they're eventually going to check this if statement anyway, alright, so don't do\nany like the look before you leap logic, just make the recursive call. That way, every recursive\ncall doesn't like self service, right? So I prefer this way implemented. And with that,\nlet's go ahead and run this code. So I'll give this a shot grid tremor, I still have\nthat 18 by 18 grid, which took quite long last time didn't actually finish while I was\nwaiting. Looks like I'm still hanging here, because I'm actually missing a little bit\nin my code. So take a moment, see if you can spot it, I forgot one really important thing.\nSo I have the logic of checking if my key exists in the memo. And I also have a logic\nof storing something in my memo if the key doesn't exist, but what I failed to do was\nactually passed down the memo object to all of the recursive calls, I want to pass it\ndown over here. Remember, the trick is only top level when someone calls like two comma\nthree for grid traveller, then we're going to initialize a brand new empty object, which\nwill be shared for the rest of the recursion, because it's passed down by reference at this\npoint. So that's a common mistake. Let's go ahead and run this now. Nice. And\nthere we have it. Look how quick our last execution was over here now is the expected\nanswer for an 18 by 18. grid. Cool. So here's what we'll do, it's evident that we definitely\nset up the execution of this one, let's head back to the drawing board to wrap up this\nproblem and really see how we cut down the complexity here. All right, so it looks like\nwe definitely improved the runtime of our function. But I want to really understand\nyou know, what the big O complexity of our improved function is now. So sort of a way\nwe constructively argue for what the new time complexity is, is to think about where the\nvalues of the nodes that will actually have to travel through. So let's say I looked at\nthis example, I wanted to find the number of voice a traveled through a four by three\ngrid, I know in general, there would be a top level node, of course, four comma three.\nBut in general, that refers to m n, right? So I'm trying to think in a very general way\nright now. And so I know when it comes to the other nodes of this tree, they're all\ngoing to sort of at most be four comma three, but then probably be less than that, right?\nThey have like a range of values for the nodes. It's not as if to solve grid traveler, four,\nthree, I would have to solve 530, right, that would be a larger grid. That doesn't make\nsense here, right? I'm shrinking the subproblems, only in this rendition of grid traveler. And\nso if I think about some possible values here, I know that if M is for top level, then all\nof the values for m in the rest of the tree would be from zero all the way up to and including\nfour, right, it's never going to be bigger than four. In a similar way, since n is three\nhere, the only possible values for n in the rest of my tree are zero through three. Right?\nSo roughly Mele, we're a little off by one here, because I have to include zero, because\nwe know that that's a base case, in our edition of this problem. That being said, there are\nroughly n choices for the first number, node, and n choices for the second number in the\nnode. And along with that, we know that we're not gonna have to travel through many duplicate\nsub trees, because we memorize them away. And so I think what I can say here is the\ntotal number of nodes you can possibly have is m times n, and I'll be the number of like\ndistinct nodes, right? Because I have m choices for the first number in the node and n choices\nfor the second number. I know that I'm going to really minimize any duplicate exploration\nthrough the memo object. So the really the implication here is we started out with our\nbrute force recursive implementation, which looked like it was exponential in the time,\nright, it was two to the n plus m time. And then by memorizing this function, we were\nable to bring it down to n m times n, time complexity, which is much faster. Notice that\nthe space complexity stays here, which is really fine, because n plus m is some sort\nof a multi linear function. Cool. So there, we have our nice optimal solution for this\ngrid traveler problem. So key thing I want you to take away from this one is, although\nthe initial narrative and the problem made it seem, you know, pretty specific, and pretty\ndifferent from a previous dynamic programming problem, like Fibonacci, was really the same\nsort of story, the most important thing that we're going to sort of leverage throughout\nin this lesson that we leverage twice already is try to think about your recursive functions\nin terms of a tree, right, I get the most information out of the tree. And then from\nthere, I can use that tree to not only implement a brute force, but to also recognize, hey,\nwhere can I optimize this brute force, that way you can reach for the optimal solution. Alright, so we've gone over two different\nproblems together, and hopefully we're starting to notice how we tackled them in similar ways.\nI think it's about Tammy gave herself some guidelines for solving dynamic programming\nproblems using a memoization strategy. So we'll call this our memorization recipe. And\nthere are three different ways you can go about learning this topic of memorization.\nAnd you might have different recommendations. This is just my particular recommendation.\nSo I think the most important thing to establish if you want to, you know, solve some dynamic\nprogramming problem using memoization, is to stick to to like high level steps, we definitely\nneed to at first just have a solution that's recursive. So just make it work could be slow,\nthat's okay. And after that, we make it efficient. I think this is where a lot of students sort\nof try to take on too much at once. They try to just solve it quickly all in one go. Right?\nTo me, it should be a very separate process, right? First, I look for correctness in my\nsolution. And then once I have correctness, then I look for efficiency in my solution.\nSo when we go through step one, if I just want to get a working solution, then I have\nto start visualizing these problems as trees in dynamic programming problems, the gist\nof them are that we have some large problem that I can break down into smaller instances\nof the same problem. So when I visualize it as a tree, what I'm looking to do is figure\nout all right, in the nodes of the tree, that should represent a problem. And when I draw\nan edge between nodes, that should be shrinking the size of the problem. And depending on\nyou know how your problem is stated, you'll have to figure out that logic, right? In the\ncase of our Fibonacci, it was as simple as we know, we can decrement our values of n.\nBut in the case of our grid traveler, what we had to do was travel rightward or downward.\nAnd once we do that, you want to implement that tree using recursion. What's great about\na tree is it's already a recursive structure. Right? So how do you start to translate that\nkind of tree visualization to some recursive code? Well, you think about the leaves of\nthat tree as your base case, right? Lately, for us, it's been about some small numbers,\nright? So like a grid of size one, or it could also be in the case of Fibonacci, just our\ninitial seed values of n equals one, and n equals two. Now, once you have that baseline\nrecursion, that's going to be your brute force solution. And so you'll want to test it. To\nme this testing step is really important, right? So if you pass inputs into your brute\nforce recursion, it should give correct answers. Although possibly for large inputs, it may\ntake a long time, right? To me, there's a big difference between code that is slow,\nand code that is wrong, right. So here, we should give back valid results, although maybe\nour code is a little slow. Once we have our working brute force solution, making it efficient\nusing memorization is a very, very canned scenario. All we do is start by adding a memo\nobject into the mix. So this memo object needs to have keys which represent arguments to\nour function. And the values of that object represent the return values for those function\ncalls. We know that in our functions, a unique set of arguments should give me a particular\nresult. So we're just having that sort of mapping inside of an object, you need to make\nsure that this object is shared among all of your recursive calls. One way you can do\nthat is to pass them along as arguments. And lately, I've been doing that by giving myself\na default empty object at the top of each of my recursive calls right through my top\nlevel call. And once we do that, we need to add a new base case into our code. So I'm\nnot going to remove any of the old base cases, from my brute force solution to me, I'm just\nadding a new base case that captures the memo. In other words, if my arguments are in the\nmemo object as a key, then I'll return the stored value, I refer to that as like my memo\nfetching logic, right? Looking up some stored value in my memo. And beyond that, the only\nthing we need to do is implement our memo storing logic. And it's as simple as going\nto exactly where we had our return values in our function. And then we just make sure\nthat we add those return values into our memo object before returning, right, so I always\nlook to the exact return expression, and just write some code around it, right storing that\nresult into another mental object before I return it, right? Step two is actually very,\nvery easy to implement, meaning it's very easy to memorize a brute force solution, it's\nreally coming up with the brute force in the first place, that kind of feels more difficult.\nSo as you're learning and practicing memorization for these dynamic programming problems, I\nhighly, highly recommend you stay very methodical, and follow these steps, right? Don't try to\nefficiently implement an algorithm from the get go get a brute force working solution\nwith recursion, and then implement it using memoization. Afterwards, right. And as you\nget more practice with this technique, soon, you'll be able to do everything all in one\nswoop, but I don't recommend that until you've definitely finished this course. So we'll be sure to follow these rules for\nfalling problems. Alright, so I think it's tempting increase a difficulty and we're going\nto know Their dynamic programming problem. So let's work on this can some function, what\nI need to do here is take in a target some as an argument, as well as an array of numbers\nby function needs to return a Boolean. So true or false, indicating whether or not it\nis possible to generate the target some using some numbers from the array. And along with\nthat, we have some constraints here, we can totally use an element of the array as many\ntimes as we want. And we can also assume that all input numbers, so the target sum as well\nas the numbers of the array are non negative. So let's try to understand what this question\nis asking. Let's say I gave you this example case. So it looks like our targets, I'm a\nseven, and the array of numbers is 534, and seven, here, the response should be true because\nit is possible to generate seven, by adding some amount of numbers from the array, one\nway you can generate seven is by just doing three plus four, another way would actually\nbe to just take the loan seven, because seven is actually a member of the array. So it's\ndefinitely possible to generate seven using, you know, some amount of numbers from the\narray. So that's why we return true. Let's see, I gave you another example. Let's say\nI gave you a target sum of seven again, but I gave you a different array of just two and\nfour, this is actually going to return false, because there is no possible way that combinations\nof two and four can actually sum to seven. Cool. So that's really what the question is\nasking. Now let's try to think about how we can frame this problem of recursively. Right?\nHopefully, you've already gathered in your mind. If we have a smaller amount of targets\nsome, then they'll tend to be a smaller, easier problem than a larger number for targets.\nAll right, so let's start to think about the recursive structure. For the first example,\nwe know in the long run, we should be able to derive the answer true from the string\nthat we make. So like, we always say, we should encode the arguments to our function into\nthe nodes of our drawing. That being said, since in the problem, they told us that we\ncan reuse an element of the numbers array as many times as we need, I'm just going to\nomit that from the node drunk, because basically, every node every function call is going to\nreceive the same array. So I'll just list the target sum in every node. So I start with\nseven, and I have to think about how I can transition to other nodes, right? How can\nI shrink the size of this problem? Well, I know that I only have, you know, four options\nI can take right have an option for every element of the array. So basically, if I'm\nat this seven node top level, I can branch to some children, and sort of the rule for\nmy transition is you can either take a five, take a three, take a four, take a seven. And\nif I actually take you know those elements as a choice, they are going to decrease my\ncurrent target sum. In other words, seven minus five is two, seven minus three is four,\nseven minus four is three. And of course, seven minus seven is zero. So notice, we have\na very particular rule from traveling from a parent node to some child, I can just carry\nover this pattern. However, we have to watch out right, so let's say I tried to flesh out\nthis note where my target sum is two, if I look at the options I have, right, I still\nhave the options of 534, and seven, however, none of them are really compatible with this\ntarget sum of two, right, what I don't want to do is take any of these choices, because\nthat would kind of give me a negative target sum. So I can't really flesh out this note\ntwo anymore. That is there are no valid options for this node. However, some of these other\nnodes like this for to have valid options. So what I can do is take a three or take a\nfour, and of course, I get a one and zero respectively. And I'll also do this for the\nthree over here, right? For this three node, I can only take a minus three as a choice.\nCool. If I look at all of the nodes that I have, now, I like the leaf level, it looks\nlike they all sort of bottom out at a base case, that is there is no further choices\nwe can take. And I also noticed that some of my nodes have a zero in them, if I look\nat the notes that have a zero in them, they actually are a really nice base case, because\nI basically have found that I can generate to the original target sum right away, you\ncan kind of understand the base case, when the target sum is zero is you can always generate\na sum of zero by taking no elements from the array, right? So these zero nodes are trivially\nsolved. And to me, they should return a true backup to their parent, right. And it's sort\nof on the flip side for all of my nodes that are not zero. And they also can't break down\ninto any further nodes. Those return false, right? Because they kind of have a leftover.\nAnd I know there are no possible options I can take to reduce that further. So all of\nthese other nodes should return false to their parent. And remember what this question is\nasking, right? It's really asking, Hey, is it possible at all to generate the original\ntarget sum? And so the logic is when these values these Boolean values return to their\nparent, the parent should just check if at least one of them is true. And if at least\none of them is true, then that parent should also return true. And if I look at this for\nnote, have a tree above it, and that sort of answers the question, Hey, can I generate\na sum of four using elements of the array and you totally can because if you look at\nthe elements of the array, there is exactly one for so I can just take that into my son.\nSo I'll be sure to bubble up, you know all these Boolean values to their parent. And\nagain at the parent will just make sure that at least one of the values that gets back\nis true. And so if at least one of them is true, then the parent itself will also return\ntrue. So very reminiscent of some like Fibonacci bubbling up pattern as well as our grid traveller,\nexcept now we're kind of adapting this for some boolean data, but it's really the same\nstructural understanding I have. Cool. So that was an example where we said true, right,\nthere is a way to generate the sum. Let's look at another example. Right? How do we\nknow the flip side. So if we have this example, right, seven, and an array of two, four, in\nthe long run, that's gonna return false, right, there's no possible way you can generate that\ntarget sum of seven. So the tree for this example would look like this. So this is a\nfull tree. Notice that all of the leaves get as low as one, but they can't be broken down\nany further. Like we just said, in our last sketch all of these ones, since they can't\nbe broken down any further, and they haven't reached zero, they're going to return a false\nup to the parent. And I know that if I bubble up all these false values, of course, a top\nlevel call will also return false. Right? So it looks like a key insight we have for\nthis problem is, if we find at least, you know, one base case that returns true, I know\nthat I can sort of stop early and just return true all the way up to my parent, because\nthey're not really asking like, how many ways can you generate the target sum? They're just\nasking, Hey, yes or no, can you generate the target sum at all. So that's gonna be a really\nnice way to implement this code. I think we're ready to jump right into the code. So let's\ndo it. Okay, so let's go ahead and implement this can sum function. So since we're going\nto solve it recursively, I think a good starting place, as always, is to maybe handle some\nof the base cases. So when we drew up the tree, I noticed that one of our base cases\nwas when the target sum reaches the value zero, right? If our target sum is zero, then\nwe have like, basically trivially solved the problem, because you can definitely always\ngenerate the target sum of zero by taking no numbers from the array, right? So I'm going\nto return true. If ever I reach a zero, then Apart from that, I think let's go ahead and\nwork on the recursive scenario. So I know that I need to establish some logic where\nI make a recursive call or a branch for every element of the numbers array. So what I'll\ndo is I'll iterate through that array of numbers. So I'll use some for let of syntax we'll say\nlet num of the numbers, right. So if you're unfamiliar with the syntax, all it does is\niterate through every element of the array. So for example, let's say I just called the\nfirst example for can sum of seven, and an array of two, three, if I just console dot\nlog, the num, I'm just going to see the elements printed out of two, three, right, so let's\ngive this a quick spot check. Nice, so just iterating through every number of the array,\nno tricks here. But now that I have that number, I need the branching logic. So remember, the\nlogic we use for transitioning from one node of the tree to the next, what we did was subtract\nour current choice of number from the target sum, and they basically gave us like the new\ntarget sum. So I'm going to express that and maybe some variable, so I'll say, Alright,\nI'm going to generate the remainder by calculating the difference between the target sum and\nthe number, right, so I'm just subtracting the number from my target sum, that gives\nme my new remainder, which becomes a target sum. Right? So at this point, I think I need\nto call recursively on can some of our pass in this remaining quantity? It doesn't need a second argument, still,\nI'm still gonna pass in the same exact numbers array. So I'll still pass in numbers unchanged.\nI think that you know, the fact that we pass in the same exact numbers, right, it's pretty\nconsistent with the way they stated the problem, because we can totally reuse the numbers of\nthe array as many times as we like. Cool. So now that I'm using our function, again,\nI'm making the recursive call, I want to think about what this call will return. I know at\nany point in time, my can sum function is going to return Boolean. And what's great\nabout boolean data is there's only two possibilities, right, either true or false. So I think, based\non what we said about the tree was, if this call, if that returns true, then I can just\nultimately respond with a true right now. So I'll write it like this. So this is saying,\nAll right, if we figure out that it is possible to generate the remainder now using numbers\nof the array, then I can return true for this larger problem of target some, right? So if\nI find at least one way that works out, then I'm going to do an early return true. And\nthe really important pattern here is we don't want to write the LS and then return false.\nInstead, we'll want to return false after the for loop. And so here's the reason why\nyou want to return false after the for loop. I only know that after I attempted you know\nall possibilities and I found that none of them worked out Can I actually say that it\nis impossible to generate the target some Right, so I need to make sure that this for\nloop tries all possibilities of number. Before I can say false, the target sum cannot be\ngenerated. That being said, there's one thing we should add to our code. So if you look\nat line six, all right, I'm subtracting our choice of num from the target sum. And that\nmeans that sometimes the remainder might become negative. So remembering our tree structure,\nwe made sure to sort of return a false whenever we had a sum note, I didn't do any branching.\nTo kind of account for that I can kind of bake that into another base case. But this\ntime, make sure it doesn't return true. So I'll say, you know, if my target sum is negative,\nif it's less than zero, then you've gone too far. And you can just return false. Here,\nit's safe to just automatically return false if your target sum hits something less than\nzero, because you've gone too far. And there's really nothing else you can add from the numbers\narray to ever fix that negative target sum. Remember, they told us in the problem, that\nyour numbers are always going to be provided as positive numbers or just zero, right? So\nlet's go ahead and give this a go. So I'll try all of these examples. And we'll see what\nwe get. So I expect a true true false, true, false. Cool, so looks like a few of them are\nworking right, it looks like the first four are working totally fine. But looks like on\nthat last example, my program still running. And if you notice, I chose a pretty large\nvalue for em. So kind of like we expect this solution has correctness. But it possibly\nlacks some efficiency, it looks like it just finished, the definitely took way too long.\nAnd so it's a very interesting example of a slow input to can some, because for one,\nthe length of the array is pretty sure I only gave two elements here. But it seems like\nthis number as a target sum really affected the runtime. So we'll do, let's head back\nto the drawing board, and talk about the complexity of this baseline solution. Alright, so we\nimplemented the brute force for our khamsum. But obviously, now we want to make it a little\nfaster. But before we kind of just jump into memorizing the solution, let's at least describe\nthe complexity of our current brute force. So let's try to visualize this example. So\nI have a target sum of eight. And my choices for my numbers are two, three and five. In\nthe long run, they should return true, the visual for the full tree would look something\nlike this, notice that it's fairly large tree of forbs and relatively small inputs, right,\nI only have a target sum of eight, and only three choices. So let's try to describe the\ncomplexity of this, I'll sort of generalize the shape of it, get rid of those numbers.\nSo this is the overall shape of the tree. And I know I want to describe my complexity\nin terms of the input to my function, this function has two inputs to the right, I'll\nsay that M is the size of the target sum, and n is the length of the array I'm given,\nI know that both of these arguments definitely have an effect on the dimensions of this tree.\nSo like we did in all of our other examples, I'll start by maybe analyzing the height of\nthis tree, that is a what would be the maximal distance from the top level call to a base\ncase, or in the structure of the tree, what is the maximal distance from the root of the\ntree to the farthest leaf. So if you sort of imagine that, we have\nm as the root of the tree, imagine that along the left hand path, we just did a minus one\nall the way down, right? So we kept taking a minus one, right? In the worst case, maybe\nthere's a minus one present in our a numbers array. In the worst case, the distance from\nthe root to a base case would be exactly m, because you have to subtract one m times,\nright. So I can basically say that the height of this tree is M. And it kind of like we\nsaid in our other problems, that means that the number of levels is m right. So now that\nI've identified the height of this tree, the move is now to identify the branching factor.\nThat is, how does the number of nodes change from one level to the next. Remember that\ninitially, we described this particular tree example is having numbers array length of\nthree. And you'll notice that the maximum branching factor is exactly three or in general,\nN, right? because n is the length of the array. So for example, if I had three numbers in\nthe array, then a node would have at most three children, right? Cuz you have three\noptions to take. We've seen this pattern before I have n levels, and from one level to the\nnext, I would multiply the number of nodes by n, right? This is the same thing as saying,\nHey, we take n and multiply it by itself, m times. And this would definitely give us\nan exponential complexity, right in particular, and to the M time complexity, like we always\nsay another great thing about this type of diagram is we can also derive the space complexity,\nright? So what would be the space used by the call stack, it would really just be the\nheight of the tree, which we already described as M. So overall, our brute force is looking\nat an end to the M time complexity, and M space complexity. So now that we actually\nhave you know those concrete numbers for our complexity, let's go ahead and focus on how\nyou can truly improve this So here's again, the drawing for this particular example. It's\na fairly large one. And typically, you know, when you're trying to notice where there is\nroom to be optimized, you might have to give yourself a sufficiently large example to see\nthese scenarios. So in this example, I do have overlapping subproblems. And in the context\nof my tree, that means I have duplicate sub trees. So I can look at possibly this subtree\nrooted at three, notice that the root of that subtree is trying to answer the question,\nHey, can I generate a target sum of three using the array? And of course, once you find\nthat answer, that answer is never going to change for your target sum of three, right?\nSo I know that all three of these sub trees are trying to ask the same problem. And so\nwhat I'll do is I'll just cache those results in my memo object like we always do. Let's\ngo ahead and work on that. All right, welcome back to my code editor. And same stuff, different\ndays. Let's go ahead and minimalize. This can sum function, right. Once we've established\nthe brute force through the recursion, then memorization is pretty formulaic. Right? Alright.\nSo we'll start by just baking in our memo object like we usually do. So if someone calls\nour function without a third argument that is like a top level call, we'll be sure to\ngive them a new object. And I'll, before I forget, be sure to pass down this memo object,\nI'm going to make sure that every top level call and it's recursive tree shares the same\nmemo object. But now I need to figure out what what should I use to key into the memo\nobject. So here I have two arguments of my original function are I have targets summon\nnumbers, what I want to do is try to notice, you know, which of these arguments is actually\ngoing to directly impact the return value. So I know that through the recursive calls\nlike this call over here, the numbers argument doesn't change. And so if it doesn't change,\nthen right now, it doesn't really affect other return value. So I'd be okay to just use the\ntarget sum as the key into this memo. So we'll go ahead and do that. So I'll check if my\ntarget sum is in the memo, that I've seen that sub problem before, so I can just return\nthe stored value. Cool. And now I have my, you know, memo fetching logic. But now I need\nto actually store things in the memo. And the trick is, what I want to do is look at\nall of the return values that were not base cases, and I need to now store them in my\nmemo. So I have to return values here, right, these two lines, lines, 10 and 14. And so\nI need to store data into the memo for both of those lines, it's as simple as quite literally\ngoing into your memo using your key, so target some, and then assigning the value we just\nreturned. So I'll just write it like this. And this\nis going to be sort of a hard and fast rule, you can always use our for a memorizing a\nbrute force recursive function, right. So I'm just going to take exactly the lines or\nthe expressions that I returned in the recursive scenarios. And now just store them in the\nmemo. Cool. So let's go ahead and give this a shot, this code is looking pretty good.\nAnd remember before this last call with an input of target, some 300 took notice will\nbe long. But I think now when I give this a shot, right, it finishes really quick. So\nthis is going to be a nice optimized solution for cancer. Really, most of the work of this\nproblem was done in the brute force. And then afterwards, it's really just a minor adjustment\nto make it efficient. So to wrap up this problem, let's go ahead back to the drawing board and\ntalk about the improved complexity. So we definitely memorize the heck out of that code.\nBut let's recap by just understanding what the new complexity is. So again, we're saying\nthat M is the target sum, and n is the length of the array. Initially, we said that our\nbrute force solution had an end to the M time complexity, which is exponential. And actually,\nonce we memorized it, we really cut down on that complexity, we brought it down to n m\ntimes n type complexity. And so here we say that the memo is complexity is now m times\nn, because of the memo object, right? We know that the value of the nodes in the tree are\njust going to be values up to m or their m different possible values we can have in a\nnode. However, it now since we are able to cache values or cache results inside of the\nmemo object, I'm never gonna have to re explore a subtree before M. That being said, I select\nthe branch and times for each of those nodes, right. So overall, I have m times n nodes. So hopefully that can some problem made some\nsense, because we want to do now is actually carryover a lot of that knowledge to solve\nthis new Howsam problem. So this problem is very similar, it still asks us to take in\nsome target some an array of numbers, but this time around, we want to do is return\nan array containing a combination that adds up to exactly the target sum. And if there's\nnot any combination that actually leads to the target some, then I should just return\nnull. Along with that, if there are many possible combinations that can reach the target some\nthat that can return any of those. So you probably Already recognizing that this house\nsome problem is very similar in logical structure to the can some problem right? instead of\nreturning a Boolean instead now I want to return exactly the combination of elements\nof the numbers array that leads to my target sum, so it's a little more involved. That\nbeing said, let's take a look at some examples to make sure we're on the same page. So let's\nsay someone asked us to calculate how some and our target was seven, and our array of\nnumbers are 534, and seven. So there are actually a few different combinations that can give\nyou your target sum of seven. One way would be to take three plus four, that's one possible\nanswer, another possible answer would just be returning an array of seven. So no matter\nwhich combination array you return, it'll be considered correct in either scenario.\nLet's say I gave you another example, where your target sum was eight, and your choice\nof numbers were two, three and five. One possible solution for a combination is two plus two\nplus two plus two, right? So I returned that in an array, another combination would be\njust three plus five, notice that no matter what we're always looking to get back in array,\nif it is possible that our target sum can be generated. But let's look at the flip side.\nLet's say that we were given this input, so I have a target sum of seven, and my array\nof numbers is just two and four, the first thing we notice is it is not possible to actually\ngenerate the target sum of seven. Like they said, the problem in this scenario, what you\nwant to do is return Nome sort of symbolize that, hey, it's not possible to generate any\ncombination that leads to the target sum. All right, I think it's important that we\nthink about one more scenario. So let's say that I was given a target sum of zero. And\nwe were given really any array of numbers. In this case, I just gave us one, two, and\nthree, we already know that in our previous problem, we had to return a Boolean result,\nwe use the target sum of zero as a base case. And so what I want to think about now is how\nis the target sum of zero just trivially solved? Well, if I want to know the combination that\nsums to zero, and that's really just the empty combination, right. So I think the logical\nresult here is to return an empty array, when your target sum is zero. Remember that an\narray represents a combination. And if I have an empty array, that means I take no elements\ninto my combination, right? If I summed up all the elements in that empty array, it would\nindeed have a sum of zero. So that's going to be a really important facet that we need\nto encode into our logical tree that we draw next, as well as our code, right. So let's\ntake a look at how we can structure the tree and try to take a step toward really understanding\nhow we can implement it in some code. So let's say we're stepping through this particular\nexample of target sum of seven, as well as an array of 534, and seven. So the full tree\nand really the same tree that we drew last time would look something like this. from\nthe get go, I see that I have some scenarios or some nodes where I reach zero, which means\nthat it's definitely possible to generate the target sum. That being said, How can I\nget back a valid result, right, so I need to return an array. So you sort of reframe\nthis problem in that, all right, all of these base cases that have a target sum of zero,\nthey are trivially solved because they are combination would just be the empty array.\nRight. So for now, I'll just kind of trace through how one of these base cases would\nreturn. So I know that this particular zero is going to return an empty array. And like\nwe always say, when it returns, it's really returning that information to its parent,\nright. So this array sort of bubbles up to its parent. And now what I want to do is actually\nmanipulate this return value, I want to add something to it. So I want to really put the\nnumber that brought me to that zero in the first place. And that would really be the\nchoice of four. So notice along the edge, I have them labeled with a minus four, meaning\nthat, hey, I took a choice of four. And I want to actually add that choice into the\ncurrent array. So I'll just really push it into the right, of course, I actually don't\nneed a negative sign that was just for the sake of understanding the math here. But now\nthat my call to how some of four is returning an array of four, that array bubbles up to\nits parent. And of course, now I need to push that edge that I took, which would be that\nthree, so that three gets pushed to the rear as well. And if I look at what I'm seeing\nright now, it looks like above the seven, we have an array of four, three, which makes\nsense, because you can totally generate a target sum of seven by doing four plus three,\nawesome. So four comma three would be a valid answer in this particular problem. But like\nthey said, you could return really any valid combination if one exists. So let's say we\nretrace through this far right base case, we know that this zero is going to return\nan empty array, that empty array will be returned to the parent. But we also have to add the\nvalue according to the edge, right? So I would press seven in this array. And that makes\nsense because I could generate the target sum of seven by just summing up a loan seven.\nSo that's still good to go. So I'm feeling pretty good about how we can return a valid\ncombination if one exists about let's say, there are some options that we take that don't\nwork out. So for example, let's say we explored this node first, right? This was the first\nbase case we had and logically in the space of our code, it really would be right. So\nI know that this node can't really branch out any further. So it's sort of a dead end.\nThis is a node that should work Turn no meaning that, hey, there is no way I can generate\na target sum of two using elements in the array. Or if you look at the elements of the\narray, they're all too big, right? So I know that this base case is going to return null.\nBut along with that, if you look at the next base case, we would hit it would be this one,\nwhich also returns Now, if you look at the next base case, to the right, that's actually\nan affirmative one that should return an empty array. So it's kind of reasoned out how these\nreturn values should be considered at their parents. So I know that both of these values,\nbut to the left of the node four would return, right, so it kind of bubbles up a little bit.\nBut for the array on the right hand side, I would also have to push the edge that I\ntook, which was a four in this scenario. So now I'm sort of comparing you know, the nollan,\nthis four, or really, I'm comparing all of the branches that I take from a node. And\nif at least one of the branches gives me back an array that I know that it's possible, right?\nSo basically, in this scenario, the array of four actually wins out over the null, right,\nI know it's possible to generate a four. And I'll just continue this process, right, now\nI can return these two values to its parent. So let's I'm considering them at seven. In\nthe same way, I would have to add the edge I took, which would be a three on this array.\nAnd then from there, I know the array would always override the null, right? So I could\njust ultimately return this four comma three. And a really nice pattern in this code is,\nas soon as we find a winning path through the tree, or that is we find a combination\nthat creates a target sum, we can actually return early because we don't need to really\ntravel through the rest of this tree. We don't need to explore any other options because\nthey're happy with at least one combination. Right? Awesome. So again, to recap, the punchline\nis for this tree, I have the information for a combination, encoded as a path through edges\nof this tree, right, so I've looked at this path I have highlighted in yellow, I see that\nI took a three followed by four. And that eventually led to a zero. So I know that one\nvalid combination would be four comma three. All right, at this point, I'm feeling pretty\ngood. Let's go ahead and work on the code for this now. All right, here we are back\nin my code editor, let's work on solving the house implementation. So the codes going to\nbe pretty similar to the cancer problem, it's the really the whole point, we're just kind\nof going to finesse the return date over here, we're gonna have a very similar base case,\nlike we said, in the tree diagram, whenever we have a target sum, that's zero, we have\ntrivially solved the problem, because I could just return an empty array. And a similar\nway, what we can do is also have a separate base case, if our target sum ever reaches\na negative quantity, then I'll just return null. That's because it's never possible to\ngenerate a negative target sum, right? Remember, in this problem, the array of numbers is only\ngoing to be positive ones. Cool. We ended up writing very similar base cases for our\nlast problem, except now instead of returning true, we return an empty array. And instead\nof returning false, we return nil. Nice. So let's go ahead and get the branching logic.\nRight, how do I want to make my recursive calls, I'm going to need to make a recursive\ncall for every element of the numbers array. So I'll say, let num of numbers, we'll just\niterate through every number of this array. And I'll go ahead and do the same logic as\nlast time. So I'll subtract the number from my target sum, they'll give me my remainder,\nright? So remainder equals target sum minus mine number. Cool. So this remainder is now\nwhat I want to find the combination for, right? So here, I would make my recursive call. So\nhow some pass in the remainder. And the second argument will stay exactly the same. I'm going\nto pass along the same exact numbers array. I don't need to remove anything from the numbers,\nright? Because they tell us in the problem that we can reuse the elements however we see fit, right. Cool. So now I\nneed to really think about what type how some returns. So this problem is interesting, because\nwe basically have two different types, right, we could get back in array of some elements,\nif it is possible to generate the remainder, or we can get back know, when it's not possible\nto generate the remainder. I think no matter what I get back, I'm just going to save into\na variable. So I'll say console, this is the result for the remainder. I'll call it remainder\nresult. Cool. So I know that in the context of like how I thought about this logic in\nterms of the tree, I wanted to basically do an early return if I found a valid combination.\nAnd so I'll go ahead and check you know, if the remainder result is not No. So the implication\nif I enter this if statement, that means that it is possible to generate the remainder.\nAnd so what I can do is just return early and I can return of basically almost the same\nremainder is also the same array. However, I need to make sure I include the element\nthat I took recall from the diagram, whenever we had a recursive call that returned in array,\nthe parent had to also add the number that it took transition to that recursive call\nin the first place, right. So in the context of the tree, I had to put the labels of the\nedges into the array here. means I have to put the num into this array. So some syntax\nI can use for that. So use some spread operator. So I can copy all the elements of the remainder\nresult into this new array. But I'll also add on the number I just took, right. So all\nI'm doing in this return line is, I'm returning basically the same array that I get back from\nmy recursive call, with the number added to the end of it. Let's say you're unfamiliar\nwith this syntax, I can preview it really quick. It's pretty neat. Let's hop into the,\nyou know, repple. So let's say I had some array, let's say it was this array of just\na, b, c, sort of an isolated example, you can use the spread operator, which is the\nthree dots here to like unpack an array. And you can sort of say like, new array equals\nbracket. So this gives me a new literal array, I can spread out the elements of the old R,\nright? So if I do that, the new array just has all of those same elements, vi, capitalize\nthat and properly, cool, we can extend that syntax, right. So I still have that array\nof ABC. Let's say I had another variable, we'll call it other array, what I can do is\ncreate a new literal array, copy all the elements from our using the spread operator. And then\nI can comma, separate any additional things I want to add while I'm here. So let's say\nI added a z. So if I look at my other array, now, it contains ABC, and also this new element\nz. So it's all I'm doing on this slide, right? I'm returning the same combination, that my\nrecursive call gives back with the number that I took are added to the end of it. Cool.\nSo what's really nice about this code is it's very reminiscent to our previous code, because\nwe have an early return. So if I find at least one way, to generate the target sum, I can\njust go ahead and return that first way that I found, right, they say we can return any\nvalid combination here. But let's say this for loop finished, and we never found a valid\nway to generate the target sum, then after the for loop, you can just return null, because\nit's not possible not to generate the target sum, apparently. Cool. So this code is looking\npretty good. I think let's let's give it a shot. It goes without saying no, sometimes\nthe remainder right will become negative. But we already handled that with this nice\nbase case, right. So let's test this code. So I already have some example outputs over\nhere. So looks like our first few examples are working. Obviously, our last one seems\nto take quite a long time. So I'll just kill this program early. But before we talk about\nhow to optimize for this larger example over here, if you look at these other examples,\nwhat I can see is this array of 322 does add to seven. So that's looking good. This array\nof four, three, also adds to seven. So that's good. We already saw that this example of\nseven and two for now, that's your return No, because it's not possible generate that\nsum. And it looks like the array for the eight example is also good to go. So notice here,\nthere are also some other arrays that we could have returned and would still be considered\nvalid output, the exact combinations that we get back are really just dictated by the\norder that we happen to iterate in the array. So for example, let's say I switch things\naround here, like I did 352, it's really the same array, just in a different order, we'll\nprobably get a different answer for that particular one, right? So I'll run this now, notice I\nget 233. But either case, that still sums to eight, so we're totally good to go. Awesome. They bring this\nback to the original code. And yeah, it seems that now the limiting factor seems to be the\nspeed of our solution, right? We've been here before. And so let's go ahead and talk about\nthe complexity of it. So we know that the time complexity for this is almost identical\nto what we did in the cancer problem, which is conveniently over here. But sort of refresh.\nBy now you recognize that all right, the time complexity should be described in terms of\nlike the recursive tree, let's let's lay down the foundation. And we already know that M,\nwe're going to call the target sum. And let's also say that n is the numbers dot length.\nCool. And so if I think about the number of recursive calls that I'm going to make, it's\nreally the same as last time, right? So I'm going to say that, hey, the time of this function\nseems to be Oh, and I have an exponential, the base of the exponent is the branching\nfactor, which is the length of the array. And then the depth of the tree would be the\nexponent, which is just m, right. So this was the same time complexity as last time\nfor a brute force writes M to the M power. However, it looks like we have some additional\ntime that we consume in this function really coming from this expression, right. So if\nI look at line nine, in particular, this line creates a copy of an array. So that will actually\ntake sort of a linear number of steps to copy over every element of an array right. So I\nwill have to consider the cost of this operation. It sort of under the hood like iterates through\nthe remaining result, I know that the maximal length of the remainder result I can get back\nwill be at most m, right? Remember that remainder result in the worst case is going to be in\narray, the longest that array could be is exactly the target sum, right? Imagine that\nwe had the most simple, you know, sort of a combination to generate the target sum.\nIf it was just a bunch of ones, right, my target sum was 50. And I had an array filled\nwith one, then I can just do one plus one plus one plus 150 times to generate the target\nsum. So in the worst case, this copying operation will take m steps, I need to do that for every\nrecursive call. And so if I have this many number of recursive calls, in addition to\nthat, I do an M operation, you just multiply that M, right. So the time complexity for\nthis brute force so far, is n to the n power times M. Really, the thing we want to optimize\naway is this exponential part, right? So I really want to focus in on that. But while\nwe're here, let's go ahead and talk about the space of this brute force. So the space,\nthere are things to consider the terms of the stack space, it's going to be the same\nas last time, so it's going to be o of m. But think about any other space I use up I\nguess you should also consider the array that you return back, whoever we know that we're\ngoing to return back like the first array that we find all the way back up to the top\nlevel call. And the combined length of all of those arrays that we return is really just\ngoing to be in worst case, M. Right. So I would still say that the space complexity\nfor this function is just m right now. Cool. Obviously, let's work on optimizing this time\ncomplexity. So this was the brute force. So brute force. And you guessed it, and there\nis definitely some people get some problems in this brute force. So we'll just memorize\nit away. So very formulaic stuff, most of the work is always the brute force. So I'll\nstart with my empty mental object. And like we always say, we'll use the target sum as\nour key. So if I've seen the target sum before, that is if it's in the memo, then I'll return\nwhat I have stored in the Mo. And at this point, what I want to do is make sure I pass\nalong the same memo object to all of the recursive calls. That way, they can benefit from any\ninformation or any sub problems that I worked on over here, right in this stack frame. Cool.\nAt this point, I need to make sure that I take all of the return lines that I had before,\nand I store them in the memo, right? So the trick here is I can say, memo of target. So\nI'm going to save that array. So notice that now the values in the array, or sorry, the\nvalues in the memo object are going to be arrays, because that's the return value of\nthis. It's either going to be an array or not right? So I'm just going to complete this\nreturn value by returning what I just put in the memo. And in a similar way, I also want to memorize\nthis late return. So we'll also be memo of target sum equals No, I can just still return\nNo. Cool. So with that change, right, it's very, very straightforward change. Let's see\nhow this does. Now. I know that for this last example of how some 300, it is not possible\nto generate the sum of 300 using just sevens and fourteens. So should we get an all for\nthat one. So let's give that a shot. Nice. And there, we have a really quick running\na know of that very last example. So we definitely had an effect on the runtime here. Let's talk\nabout how we changed up the complexity of this code. So that was a brute force. Let's\ntalk about the memoized version. So it's good with the time over here. So we know that in\nterms of the time complexity from the number of recursive calls that we make, it's the\nsame story as our last problem, right? We just have to consider any other time operations,\nwhich would still be this array copying. So but in just terms of the recursive calls that\nwe make, it's going to be n times m, recursive calls. And then in each recursive call, I\nneed to do this copying pattern, right copying over the contents of an array, and the array\nwill be at most m elements long. Alright, so if I have this many recursive calls, and\neach recursive call needs to make an M length operation, now I just multiplied by another\nm term. So right now this looks like n times m times m, which is the same as n times m\nsquared. And I'll talk about the space complexity. So the space complexity will be at least as\nbig as our brute force, so it's going to be at least o of M, above, now we have to consider\nall the space we use up in the memo object. So I think about the keys of this memo object,\nthe keys are just going to be all unique values of target sum, right? Because I just literally\nuse target sum as a key on all these lines, right? But then everything about the value\nor the values are going to be Pretty chunky now, because sometimes of value but in the\nobject is going to be an array. And I already said that the maximal length of any of these\narrays that I returned is going to be of length M. Right. So to me, it's now the case that\nyour space complexity comes from mostly your mental object, which is going to be of size,\nm times m, right, because you have m keys. And each key has a value, which is, at worst\ngoing to be an array of M elements. So it's m times m, which is m squared. Cool. Notice\nthat we definitely cut down on the brute force implementation, especially in terms of the\ntime complexity, obviously, there was a little trade off that we made here. But now we're\nable to run our house and function in a reasonable amount of time. So to wrap up this problem,\nlet's go ahead and hop back into the drawing board. Alright, now that we coded the house\nand prom, let's wrap it up by actually analyzing the complexity of it. So recall that for our\nhouse, some problem, we have multiple arguments, right, so I need to describe them. So I'll\nsay that m is my target sum, and n is the length of the array. Remember that the array\ncontains the choices we can take. And our baseline solution, that is our brute force\nrecursion had an exponential time complexity, right? It was kind of in the form of n to\nthe n power times M. And after we actually optimize it using the memorization strategy,\nwe actually reduced it from exponential down to a polynomial time complexity. In particular,\nour new time complexity was n times m squared. So really important fact about our memoized\nhave complexities, it is no longer exponential. Please recall that when we have m squared,\nthat is not exponential, because the exponent is a constant number. Cool. If I look at the\nthe space complexity for this, I had to actually pay a little more cost in terms of the space\nbecause of the memoized object. But that space complexity we use up is still not exponential,\nright? Still a polynomial or quadratic complexity. So I'm still satisfied with it overall. So\nwe definitely prefer this memo is complexity over the brute force. All right, that was\nthe how some problem but now let's go over one more variation of it. In this problem, I'll still give you a target\nsum as well as an array of numbers to choose from. But this time, what you want to do is\nreturn an array containing the shortest combination of numbers, that adds up to the target sum.\nAnd along with that, if there's any ties for the shortest combination, you can return any\nof those shortest ones. So from this description, you probably recognize that this is similar\nto our last few problems. But now they're asking for a little bit of an optimization,\nright? So I want the shortest sums, that means an array containing the least amount of numbers,\nbut it still adds up to the target sum. So we're really just going to add on top of our\nprevious understanding, let's take a look at a few examples. So let's say I gave you\nthis example. So here, my target is seven, and the numbers I choose from are 534, and\nseven. So there are a few different ways you can generate your target of seven, one way\nwould be to do three plus four, that's one combination. But another way would be just\ntake the seven because notice that seven is actually a member of the array. And here I\nwant to choose the smallest array, which would be just the lone seven. So that would be the\nexpected result for this one. In a similar way, let's see, I gave you a target sum of\neight. And your choice of numbers were two, three and five, there are plenty of ways to\ngenerate eight, you can do two plus two plus two plus two, or you can do two plus three\nplus three, or you can just do it three plus five. And here, I want to return always the\nshortest combination, which would be the three plus five. So that would be the result over\nhere. Cool. So we definitely have some awareness that Alright, this problem is similar in structure\nto our previous one where I need to sort of generate a way to make the target sum. But\nnow I want to really specify the shortest array, right? So let's try to visualize this\nas a tree. Like always, let's say we're stepping through this example, with the target sum\nof eight. So we know that the full tree would look like this. And we've seen this tree before.\nBut now what we're trying to do is come up with a different process for the value your\nreturn, right, it's no longer going to be valid to just return the first way that I\nfind to generate the target sum. Now I want the best way. So let's start coming up with\nthe strategy for this. At this point, we know that we can definitely implement some logic\nin our code where we return an array up our recursive calls, we did that in the last problem.\nSo here, we'll sort of use some abstraction to assume some return values. So let's say\nthat I'm bringing this problem down, my top level problem asked me what's the best way\nto generate eight. But I see that along that path, I have to find the sub solution for\nthe best way to generate six. So let's say we're rooted at this subtree. And we know\nthat there are a few ways we can make six, right? If I look at this subtree rooted at\nsix, there are two zero base cases downward, right? So if I look at the first one, I get\nthis path, I know that my sub tree over here will be able to know that all right, one way\nto generate six would be two plus two plus two, right? We kind of implemented that logic\nin the last problem. But now what I also want to do is consider any other paths in case\nthey end up being shorter. Obviously, I know That this path of three 300 return upward.\nAnd now I have to kind of make the decision, you know, between these two options for generating\nsix, I should just prefer the shorter one. So that means it's sort of two to two versus\nthree, three. And obviously, the three, three wins because the array length is shorter.\nAnd if I pause right here, and I looked at what the diagram is saying, it does make sense\nthat above the six, we have three comma three, because that is the shortest way we can ever\nmake a six, right, just three plus three. But now I can return this sub array to my\nparent. But if I do that, I should also include the value of the edge along that path, right?\nSo I also included the two over here. Now this makes sense, because one way I can generate\neight is three plus three plus two, right? But we know that's not the optimal way. Let's\nsay we step through this a little further, let's say we took the same sort of process\nfor this other child of five. So I know that to generate five, there are three options\naccording to the subject, right? Because I see three different leaves that are have zero\ninside of them. And so I know that for these paths, they would work out through their own\nsub arrays. And here, I really just want to choose the shortest one, right? So obviously,\nthe lone five wins out over here. So that'd be returned all the way up to that five node.\nBut then that five node will return it to its parent, then, of course, I need to include\nthe edge that connects the eight to the five, right? How did I transition to that five in\nthe first place, so I go ahead and just add it in. And now the root node over here has\na decision to make, which one does it prefer between 332 or five, three, it'll just choose\na shorter one. So the five three should win out over here. And I just need to continue\nthis process for any other branches in my tree, right? I can't return early and this\ntype of problem because I need to find the optimal way. And I can't be sure until I've\ntried every possibility. Cool. So it looks like our overall logic is we want\nto explore and find any ways to generate our target sum. But then when we find a way that's\nshorter than our currently tracked way, we can just replace it, I'll continue that process\nthrough the entire tree. If I checked every possibility and keep replacing what I consider\nthe shortest. By the end of us exploring every branch, we would have the absolute shortest.\nAlright, I think we're ready to hop into the code. Alright, programmers, welcome back to\nmy text editor. Let's work on coding this one out. So here I have some initial examples\nthat we'll use to test our best sum function. I noticed for this last one, right, I get\nmy initial target sum of 100. And the best way to do that is obviously just take a bunch\nof 20 fives, right for 20 fives. What else I want to bring our attention to is this third\nexample over here. So my target sum is eight. And my choice of numbers are one, four, and\nfive. The optimal answer here is four and four, right? That is the shortest way to generate\nat a common mistake I see a lot of students make is sort of assume that the best way to\ngenerate a target sum always involves taking the largest choice of number as many times\nas we can, right? That is not true. If you took a five in your your sum, then you would\nhave to take three ones in the long run, which is not going to work out to the shortest answer,\nright. So it's not the case that just taking the biggest choice of number always yields\nthe target sum in the shortest amount of numbers overall. So don't fall into that trap. Which\nmeans that we have to do the full tree exploration, right, we have to do that in exhaustive sort\nof search using our recursive code. So let's start with that base case, like we always\ndo. So bring this a few times, but still right here. So if the target sum is zero, then I\nhave trivially solved the problem. So I can just return an empty array, right? That is\nthe exact single combination and the shortest combination that can generate the target some\ncool along with that, let's handle that scenario, if our target sum goes too far downwards,\nif it's less than zero, so if the target sum is less than zero, I'll just return null,\nmeaning that it's not possible to generate that target sum. And now we'll use our branching\nlogic. So I'm going to iterate through all choice of numbers will say for let num in\nnumbers. And like we always do, I'll go ahead and create my remainder, which I know would\nbe the difference between my target sum, and that choice of number. Right? So what I'm\ndoing is I'm choosing the number that decreases my target sum. At this point, I would make\nmy recursive call right with that remainder, passing in the same numbers array. But now\nI have to do some thinking, I know that all right, best sum is either going to return\nto me a combination or an array, or it's going to return null, so I'm gonna have to kind\nof differentiate between the two. So over here, maybe I'll just save this as a result.\nI'll call this my remainder. Let's say combination. And if this remainder combination is not null,\nthen it can do some other logic, right? So I'll say if the remainder combination is not\nequal to No, then do stuff. So if I enter this if statement, then that means it is possible\nto generate the remainder. And exactly what remainder combination is, is an array containing\nthe short This way, I can generate the remainder. Cool. So if I enter this if statement, then\nI also have a way to generate the full targets, right, I can just take the remainder combination,\ncopy the elements over from it like we did last time. And also add on the choice of number\nI just took, right. So this would be now a complete combination for target sum. So I'll\njust say that as a regular combination. Cool. So so far, this is very reminiscent to our\nlast one. And we need to work in some more logic relevant for this problem, that is a\nvery, very important characteristic that we needed to implement in the tree was, I need\nto sort of choose the shortest combination, RAMs, I'm going to need to work in that logic.\nSo here's what we can do, I know that I need to compare basically, all of my branches together,\nall of my recursive calls together, and pick out the shortest combination. So I know that\nthis for loop is a piece of code that sort of iterates and attempts, all of my branches.\nAnd so outside of the for loop, I'm going to need some outer variable, I'll call it\nmy shortest combination. And over time, I'll just keep updating this variable if I find\na combination shorter than my current shortest combination, right? So I'm gonna initialize\nthis to null. And the reason is, imagine that we set up\nthis shortest combination of variables, no. And then we iterate through the for loop.\nAnd there isn't even any way to generate the target sum. So this for a loop finishes, and\nshortest combination would still be no. And that'd be great to return, right? Because\nin this problem, they said, if it's still not possible to generate the target sum at\nall, you should still return null. So this is a good initial default value for shortest\ncombination. But now I need to do my update logic. So here on line 11, I've actually created\na combination, that gives me the target sum. But now I need to check, right, so I'll say,\nif the combination is shorter, then the current shortest that I need to update it. So let's\ntranslate that into some code. Just use an if statement. And I'll start by checking if\nthe combination I currently have, which is an array, right? I check if that is less than\nin length, then the shortest combination variable. And really, it looks like shores combination,\nit starts as null. So I need to fix this code a little bit. But if I update it with a valid\ncombination, then it's going to be an array, right? So I'm really checking the length of\nthe arrays here. So what I want to do is assign my shortest combination\nwith the combination that is now shorter, good. So this means the shorter combination\nwins out and gets to stay, right. If I look at this code, it needs a little bit of work,\nbecause the first time I find some combination, I know that I be comparing that array length\nto no dot length, right? Because shortest combination starts as null. And I can't do\nnull dot length in JavaScript. So I'll need like a nice or clause here. So I'll say, if\nit is the case that your shortest combination is equal to No, then you can go ahead and\nreplace it. Cool. So this sort of check over here is going to make sure that I automatically\nreplace this null value with the first valid combination. Even if right now it may not\nbe the shortest, right later on, I'll compare that combination I have stored to some possibly\nshorter combinations. Cool. So this code is looking pretty good. Let's go ahead and give\nit a little test run. Nice. Notice that and on occasions where we call besam, with a remainder\nthat is negative because remember, sometimes we subtract a number that is maybe too large,\nthat's okay. Because that will actually bottom out at a base case and return null, which\nwe sort of check for explicitly in this if statement. Cool. So let's give us code a run\nnode best some. So I get an error over here looks like I get maximum call stack size exceeded,\nwhich means that we didn't really hit our base case. So there's some work to be done\nhere. So let's take a look at this code. So if I take a look at this code, it's a very,\nvery small typo. It's kind of unfortunate that it breaks the entire code. But really,\nI messed up when I iterated in the for loop over here. So here I wrote for letting them\nin numbers, that would actually give me the indices of the array. So they'd be like 0123.\nWhereas I want the elements of the array, right? So instead of in any of over here,\nso that's on me. So with that small change. Let's give it a run now. Yeah, it looks like\nwe're passing these first three examples, we have 735, and four, four, notice that the\norder among the elements in the combination doesn't really matter too much. But looks\nlike we're definitely a little too slow on this last example, over here, right? So obviously,\nwe know the move is to memorize this because we have the brute force recursion. But before\nwe do that, let's just talk about the complexity of This. So this code is going to be very\nsimilar in complexity to our last how sum function, sort of compare the two, it's almost\nthe same code, right? But do these side by side, right, these two functions look very,\nvery similar. So we know in the long run, we probably have the same or close to the\nsame complexity. Let's be methodical. So we know that over here, we always like to say\nthat M is the target sum. And we'll also go ahead and say that n is the numbers dot length.\nSo we just did the brute force. And our brute force shouldn't be the same story as last\ntime. So talk about the time. So the time of the brute force is going to be some sort\nof exponential, right? If you remember that tree drawing, in general, the exponential\nnumber of nodes in a tree will be the branching factor to the height power. So not the branching\nfactor here is n, right? I branch for every choice of number, and then the height of the\ntree would just be the target sum. So that's n to the M. But along with that, we also have some additional\noperations, right? If I look at this for loop, so this for loop gives me the branching factor,\nright. But then I also do this operation on line 11, which is copying over the array of\nremainder combination. And that array in the worst case will be of length m, right? The\nlargest sort of combination, give me back is a combination that is just filled with\na bunch of ones, right? If my target sum was 50, the longest combination possible would\nbe a bunch of ones, so 50 ones in an array. So what I'll do is, I'll say that for each\nof these n to the M power calls, you also have to do a linear operation in M, right?\nSo like before, it's n to the m times m. Cool. And then the space complexity is sort of interesting\nin this one, because we're maintaining some values. So look at this. So I talked about\nthe space complexity, just from the stack space, it would just be the heights of like\nthe recursion. In other words, it would be m over here, right? So I know it's going to\nbe at least M. So I'll jot that down. But then we have also like this variable on line\nfive, right? So I know that over time, I'm going to be storing an array inside of this\nvariable. And this array is going to be in the worst case, m in length, right? So what\nI'm saying is, every recursive call would have to have its own shortest combination\nvariable, right? If the shortest combination variable is going to be an array of length\nm, that means I have an array of length m, for every recursive call right? Before I bought\nthem out, at like my final base case. And so also, the space complexity here is m times\nm, which we know is the same thing as m squared, right? And sort of the reasoning is, your\nmaximal stack depth is still m like last time, however, now you need to have those stack\nframes, you need to store in array, right as you recurse. Nice. So really, the limiting\nfactor for us right now is going to be the time complexity, which is exponential. And\nso like we always say, let's go ahead and memorize this. So memorization pretty trivial\nright now, right? You've done it many times. So I'll just begun my initially empty memo\nobject. And I'll check, you know, if my target sum is in the memo, then I should actually\nreturn the stored value. So return memo at Target sum. So now that I have my memo checking\nlogic, what I also want to do is add the memo storing logic, right. So I need to just go\nto my return value and store it in the memo before I return it. Notice that the return\nvalue right now, it's no longer inside of the for loop, right in the last problem, it\nwas in the for loop, because I can return early. But this time, we're going to return\nat the very end, so I'll replace it over here. So I'll say, for here, the memo at Target\nsum should be stored with the shortest combination, I can still return the shortest combination.\nAnd before I forget, let me go ahead and pass down the same memo object by reference. Alright,\nnothing too much to that. Let's go ahead and try this last example. Now. Give it a shot.\nAwesome. And there we have it. We have 425 in this last example. And that is the best\nway to generate a 100 is pretty evident that we cut down on the runtime. So let's talk\nabout the memoized complexity embolized. And so the time is obviously much faster should\nnot be exponential. But if I take a lay of the land, I know that now that every target\nsum is going to be a key of the memo object. And target some is really just a number, right?\nSo if my target time is 50, then I basically have 50 different keys I can never store in\nthe memo object. So if I have m different keys in my memo object, I know that I won't\nbe exploring any full duplicate sub trees for each of those keys. However, I will slap\nthe branch for every number in the array, right? So overall, I'm looking at an m times\nn. So so far, I have m times n, but I have some additional work from this array, right?\nSo notice that the n over here that comes from this for loop, I'm iterating through\nnumbers, but then the additional M comes from copying over this array, which would be linear.\nSo it would be m times n times M. And I can just kind of squish these two M's together.\nSo it kind of boils down to m squared, times n, which is really the same thing as last\ntime. And our space complexity would also be the same as it was last time, which was\njust m squared, mostly coming from the memo, right? And the logic is, your memo keys have\nm possibilities. But for each of those keys, their value can be an array of length m, right?\nSo just m times m, or m squared. Awesome. So looking at this code, you probably, you\nknow, feeling that Oh, my gosh, like this best some problem is pretty complex. And I\nthink it you know, to be honest, it is, however, what I really want us to focus in on is this,\nlike progression we took, right, I think that everyone could tackle this best some problem,\nif they warmed up and really understood simpler problems like can some and how some write the code is very, very similar. So to\nwrap things up, I will let's do some closing words on the drawing board. So in its best\nsome problem, right, we had two inputs, we had m as our targets, and also say that n\nis the length of the array. So the brute force that we initially implemented it with just\nsome recursion was exponential in time. And after we optimized it, we brought it down\nto just a polynomial time complexity. And notice that between our brute force and our\nmemulai solution, they actually have the same space complexity. So we definitely prefer\nthis memoized version. So hope you enjoy this series of problems. That is we worked on the\ncan some how some and best some problems, they all had the common frame of us having\nsome target some that we need to generate with some options given in an array. And in\nparticular, if you look at the can some problem it asks us what that task of generating target\nsome Can you do it? So yes or no? The house and problem. So is how will you do it? So\nwhat are the exact combination of elements that you'll use? And finally, the best son\nwas the hardest version? And it asked, What is the best way to do it in terms of the least\nnumber of elements of the array? So there definitely is a logical progression to these\nproblems. And in particular, they kind of capture a different variation of a dynamic\nprogramming problem for our can some problem, right, we had to return Boolean there. That's\na type of decision problem, right? Yes or no? Can you accomplish this task? Is it possible?\nAlong with that the house some problem was a combinatoric problem, right? We want to\nknow the exact combination that works out. And the best some problem was a variation\nof an optimization problem, right? I want the shortest way to generate the target. So\nwe saw that these three problem types definitely have some common ground, but they also have\nsome nuance, depending on exactly the question we're trying to answer. These all fall under\nthe umbrella of dynamic programming. That being said, dynamic programming problems aren't\njust limited to number inputs. All right, I think it's time to work on another prompt,\nlet's say I gave you this, what I want to do is write a function called can construct\nthat takes in some target string, as well as an array of words in a word bank. My goal\nis to return a Boolean indicating whether or not I can make the target by concatenate\ntogether elements of the word bank. And along with that, we can reuse as many elements as\nthe word bank as we see fit. Alright, notice that in this problem, we're looking for a\nBoolean response to start, right. So just yes or no. Is it possible to generate the\ntarget? So let's take a look at an example here. Let's say I gave you this. So my target\nis abcdef. And I have a nice long array of some words. And so I'm basically asking, Can\nyou construct abcdef, using elements of the array. So if I kind of take a look at the\narray, there is exactly just one way to generate the target string, which are just B, A, B,\nC plus D, F. So the answer here is true, because there is at least one way to make the target,\nright. Let's take a look at the opposite example. So let's say I had this word of skateboard.\nAnd I gave you all of these words in an array. So take a moment to kind of look this one\nover. And you tell me write Is it possible to generate skateboard here? And the answer here is no. Right? It is not\npossible to generate skateboard using this array of words. So we should return false,\nwe can get pretty close to making skateboard. But we can never build the full string. Alright,\nso here are a few ways that we can attempt but they don't work out in the long run, right?\nThis is one series we can take, but we kind of get stuck, as well as this. And also this\nway, right? Point being there are zero ways we can ever generate skateboard. So we should\nreturn false over here. Awesome. So I think let's look at one more example. We should\nalready have the vibe that in general, it's easier to create a shorter string than a longer\nstring, right? To create a longer string, you're probably going to need to use more\nelements. So if I have that kind of framing in mind, that I know that possibly the easiest\nstring to create would be the empty string, right? So let's say your target was the empty\nstring and I gave you you know, some kind of random array of words, really, the array\nof words doesn't really matter here. I think no matter what they should return true. Because\nto generate the empty string, you can just take no zero elements. From the array, and\nthat kind of line of thinking is going to help us really start to solve this problem.\nSo we'll kind of take this example, in stride, what we want to do is return true if our target\nis empty, and that takes place no matter what array of words we're given, right? Cool, more\nor less, that kind of sounds like a base case, right? But let's go ahead and start to kind\nof define some process we can take to explore all of the options, right? So I want to really\nvisualize this in a well ordered way. And that really means a tree. Right? So let's\nsay we're going to trace through this example visually. So my target is abcdef. We already\nsaid that, in the long run, we should return or conclude a true about this input, right?\nSo we'll just start with the input argument that is the target string as the root of this\ntree. And this is sort of a scenario where like, Alright, I have two inputs, how do I\nknow which one to really encode in my drawing? Well, it's about what will actually change.\nI know from like, one instance of like this problem to the next, the array of words, I\ncan actually reuse as many times as I need. So it's not like I'm taking out elements from\nthe array. So with that in mind, I think it's better or more reasonable to encode the actual\ntarget string into the nodes of this picture. Because I'm gonna start with this original\ntarget string of my route. Now I have to think about how I transition to the children of\nthis right, so what moves do I take that hopefully shrink the target string, right, I know I\nneed to shrink the target string, because I already have the base case of the empty\nstring in mind. So I need to get closer and closer to a length of zero. We'll talk about\none transition we can make. So I know that I need to sort of use the array of words as\nI transition. And so let's say I took a B as a choice right now, if I take a B, then\nI guess I could remove, you know, that sequence of characters from my parent node. So if I\ntake a B out of abcdef, then the resulting child is just C, D, F. Cool. So notice that\nas we transition from one node to the next, looks like we're taking out that substring.\nIn a similar way, I have another substring, that I can take out for my word bank, and\nthat would be ABC, and that would yield in the child d f. And then I can do this for\nsome other string inside of the word bank. And the really important thing to know is,\nthere's a correct logic to doing this. And it's also a common trap I see a lot of students\nfall into when it comes to this logic. So right now I'll talk about like the common\nmistake. So it would be ill advised to sort of take out the CD from our root node, if\nyou took out C, D, then the resulting note would be a, b, f. And so what we're doing\nright now is if we took out C, D, you're taking out something in the middle. And if you take\nout something in the middle, that means that your resulting string actually creates a new\nadjacent sequence of characters. In other words, I know that this is kind of suspicious,\nbecause look at this little run of characters, A, B, E, those are now like adjacent next\nto each other. Whereas in the original string of abcdef, A, B, he was not present, right.\nSo if I kind of take out strings in the middle, then I'll have this sort of mistake of creating\nnew adjacencies. Right. And that would actually impact the moves I take later on. So I don't\nwant to do that, right. So the move here is to not take out any characters from the middle\nof the string. So what would be the correct way of doing it? Well, if you look at our\ntwo nodes that we already branched into, a common factor for them is the fact that we\nactually took a prefix out of our original root node, that is a B as a prefix, and so\nis ABC or recall that a prefix is just a string, that kind of begins some other larger string.\nSo if I want to transition to a third node over here, there's only one more prefix I\ncan take. And that would just be ABCD. Right? If I take that prefix out, then my resulting\nchild is just E, F. And so the overall logic that we want to use when we build this tree\nis to only branch to children if we have a matching prefix in the word bank. And of course,\nthe child would be the resulting string after we remove that prefix. So let's keep it rolling.\nAnd we'll apply this logic again and again, recursively. So let's say I'm rooted at this\nCDF node, I'll look inside of the word bank and notice any prefixes that actually match\nhere, I think there's only one and that would just be CD. If I took out the prefix CD, then\nmy result is E, F. In a similar way, I can do that for d f, I find that d f is actually\ncontained in the word bang. So it's technically also a prefix. If I took the prefix def out\nof that node, then my result would be empty, which is pretty good. At this point, I look\nat some other nodes like this EF and they have no matching prefixes inside of the word\nbank. So they sort of bought them out in some sort of base case. In the long run. If I can\nbreak down EF any further than I know that it's not possible to construct EF so that\ncan technically return a false to the parent. Mr way, if I ever run into the empty string,\nthat means the job is done. And I can just return true, right? Something we said earlier\nwas, whenever we want to generate the empty string, it is always possible no matter what.\nAnd now this pattern should feel a little familiar, right? All I have to do now is kind\nof bubble up these Boolean values to the parent. And overall, if one of my children return\ntrue, then I myself will return true, right? So I'll bubble this up a little bit, bubble\nup all the way to the top. So our root note chooses basically the true value among these\nthree values it gets from each of its branches. And so the ultimate answer here is just true,\nright. And it is possible to generate abcdef using words of this array. So you're probably\nhaving deja vu right now, right? We almost use the same exact logic for the previous\nsome problem. However, all we did was adjust how we transition from one note to the next,\nreally making a compatible for this string data. But we're going to carry over a lot\nof knowledge, right? It's really important that we understand like the general like knowledge\nof dynamic programming and recursive understanding, we can apply that under any circumstances.\nThat being said, let's look at one more example. What I want to do is see an example where\nthis should return false. So let's say I gave you that skateboard example from before. In\nthe long run, this is going to return false. If I tried to break down skateboard, I would\nalways try to transition using any matching prefixes from the array. There are two prefixes\nat the start that match, and that would be SCA and SK, and those would give me t board\nand eight board, respectively. And now at this point, if I route myself at the keyboard\nnode, I can only take the T, resulting eboard. In a similar way, if I am at the eight board\nnode, then I can only transition using the eight. And I'm left over with board. At this\npoint, if I look at eboard, that node over there actually hits a dead end, right, there's\nnothing I can actually take out of Eve or there's no matching prefix, because I basically\nneed something that starts with E, but no words of the word bank start with E. So I\nguess we have to focus our effort elsewhere. Looking at this board, I can take either a\nBo or a Bo AR, and I'm left with art and D respectively. And unfortunately, those two\nnodes at the leaf level also bottom out, right, I can't transition further and take out any\nprefixes from those strings. So I know that those will have to return false. And if all\nof these leaf nodes return false, then my ultimate note at the top that is a skateboard\nnode at the root, that's going to just return a false as well. So it's pretty clear to me\nthat the overall logic we want is if we get back a single true, then we can just return\ntrue all the way up to the call stack. But if everything is false, then we'll just go\nahead and return a false. With that, I think we're ready to code this one out. All right, let's go ahead and code this one up. So here I have\nsome initial examples we can use to test our code for correctness. Looking at the last\nexample, over here, it's a fairly long one. And notice that the target incident F, whereas\nno words of the word bank have an F in it. So we know that that should result in a false.\nSo let's go ahead and lay down the base case for this. Like we said, a reasonable base\ncase is to check if your target is empty, right. If you have the empty string, then\nyou can already construct the empty string by taking no words from the word bank. So\nyou can just return true over here. And now I need to make my recursive call in a way\nwhere my target string gets progressively smaller and smaller toward this empty string.\nAnd so I know that based on the tree I drew, I need to make a choice based on the words\nin the word bang. So I'm going to iterate through all of the words. So I'll say for\nlet word of word bank. So I'm iterating through every element of the word bank. And now that\nI have the word element, as I think about when it's okay, to make the recursive call\nusing that word, and we spoke about this, we pointed out that we need to make sure that\nthe word is a prefix of the target. So I can do that, I can just check if the target dot\nindex of word equals zero. So index elf will just give me the index where I can find some\nsubstring inside of a larger string. If the index i get back is zero, that means that\nthe word starts at index zero of the target. So if you're unfamiliar with this method in\nJavaScript really quick, let's say I did potato dot index of pot, that will tell me the index\nwhere I can find it, which happens to be at index zero. But if I looked for tayto, I would\nget the index of the T, the first t rather in potato. So this is a really nice way I\ncan use to check if some substring is a prefix of another string, right, the index should\nbe zero within it. So a way interpret this if statement is if I have a prefix, then I\ncan sort of use it to shrink the target. So I'll create another variable here. I'll call\nit like the suffix so that's like the string after I remove the prefix. What I can do is\nslice my target string. Except to target that slice. And what I want to do is start picking\nup characters. After the length of the words I can say word dot length over here. So it's\nkind of reasoned out what this logic is doing. So we'll trace through this, let's say that\nI don't know my word. So I'll open up the note repple. Let's say my word was the string\npot. And we'll also say that my current target is potato. So I know when I do target dot\nindex of word, that is going to get back zero. So this if statement would be true. And then\nwhat I do is target dot slice of word, dot length. So we're dot length is just the length\nof the prefix I took, right? So it would be three over here, providing the target that\nslice starting at index three, that would give me everything after the prefix, right?\nSo I basically have removed pots, and got eight. Oh, cool. So when you use slice, if\nyou pass in a single argument, that's going to be the starting position of what you start\ngrabbing characters, and you'll go all the way through the end. Cool. And that's the\nlogic I definitely want here. So back to the code. Now that I have the suffix, I want to\nmake my recursive call on that suffix. So basically asking, Hey, is it possible? Can\nI construct the suffix now? And I'll pass along the same choice of word bank. Nice.\nSo here's where I should think recursively. So I'm focused in on what type of data do\nI get back from can construct I know I get back a Boolean, right? True or false, it tells\nme whether or not the suffix can be made. And I want to check, you know, if this call\nreturns true, maybe I'll be explicit here. So if the recursive call is true, then I know\nthat the original target can also be made. So what I'll do is return true early here.\nCool, I know that if the suffix could be made, and the word that I use to generate the suffix\nis also in the word bank, then the entire target must also be able to be made. Nice\nto hear I have my nice early return true. Like you expect, where should I return false,\nit should be after the for loop, right? Only after I've tried every possible choice of\nthe word and none of them worked out, then can I say, No, the target cannot be created.\nSo I want to do a late return false over here. So this code is looking pretty sharp, I think\nlet's go ahead and test these examples. So I should get true false true, and then false\nfor the last one, give this a go. So I get true, false true. And it looks like\nthe last example over here is taking quite some time to finish. So I think our code has\ncorrectness. But it's not efficient enough to you know, reasonably run this last example.\nSo I'm going to kill this program. If you take a look at the example I pass it for this\nlast one, it does sort of describe the worst case here. For one, we know that the answer\nis going to be false. So you will have to do a full exploration of the tree, meaning\nyou can't do any early return trues, right. And because of like the length of the string,\nand also the length of the word bank, I have a very big tree, right? Notice that there's\ngoing to be a lot of prefixes at work here, right? every element of this array is actually\na prefix that could be found over here. And that happens again and again. So I'll tell\nyou what, let's go ahead to the drawing board. And we'll try to visualize what the exact\ncomplexity of this function is. Alright, so we implemented looks like the\nbrute force for this solution. Let's talk about how we might want to optimize it, I\nthink any conversation of optimization should begin with actually understanding what the\ncurrent complexity is. So let's say I gave us this kind of large example to sort of visualize\nwith, so my target string is enter a potent pot, and I gave you a pretty diverse array\nof words in the word bank. So I'll just go ahead and kind of give us though the full\ntree in what it would look like, would be this pretty long tree, right, so I follow\nthe same logic that we did in our earlier examples. notice a few things. There are some\noccasions where I transition using a single character prefix, which is totally fine. And\nthat kind of tends to feel like the worst case scenario, right? If you take single characters\nout of your target string over time, then you're going to have a very, very tall tree\nheight, or you're gonna have to take many, many steps. So that kind of reminds us of\na worst case scenario, like we saw when we ran the code. But that being said, we want\nto generalize this understanding right for basically some generic size of our input.\nSo let's say we kind of just looked at this tree in terms of its overall shape, and then\nwe'll kind of generalize it. So to me, this tree has this sort of basic structure. And\nlet me start by defining the terms I'll use to describe the complexity right. So I'll\nsay that M is the target string length, and n is the number of words in the word bang.\nRight, so I'm really trying to use a different variable for each of my inputs, because I\nhave the vibe that both of them contribute to my complexity, possibly in different ways.\nSo you've seen, you know, us analyze trees before in terms of like their structure, right,\nwe're visualizing as a call tree, I know that the time complexity would be the number of\nnodes in the call tree, right. And so let's start with some familiar territory, I kind\nof already know that I need to realize the height of this tree, the height of this tree\nis going to be m, right? Remember that m is our target string. And so imagine, in the\nworst case that we took, or we had to take a bunch of single character, choice of words\nto construct our target string, that means that the number of things I would have to\ntake all the way from the root to a base case, or the root to the leaf would be exactly M.\nRight? If I had to take a bunch of single characters, so we can be confident that the\nheight of this tree would be m. So I talked about the height. Now I need to realize the\nbranching factor, that is from one level of the tree to the next, how does a number of\nnodes change in the worst case? Well, I know that the branching factor is dictated by how\nmany words I have in the word bank. And so that would be some relation on n. So I know\nat the root level, I have about one node. But then in the worst case, to get to the\nnext level, I will multiply by n, right? Imagine that, basically, almost every element of the\nword bank was a matching prefix, right? So you'd multiply by n. And let's say that carried\nover further, let's say almost every word of the word bank was still a prefix of those\nresulting nodes, I would keep multiplying by n. And I would do this overall m times,\nright. So we already know that this is going to be exponential, I need to multiply n by\nitself, m times over. And so this would give me an N to the M, time complexity. In general,\nif you visualize your recursion using a nice call tree like this, then the overall time\ncomplexity is going to be the branching factor to the height power. So we have a branching\nfactor of n and a height of m. That being said, this will just really consider the number\nof calls that we make, I want to be super sure and make sure we didn't do any other\nkind of performance or costly operations inside of our code. So here's our code, same code\nas we did before, if you look at this code, some things I need to consider are probably\nline six, right? If I look at line six, that was where I did a target that slice that's\nlike copying over a part of the target string. And to do that operation, I would actually\nhave to iterate through the target string. Right? So that would actually contribute to\nmy complexity here. So in the worst case, would I be slicing? Well, if I'm slicing a\ntarget string, that would have like a maximum length of M, right. And so in every call to\ncan construct, I'm going to have to do an additional m operation, if I have n to the\nM calls, then I can just multiply an additional M over here, right. So I, I added some additional\nterm into our complexity, just multiplying by M. Cool. And so overall, if you look at\nthat time complexity, it was already exponential so that multiplication by m, doesn't really\nmake it that much slower, it's really the N to the M, that makes it unbearably slow\nin the first place. So that was the time complexity. Now let's look at the space complexity. So\nif we just refer to the space complexity, due to the call stack, it looks like it's\ngoing to be the height of this tree, right? Like we always say, the height of the tree\nwould mean the maximum number of stack frames, we would need on the call stack before we\nbought them out at the base case, right? Because when we return from a call, we would actually\nremove something from the call stack, right? The height of this tree is definitely just\nM. So we'll say the space from the call stack is just o of m. But again, we should also\nyou know, look at our code and see if we created any other like growing structures. So we look\nat the code right now, I see that on line six, and kind of talking about that slice\nstatement. Again, the slice returns you a new string, right. And that new string is\ngoing to tend to be of length M. So on every call to can construct, I'm creating a new\nstring, I actually need to maintain it through the recursion, right, because I actually slice\nbefore I return out on line eight. So because of that, I know that each of my M stack frames\nwill have to store a string of length M. So that just means m times m in my space complexity,\nwhich is really just m squared. Cool, which isn't too bad of really a space complexity\noverall. Alright, so it looks like our final complexity for our brute force solution is\nexponential in time. And it looks like quadratic in space. So obviously, let's work on improving\nthe time complexity over here. And so hopefully, you're seeing where this is heading. Let's\nsay we jump back into my entropion pot example. So this was a huge tree. Take a moment look\nat this tree, and where can we actually optimize some work away? To we're trying to do is notice any overlapping\nsome problems In the context of our tree, that means I'm looking for any duplicate sub\ntrees. And I see duplicate sub trees right here, right? They follow the same structure\nall the way down even to their base cases. So I've looked at the sub trees, they're really\ntrying to solve the same problem, right? That is they're both trying to figure out, can\nwe construct the string and teapot, right? And if I saw that once, on the left hand side,\nthe answer is going to be the same on the right hand side. So I can just store that\ninformation in a memo, right? So the trick is here to of course, memorize it using our\nclassic strategy. So let's hop to it. All right, here we are back in my code editor.\nLet's go ahead and just memorize this one. So I'll create my memo object. And here, I'll\nprefer to use the target as the key to my memo, I know from one call to the next, the\nword bank doesn't change, right? So I don't need to actually make it a part of the key\nfor my memo object. So I'll just check, hey, if my target is in the memo, then what I'll\ndo is return the stored value of that target. Cool. While I'm here, let me also squish this\ndown to a one liner. So I have the memo checking logic. Now I need to make sure I pass down\nthat memo to all of my recursive calls. And then I need to actually store data in the\nmemo. And the rule is wherever you have your recursive returns. Now, you should also store\nthat return value in your memo before you actually complete the return. Right. So for\nboth of these lines, I'll make sure I store them in the memo. So it's a memo at Target\nequals that. But I still want to return that same value. So we'll return true and return\nfalse over here. Again, notice that I'm using my exact argument targets, right? I don't\nneed to write any memorization logic about the suffix, right? Imagine if we made the\ncall to can construct suffix becomes that frames target. So the memos ation would still\nwork properly. Right? So that looks pretty good. And it wasn't that much code, right?\nmemoization is always this slightly extra layer, we add on top of our brute force solution.\nSo let's try this now can't construct. Nice. And there we have that last example finishing\nfairly quickly, or we do get the correct answer of false over here. Alright, so here's what\nwe'll do, we're going to head back to the drawing board. And of course, we'll come up\nwith the final complexity analysis for this function. Some classic memorization, right?\nLet's take a lay of the land over here. So we wrapped up this can construct problem,\nlet's describe its final optimized complexity. So again, like before, we'll say M is the\ntarget length, and n is the number of words in the word bank, our original brute force\nhad an exponential time complexity, right, and that was n to the m times m. And when\nwe memorize our solution, we actually improved it from exponential. So now, the time complexity\nof our solution is n times m squared, right. And the reasoning is, now we don't have to\nfully explore any duplicate subtree, every time we run into it, instead, we just store\nthe results in the memo. And we can just kind of short circuit and fetch the stored result\nin the memo. Notice that I have an M squared, right in the memo, I have complexity, that\nsecond m really comes from the fact that we still have to do the slice, we have to pay\nfor that cost. So although we added an additional object in our memo II solution, our space\ncomplexity would remain in the polynomial class. So overall, we definitely prefer this\nsecond solution, because we remove some exponential, you know, complexity. So now it is reasonable\nto actually run this in an amount of time. I think that wraps up this can construct problem.\nNow let's work on the counting version of this problem. In particular, I want to work\non count construct. So we have the same set up here, I want to take in still a target\nstring and also an array of words in a word bank. But this time I want to return a number,\nI want to return the total number of ways that the target can be made using words of\nthe word bank. And like before, we can reuse elements of the word bank as many times as\nwe want. So notice that this question asked us to do something slightly different, we\ndon't want just true or false. If it's possible, we want the exact number of ways that we could\nconstruct the target string. So let's take a look at some examples. And also, you know,\ntake a high level view of the strategy here. So let's say I gave you this string of abcdef.\nAnd this array of words, this particular example we saw before, and it is possible, and there's\nactually one exact way we can generate abcdef. So we can construct the tree in the same way\nwe did before. And we end up with this. However, this time around, we want to choose a different\nvalue to return for our base cases, as well as changing the logic for reconstructing our\nsub solutions, right? And so if I look at the base cases here, I wanted to kind of just adapt the return\nvalue for this new type of data that I need to return which is number. So I think the\nmove is for these scenarios where we can't break down our current target any further.\nThat's your return zero, right? Yeah, f can't be broken down because it doesn't have any\nmore matching prefixes from the array. So that means there are zero ways to breakdown\nF. And so we should return zero in those scenarios. And then when we have the empty string we\nknow was successful. So we could always, you know, create the empty string. And so that\nshould return one. And we've seen this logic before in problems like Fibonacci, as well\nas our grid traveller problem, we just want to bubble up these values to their parents,\nand make sure every parent will add up all the numbers that come back from their children.\nSo it just bubbles up like this. And top level we do zero plus one plus zero, which means\nthat we can generate abcdef in exactly one way. And if you look at the way that actually\nis symbolized inside the tree, it's exactly the path from this root node all the way down\nto that lone base case that returned an empty string, right, ABC plus d f. Let's take a\nlook at another example. So here I have the target string purple, and I have some other\ncharacters and words inside of the array. So take a moment to look at the input here\nand predict what number they should return. So the answer here is two, right, there are\ntwo ways to create purple. So if you construct the tree, we know we start with the initial\nunknown of purple. And then we have about three prefixes that match here. And those\nyield some children, we can follow the same pattern recursively down the tree. So the\nfull tree really looks like this, notice that I have a two base cases that actually end\nup as the empty string. So I know those are going to turn one up to their parent. And\non the right hand side, I have a loan II that can't be broken down any further that returns\nzero. And like always, right, I just bubble up these values, until at the parent, I actually\ndo one plus one plus zero, which gives me two. All right, there are two distinct ways\nto create purple using this choice of word bank. All right, I think I'm feeling pretty\ngood about jumping into the code for this one, it's really just a small variation of\nthe last problem we did. So let's hop right in. Alright, programmers back in the code\neditor, let's go ahead and bang this one out. So I already have some examples that show\nus what numbers we should return for this count construct, right. So I have some examples\nhere. I'm gonna say even have that big example, with our large inputs, we know that that will\nprobably need to be optimized, let's lay the foundation with a brute force. So we'll start\nwith the same base case, as always, right. So if the target is the empty string, then\nwe have truly solved the problem. Meaning that there is definitely one way to generate\nthe empty string, right, just take no elements from the word bank. Along with that, I need\nto make my recursive call. So the usual structure, right, I want to iterate through every choice\nof word. So for let word of word bank. And then for every word of that word bank, I need\nto check if it's a prefix. So we've done this before, if the target dot index of word bank,\nor rather index of word, if that is equal to zero, then it must be a prefix. And if\nit's a prefix, and I can go ahead and take like the rest of the word that is the suffix\nand call recursively on it. So I'll do this in line now say, count construct, and I'm\ngoing to pass in the rest of the word, which would be target dot slice, and then I'll slice\nstarting at word dot length. So this means that the slice contains everything after the\nword or everything after the prefix. And so Also be sure to pass into the second argument,\nthe same word bank. Nice. And now I need to think about what calc construct returns. So\nit's returning a number now, right? So in particular, this will be the will say, num\nways. I'll say no more ways for the rest, maybe a little wordy of a variable name, but\nI think it does describe how exactly what this returns here, right. So this is a number\nof ways that you can generate the suffix with like the rest of the target. What I want to\ndo is keep a running total. So outside this for loop, I need a way to add everything that\nthe for loop iterates through right, so I'll create a total count over here. So I'll say\nlet, I'll say total count. And I'll start it as zero. And now inside of my for loop,\nwhenever I get the number of ways to create the rest of the string, I'll go ahead and\njust add that into my total count. So it's as simple as total count plus equals the number\nof ways to generate the rest of the string right after I've removed the word. And after\nI take the total through the entire for loop, and I can just return the total count. Something\nreally great about this, this programming pattern is let's say that none of the choice\nof words were a valid prefix. So that means I finished this for loop. And this if statement\nis never true. If this if statement is never true, that I never add anything into the total\ncount. So if I return total count afterwards, I return a still zero, which makes sense because\napparently there are zero ways to make the target right have no initial step to take\nin the word bank. So let's go ahead and test this one out. So looks like we should get\nto 104, and then also a zero at the end. Let's give that a go. So 2104. And it looks like the last example\nis just a little slow for us. So you already know where this one is heading. Let me tell\nthe program, let's just go ahead and just memorize this one off the bat, right? Hopefully,\nI think through all of these examples, you're feeling really good about memorization. And\nit's apparent that we basically have drilled into our minds already. So if the target is\nin the memo, and just return the stored value memo at Target. And then I'll need to adjust\nmy return value, right. So where I return over here is I'll store that total account\nas the value corresponds to the target. And let's not forget to also pass in the memo\nto our recursive calls, right? So memo goes right here. Nice. So let's give that a run\nagain. I expect a zero for that last answer, right. So looks like I have an error over\nhere. And of course, I forgot to actually replace my return value. So I can still return\nthe total counts. And addition to that, I'm actually adding it into my memo. So let's\ntry that now. Yeah, these answers look correct, right, I got zero for the last one, notice\nthat the last one is not possible, because it ends in an F and all my words only contain\nE's. Nice. And if you look at this code, it's a pretty similar to our previous problem of\ncan construct if I kind of split these can construct basically has the same shape. Really,\nthe only difference is this number variable that I add into, and of course, the return\nvalues. So we do expect the complexities to be the same for these two functions. Let's\nwrap this one up on the drawing board. Let's look at the complexity of this. As always,\nfor this calc construct problem, our M is going to be the length of a target string,\nand our n is going to be the length of the array, right? So that means a number of elements\nin that array. Our brute force is the same as it was in the can construct problem, right,\nso it's still exponential. And using memoization. We just brought that down from an exponential\nto a polynomial time complexity, and the space complexity remain the same. Really, there\nis no additional cost that we pay in our implementation for this counting version of the problem,\nright. The only difference is now we're maintaining a number that we just add to, you know, on\nevery iteration of that for loop. But that doesn't really affect the runtime or the space\ncomplexity at all. So I think this wraps up this count construct problem. Now I want to do one more variation of the\nstring problem. So what I want to do is write a function called all construct that has the\nsame setup, right, so I'm going to take in a target string, as well as an array of words\nin a word bank. But this time, what I want to do is return all of the ways that the target\ncan constructed by concatenating elements inside of that word bank. And that means I\nshould return a two dimensional array, a single element of that 2d array is going to represent\none of the combinations that can construct the target, right, and I want to return all\nof the ways within a 2d array. And as always, we can reuse elements of the word bank as\nmany times as we need. So let's make sure we understand this question by looking at\nsome examples and their output. So here's an example using purple. And it's the one\nwe've seen before in the last problem. The last problem I had us return to because there\nwere two ways to create purple. But now I don't want the number, I want the exact ways\nthat actually create purple, that means you need to return a two dimensional array, the\nouter array, or the outer set of brackets represents the collection of all combinations.\nWhereas a set of inner brackets or a sub array represents one of the combinations that creates\npurple. Let's take a look at another example. Let's say I gave you abcdef. And I gave you\nthis long array of word bank, notice that I actually added some elements inside of this\nword bank array. It's a little more complex of in our previous examples. Because of this,\nthere are actually many ways you can create abcdef. And this contains all of them, right?\nSo there are four ways to create our target string. And again, notice that each sub array\nrepresents one of those combinations of words in the word bank that creates the target.\nCool. So now that we kind of understand like the shape of this problem in terms of the\ndata we should return, let's take a look at some base scenarios. So let's say I gave you\nthis example. Right? So I have a target of Hello. And my words in the word bank are just\nCat Dog and mouse. Obviously, you know, that is not possible to generate Hello. So there\nare really zero ways to create this. How should we actually return an answer here? Well, I\nthink it'd be reasonable to return an empty array. Remember that we're saying the outer\narray in this context represents the collection of all of the combinations that can create\nHello, since there are zero ways to create Hello, that means that our collection is empty,\nright? This has a length of zero meaning there are zero ways to create Hello. Now let's say\nwe had another base scenario. Let's say we have to generate the empty string using the\nsame array of word bank. And that scenario, I think it's reasonable to return an array\ncontaining an empty array. And again, the reason is if it is possible to To create the\ntarget string, then we need to return a 2d array, right where the outer array represents\nthe collection. And if there's one sub array inside of that outer array, that means there's\none way to create the empty string. And what does that one way? Well, it's to take no elements\nfrom the word bang. So I think this is going to be consistent logic, this is going to be\na really important way to think about this problem. That is, when we're given a target\nthat cannot be constructed using the word bank, we should return an empty array, right,\na one dimensional empty array, because there are zero ways to create it. On the flip side,\nif I've ever given the empty string, we know that it's always possible. And so we should\nreturn like a two dimensional empty array. Cool. So with that, let's look at some tree\nexamples. Now, let's say I have this large example from before, we know that the overall\ntree like we've always know created would look something like this. Obviously, now we're\njust reframing this problem in the return values that we do for our base cases. So you\nnotice that there are four base cases here that kind of reach the empty string. And I\nknow that those represent the four ways to create abcdef. And now I have to adjust the\nreturn values here. So I'm already saying that if I have the empty string, then that\nshould return an empty 2d array. So it looks something like this, right? And how I actually\nreconstruct the entire solution from these very small sub solutions. So let's just stay\nfocused on the left subtree. Right now, I know that these arrays are going to return\nback to their parents. And when I do that, I also need to make sure that I include the\nedge that I actually use to transition to the child. In other words, I'm going to be\nsure to push the label for the edge into each of those sub arrays. So the key insight is\nthis, right? I'm just pushing those edges into their sub arrays. And from here, I continue\nthe pattern up a little further, right. So I know that these arrays return their parent\nover here, and I still, you know, push the edges that I took to get to those children.\nSo on the left, I'm going to put CD in the front, and on the right, I'm going to put\nC in the front, resulting in this. And then at this point, notice that this node rooted\nat C D E F, that is actually going to receive both of these collections, right? And what\nshould this note do? Well, it really needs to just combine a both of these arrays. Recall\nthat, you know, we technically receive a two dimensional arrays, which means that a sub\narray represents one of the ways to create the actual target. So if I just concatenate\nthese two, two dimensional arrays, that yields this construct, if I do a quick spot check,\nI'll see if this is compatible with what the question is asking, right? This is a two dimensional\narray. And I know there are actually two ways that we can create CDF, if I look at what\nthis is saying, The first way is to do C, D plus F. And the other ways to do c plus\nd f. And so this cell problem is correct in itself. So I'm going to use the same exact\nlogic to trace through the right hand side, I know that these cases return to their parent.\nAnd the parent is responsible for adding the edge to each of those sub arrays like this.\nNow, I'm just gonna reorganize everything at the top just to give us some more room.\nAnd maybe I'll even spread out these brackets to make a look more symmetric. But I'm not\ndone here, I still need to consume each of the edges at the very top of the tree. So\nif I look at my left hand set of arrays, I know that those need to receive AB. In other\nwords, they need to have a B place at the front of each of those. So I'll just do that,\nright. In the same way, all of the arrays in the middle, which is really just a one\nsub array, need to add ABC to the front of them, like this. And finally, same thing on\nthe right hand side with ABCD. Cool. Now if I look at what I have, these represent the\nfour ways that we can actually create our original target string. But at this point,\nthe root node just needs to concatenate each of these two dimensional arrays together.\nSo it really just combines them into a single 2d array like this. And if I do a quick sanity\ncheck, I know that each of these sub arrays represents one of the paths that I can take\nto a base case down my tree, which is exactly what we intended at the start. So this type\nof recursion is definitely more complex than the previous examples. But hopefully, you\ncan recognize what's similar to our last examples, right? Let's do one more together, though,\nlet's go back to this purple example of the full tree would look like this. And we'll\ntrace through this. So on the left hand side, we're going to start with a 2d empty array,\nright, because that's the base case for the empty string. Meaning that hey, it is possible\nto create the empty string in one way, and that is to just take nothing. So I do the\nsame logic as our last example, meaning I returned to my parent, but I'm being sure\nto also include the value of the edge, right. And so the key insight here is, I'm being\nsure to add the edge label and not the actual node label here. The note and the edge happened\nto have the same thing le, but I'm really looking forward to adding the edge right?\nSo I add Ellie over here. And likewise, this returns to its parent even further, and so\nAdd that last edge of perp. Cool. Now I need to do everything for this middle path. And\nso what I'll do is return the empty 2d array at the very bottom. And this really bubbles\nup all the way to the top. And we just accumulate every edge label as we go, right. So it sort\nof looks like this. And what's really interesting about this a\nright hand path, this is actually a base case, that doesn't work out, meaning we kind of\nhit a dead end at EA. And what we said in our initial examples was, whenever we have\na target string, that cannot be created at all using words of the word bank, then we're\ngoing to return a one dimensional empty array. And that actually works out in our favor,\nbecause if we return this empty array to our parents, our parent is going to try to add\nthe edge into every element of this empty array. But if there are no elements in this\narray, and it's going to add nothing. In other words, this one dimensional empty array really\njust bubbles up to the very top. And like always, if I just concatenate all three of\nthese arrays together, I actually end up with my final answer, notice that when I concatenate\nan empty array to the rest of these, I will actually contribute nothing to my file answer,\nwhich makes sense because there are no paths that work out on that right hand side. So\nour final answer is just this. Like, we know both of those sub arrays represent the two\ndifferent ways that we can create purple. All right, I'm feeling pretty good about this\nprocess. Now, let's go ahead and code it up. Alright, programmers back in the code editor,\nanother problem, another solution. So let's start by laying out the base case over here.\nNow, like we said, we'll say if the target is the empty string, then we want to return\na two dimensional empty array, right? Every single sub array here represents the one way\nyou can create the empty string by taking nothing right I take no words of the word\nbank. Nice. And then besides that, we need to make our recursive logic. So that's going\nto be very similar to what we've always done for this style of problem. So I'm going to\niterate through every word of the word bank. So I'll say let word of word bank word bank.\nAnd I need to still check if there's a prefix, right? If this word is a prefix, so if target\ndot index of word, if that index is zero, then I know that it must be a prefix, so I\ncan continue some code inside. Nice. And so what I'll do is I'll go ahead and create an\nextra variable just to store the target after I remove the word which would give me like\nthe suffix so I'll say const suffix equals, and I'll say target dot slice of word dot\nlength. So you've seen this pattern before. But just to refresh, this just gives us everything\nafter the word. So basically, once you move the word, what is the remainder of the string\nall the way to the end. And now that I have this suffix actually wants to call my function\nrecursively on that remainder, right? Just like this, I'll pass along the same word bank.\nCool. And now here's where things get a little intense, right? So we've been doing a lot\nof problems, you know, using this recursive structure, and then we memorize it in the\nlong run, I think the most important thing to do is when you make your recursive call,\nyou really just assume that your function works, right. So I think about what type I\nshould get back from all construct. So I know that all constructs and give me back an array,\nright, it's gonna give me back an array containing all of the ways to make the suffix. If there\nare no ways to make the suffix, then it's going to give me like an empty array, right.\nAnd so I'm going to assume that here, so I'll create a variable. And I'll call it, let's\nsay, the suffix waise. And the reason I'm naming it like this is, I really want us to,\nin our head, think about the return value from this as an array of all the ways to build\nthe suffix. Cool. So that's going to be a two dimensional array, right? There are many\nways to do it. Nice. So if this gives me all the ways to make the suffix, how can I get\nall the ways to make the original target like in this current stack frame? Well, what I\nneed to do is really just take each of those suffix ways, and add my word to the front\nof it, right? I used this word to even create the suffix in the first place. So what I can\ndo is, I'm going to say my target ways. Right? So now I want to relate how the suffix ways\ncan be used to build my original target, right? All I need to do is really iterate over every\nsub array over here and add my word to the front of it. Right, that's exactly the process\nwe took in the tree diagram, right? So I can use some nice JavaScript methods here. If\nI just wanted to basically manipulate every element of the array, I can do a map here.\nSo I'll say suffix, ways dot map. And I know that a single element there's going to be\none way he'll say, singular. And then what I want to do is just take that same way, copy\nit over, meaning I just spread It's elements. But I'm also going to put the word that I\ntook in the front, we've seen this syntax before, although maybe this like map method\nis maybe new free, maybe you're not super familiar with JavaScript. I think that's fair\ngame. So let's hop into the node repple. Just to demo this, let's say I had some array,\nI'll just make this array 1234. So there's my array. What I can do in general is use\narray dot map. And map is a function and you should pass in a callback. So that means another\nfunction. And what I'll do is this callbacks gonna take in every element, and it's gonna\nbe an arrow function, what's going to return is really just how I want to modify the elements,\nlet's say I wanted to multiply every element by two, right, the return value of this callback\nfunction is going to become a new element of the new array. So notice, I get back 2468,\nmy original array was 1234. And I get back a new array using map. And so essentially,\nwhat I'm doing in this example, on line eight, in my actual code, I'm just taking every sub\narray and just inserting my word at the front of every sub array. So an example that speaks\ncloser to our exact code would might look something like this, like suffix ways. And\nit's going to be a 2d array. So I'll make a sub array, and we just an array of some\nstrings kind of arbitrary right now. So I'll say x, y, and then z. And then the second\nsub array will be maybe I don't know, like, a x and then a yz. Right, so that's my original\narray. And what I want to do is, if I say suffix ways dot map, and let's say for every\nway, that is every sub array, I just want to copy over that way by spreading out. And\nthen I'll just go ahead and put I don't know, like an A at the front, just like this. So\nnotice what I get back, I basically have every sub array from before, except now I have a\nas the first elements of both of those. Cool. So that's all I'm doing in this particular\nchunk of code. Awesome. So we'll leave the node repple. Back to our running solution.\nAnd now that I have the target ways, that's good. It's basically just like a piece of\nthe answer I need. However, it now this is really only going to give me all of the ways\nto make a target that use this word that I'm currently like on in my iteration. However,\nI know that this for loop gives me multiple branches, right, it's going to use all of\nthe words that are possible to create the target. So I need to kind of gather them all\ntogether. So I'll create a variable on the outside, I'll call it result mailstore. Everything\nright? So across all of these iterations, I just want to add the target ways into the\nresults, I'm going to do result dot push target ways, and I need to actually spread this out\nthat way, I don't nest things too deeply. Right? Remember that this is a one dimensional\narray, right now, target ways would be two dimensional, I don't want to just push target\nways into result. Otherwise, I'd get like a three dimensional array. So I'm going to\nbe sure to spread out target ways, right. So with that, let's actually go ahead and\ngive this run I think all I need to do now is after my for loop, right, after I'm done\ngetting all the ways, then I can just return the results of Mr. Just work recursively. So let's just try maybe the first example\nfor now and see how we do. So I should get, you know, a two dimensional array where I\nhave two ways to make purple. Right? let's give that a go all construct. Nice, and that's\nlooking pretty good. That is a correct answer. Let's try these other ones. Now while we're\nhere. So we should get a nice, large array for that second example. Nice, here it is.\nAnd then the third example, skateboard should return just an empty array, because it's not\npossible. And it looks like that last example is also not possible. So we do get an empty\narray. And if you kind of notice, to get that last answer, like we did in our other examples,\nit does noticeably take us some amounts of time. But before we get to that, let's take\na look at this code, make sure we really understand it. So the biggest logical leap we made here\nwas really, you know, assuming that we get back valid data from line nine, right? And\nthen it's all about how we can, you know, adjust that sub result to get our full answer,\nright. So if I get all the ways to make the suffix, and for each of those ways, I can\njust add my word in front of them. And that would give me all the ways to make my target.\nRight. And I need to continue that process for every choice of word, which is why I'm\nmaintaining this like a massive results variable outside of the for just pushing all the ways\ninto this result over time. And maybe just to be super clear, you're not familiar with\nlike this push method, especially when you use the spread operator with it as well and\nreally easily step through that. So in isolation, right, this is just using push and spread\nin general, if I had some, let's say, array, and let's say it was just an array of just\nsome elements 1234 Then I had another array, I'll call it just numbs, let's say in nums,\nI had elements of seven and eight. So here's my original array. And here's my nums. And\nif I did array dot push nums, you're actually going to force some nesting in this array.\nSo array dot push returns the new length. But it also actually manipulates or mutates,\nthe argument you call it on. So if I look at the array, now, notice that it actually\nhas another array nested inside. That's because I literally just pushed the entire nums. If\nyou wanted to do something a little different, what you can say is array dot push, and you\nspread out nums, what's going to do is comma separates the seven and eight, basically removing\nthe outer brackets from it. So have a look at this. Now, look at the array. Notice that\nwith that second push, now I just added a seven and eight without those additional brackets.\nSo that's all I'm doing over here. Like I said, I don't want to add another level of\nnesting to the result array, right, it should just always remain at most a two dimensional\narray. Cool. But overall looks like we have solved this one. And let's kind of talk about\nif there is even a way to make this faster. This is kind of an interesting problem. So\nthis is looking pretty good. So earlier, when we were on the drawing board, we said that,\nalright, because of what they're asking in this problem, it is basically going to require\na full exploration, right? If I want you to return every possible way, to make the target\nstring, you'll just have to kind of do all the work of creating all of those sub arrays,\nright, so we can't really avoid that stuff over here. If you think about this example,\nunlike 3334, this is actually not the worst worst case anymore. All right, here, we know\nthat eventually we're going to return just an empty array, because we can never generate\nthe final z in this example. However, if I remove the Z, then the result will be a very,\nvery massive 2d array, because there are a bunch of ways to actually make this target\nstring. Right. So we've kind of changed the direction of what it means to be like worst.\nOn this example, let's say we brought this to use the Z. If you really cared about optimizing,\nlike this particular scenario, you would find some benefit to like memorizing it, although\nit wouldn't really affect the worst case, because the worst case is actually where you\nreturn a two dimensional array and not just an empty array. So maybe just because it's\ngood practice, well memorize this. But when we go to the drawing board, we'll see that\nthis actually doesn't affect the true a bigger worst case. But if you just want to optimize\nit slightly, let's say we baked in our memo over here, then we check, you know, if our\ntarget is in the memo, and if it is, then we return the memo, add the target, we'll\nbe sure to pass along that memo to our recursive calls. And then we just need to make sure\nthat for our return value on line 16, we actually store that inside of our demo using the target as a key, and then we still\ncomplete the return by returning result like we once did. Cool. So let's run this now.\nAnd I would agree that the last example now runs faster. But it is not the worst case\nis a really important thing to understand here. Right? The worst case is when you actually\nhave to create a massive sub array, right. And so let's head to the drawing board and\nsee our final conclusion about the complexity here. Like we usually do, well define m to\nbe the length of the target string, and n will be the number of words in the word bank.\nWe know that this problem asks us to return an array containing every combination that\ngenerates the target string. And to come up with that answer, we have to visualize it\nlike a tree sort of like this. In our previous drawing, we saw how each leaf of this tree\nrepresents one way we could create the target string. In other words, if we can figure out\nthe total number of leaves in a tree like this, then we will basically have the number\nthat represents how many different ways or how many sub arrays we have to generate in\nthis problem. We already know that based on our process, we described that there are dimensions\nto this tree, we know that the height of this tree is going to be m and we know that from\none level to the next, we really just multiply the number of nodes by n. And that means at\nthe base of this tree, we would have entity m number of nodes, right, so we have n to\nthe M leaves, which means that we have n to the M different combinations that generate\nthe target string. And if we have to represent each of these entity m combinations, then\nwe definitely need n to the M sub arrays in our output. And so what we're saying here\nis no matter what clever implementation we create, we really have to return a result\nthat is exponential in size. And that's really going to drive the complexity of this one.\nYou can't do any better than exponential over here. And its overall will say at the time.\ncomplexity of this is n to the M or just exponential. If you want to split hairs here, you can really\nmultiplied by some additional factors of m. However, the exponential nature of this alone\nreally gives us the overall complexity, right, because once something is exponential, there's\nreally no coming back from that. And in a different vein, we can say that this space\ncomplexity for this is O of M, like we usually say, it's really just the height of the recursion\ntree. And an example like this, where output is very large, we usually don't include the\nsize of the output of the size of the result into our space complexity, which case obviously,\nwould also be exponential in space, because the result is exponential. Right. So here,\nwe'll just refer to the additional space we use for the call stack, which would be o of\nM, right, any solution you come up with for this problem would be just about this fast.\nAlright, and there, we have our all construct problem. So at this point, we've gone over many dynamic\nprogramming problems, and we use that memoization strategy to work out a solution for all of\nthem. However, memoization is only one of the ways we can actually implement a dynamic\nprogramming solution. Right now I want to revisit all of those problems, but this time\nuse a different lens of understanding. As always, I want us to ease into things. So\nwe'll warm up with this fib function, this is the same problem as last time. In other\nwords, I want us to return the F number of the Fibonacci sequence. Here, I'll say that\nthe zeroeth number of the sequence is zero. And the first number of the sequence is one,\nyou might notice that this time around, I'm saying that the zeroeth number is zero and\nthe first number is one. Whereas in the first time we did this, we said the first number\nis one and the second number is one However, no matter how you start the sequence, they\nwill both actually give you the same series of numbers. In other words, down below here,\nI have some examples for n as well as what the output for our fib function should be.\nIn other words, if I asked you for the six Fibonacci number, the answer there is eight,\nlike we always expect, alright, let's get into the heart of this strategy, right? What\ndoes tabulation even mean? Well, it's all about building a table. So what we'll do now\nis step through a tabulated strategy for calculating fib of six. I know that in the long run, I\nought to return the final answer of eight, right? So I hope that I get the answer right\nby the end of this little trace. So with tabulation we're choosing to do is really think about\nthis dynamic programming problem, still in terms of subproblems. But instead of doing\nit recursively, we do it iteratively by building a table, really just an array, and I'm going\nto begin it with roughly the size of the input. In other words, if my input here is the number\nsix, then I basically want an array of length six, notice that if I want the indices of\nthis array, it's kind of line up perfectly with the original input number. And I'm going\nto have to actually add an extra position. In other words, this array spans indices zero\nthrough six, which kind of means that there actually are seven different elements here,\nright, the length of this array is seven. So something very common that I see when students\ntry to implement a tabulated strategy is they kind of overlook this off by one nature, right?\nSo technically, I'm creating an array that has one greater length than my number input.\nBut any case, if this is my array, what do I want it to represent? Well, in the long\nrun, I want to actually fill out this array in a way where each subproblem corresponds\nto an elements of this array. So here's how I'm going to begin this table. The move here\nis to actually initialize every position of this table with zero. And the reason for me\ninitializing zero everywhere in this array is the fact that I know Fibonacci requires\nme to take a sum, right, and zero is a really great starting value when I need to calculate\na running sum, right. But along with that, I need to be sure to seed the starting values\nwithin this table. In other words, if I look at the zero position of this table, it already\nhas a zero, which makes sense because the zero number on the Fibonacci sequence is zero.\nBut what I should also do is make index one contain a value of one. And that kind of entails\nthat, hey, the first Fibonacci number is indeed one. And now at this point, once I've seeded\nthose initial values, now I can actually run the general algorithm to fill out this table.\nSo now it's just a matter of iterating through this table, so I'm going to start you know,\nat the very first position of the table, probably just with a regular for loop. And what I need\nto do is really remember the definition of Fibonacci, right. So if I have this number,\ncurrently in the array zero, that's a zero Fibonacci number, what I can do is just add\nthis current number that I have kind of pointed to in yellow to the next two positions. And\nthe reasoning there is a Fibonacci number is used to contribute to the sum of for the\nnext two Fibonacci numbers. So I'm going to do is take the zero and add it to the next\ntwo positions, obviously, since it's zero, actually don't change the values of those\nnext two positions. It's nothing really is calculated on that first iteration. But any\ncase I can continue on to the next iteration, so my current position is always in yellow,\nand the next few positions are pointed to in blue. At this point, my current position\nsays one is what I should do is take one and add it to both of my next positions. So that\nmeans two and three are indices two and three are contained both a one and a one which so\nfar, make some sense because at least for the to the second number of the Fibonacci\nsequence is indeed one, I can do the same thing, right, my current position contains\na one. So I'll add that one into my next two positions. Keep doing this, I add two to my\nnext two positions, at three to my next two positions. And at this point, I sort of reached the end\nof my array. So I know that I probably shouldn't step out of bounds. So really just want to\nlook one position ahead over here. And at this point, I just add five into my next position,\nwhich actually works out to an eight being stored in index six of this array. Which makes\nsense because logically, the six number of the Fibonacci sequence is a just like we intended.\nThat's all there is to tabulating Fibonacci, the most apparent difference from our previous\nlike recursive strategy was, this is not recursive, right? This really just requires us to iterate\nthrough an array. So to fully iterative process. And at this point, the actual complexity of\nthis is really straightforward to kind of foresee, we know that we're just going to\niterate through an array of size n, that must mean that our time complexity is just n. In\nthe same way, the only space we use is really just the space of the array, which I know\nis still going to be sighs and as well. So overall, we're looking at a linear solution\nfor fib. So before we hop into the code, for this one, I just want to draw a really important\nconnection. So although at face value, this iterative strategy looks very different from\nthe recursive solution, a lot of the logic really carries over, I'm still using my overlapping\nsubproblems to solve this one. So for example, I know that every index of this array really\ncorresponds to some number input for fib of n, right? So I can kind of visualize it like\nthis, right? Like we said, the six of bonacci number is eight. So I'm just going to choose\na position of this table, let's say I looked at fib of six. So I know that to calculate\nfib of six, what I did was really add the previous two numbers into this position, right.\nAnd if you kind of see that the shape of this, I kind of dropped the table, and even just\nignore the rest of the subproblems. This is basically just a tree that can kind of shift\nthings around. And it really looks like this. So overall, you're looking at really the same\nrelationship for calculating Fibonacci. It's just encoded in a table instead of the recursive\ntree. But overall, if you understand, you know, the recursive solution, you should still\nfind, you know, some comfort inside of this iterative solution. But I think at this point,\nlet's hop into the code for this one. Alright, programmers, let's go ahead and translate\nthat strategy into some code. So I'll start by creating a table, which really just means\ncreating an array, we'll call this table. And I need this array to have certain dimensions\nthat are roughly the size of n. So to do that, in JavaScript, I can say array and call a\nstatic method and pass in my desired size. So here, I want to say n plus one. For the\nreason we did in the sketch, right, I need to make sure that the last index of this array\nis exactly n, I have to do a plus one here, because of course, indices start at zero.\nCool, that should give me an array of that n plus one size. And then at this point, what\nI want to do is assign particular values into this table. So let's just say I console dot\nlog, what this table looks like, I'll just run this first example of fib of six. So I'll\ngive this a go. So notice that the array that prints out is this, it says like seven empty\nitems, which means that the elements are undefined right now, according to our strategy, but\nwe should do is assign these all to zero. So what I can do is, after I initialize the\narray over here, I can fill it up with all zeros using the dot fill method, right? It's\nan array instance method. So with that change, now I should have a seven zeros inside of\nthis array. Cool, so it's looking pretty good. At this point, I also need to fill up a particular\nvalue inside of the table, I really need to make sure that the index one contains a value\nof one, right so I can say table at index one equals one. So we're seeding index one\nwith a value of one to symbolize that the first bonacci number is one, remember that\nwe kind of have like two base scenarios. In Fibonacci, let's just console that log with\nthis table looks like now to make sure it's in the correct state before we actually iterate\nthrough it. Cool. So this is a good starting point for our table. So at this point, what\nI want to do is iterate through the table. So use a regular for loop for that. We're\ngonna need access to the indices. So I'll say let i equals zero. And I'll go up to and\nincluding, and basically give me iterations through the entire table. And I'll do i plus\nplus, I'm going to hit every position. Cool. According to what we did in our strategy.\nWhat I should do is look at the next two positions after I right, so I'll say as I'm gonna look\nahead and table and I'll look at positions I plus one, and also i plus two, right? Of\ncourse, right now I'm currently situated at position I. And what I did was I added into\nthose two neighboring positions, I added my current value in the table. So what I'll say\nis, in my next position i plus one, I'm going to increment it by exactly what table I says,\nright? So I'm incrementing, my next position by the value in my current position. And the\nsame will hold true for the next position two spaces away, right, so they both get plus\nequals table. I know nice. So this is looking pretty good.\nAfter we're done doing this process for the entire table, where we're just going left\nto right, filling in our next two neighboring positions, what we'll do is just return our\nanswer, which should be table at position n, right? To finish this off, I just want\nto return the table at index n, because the elements of this array correspond to the Fibonacci\nnumber, right? And the index is sort of the input to my function. So let's try these examples.\nWe'll give them all ago. Cool. So I get 813 21. In this very large\nnumber, this actually looks correct. Nice. This is a fair implementation of Fibonacci.\nNotice that because we're already using an iterative strategy, we already satisfy a decent\ncomplexity for even this, this last example over here, we already mentioned the time and\nspace complexity of this strategy, right, it gives us a linear time and space. However,\nyou may already have in your head that we could actually optimize a little more here\nand just use a constant amount of space. However, if you want to kind of subscribe to just a\ngeneric tabulation strategy that I know is going to be useful in most problems, I will\nkind of stick to this overarching pattern right of initializing our table upfront, that\nis roughly the size of the input, and then iterating through that table. Of course, you\ncan probably finesse this fib function to only track two variables represent your last\nFibonacci number, as well as your last last Fibonacci number. But I'll leave that to you\nbecause it's not really a classic tabulation, which is a topic want to drill into our heads\nright now. Let's head back to the drawing board and do another problem. All right, now\nlet's revisit that grid traveller problem using tabulation. So like before, we're going\nto have a 2d grid, and we start in the top left corner. And our goal is to go to the\nbottom right corner, we only have two possible moves at any point in time that is to move\ndown or to the right. And how many ways can we actually travel to the goal, if we had\na grid of dimensions, m by n. And we want to write our function to actually calculate\nthis. So let's trace through how you can build a table for this one, let's say we're going\nthrough grid traveller of a three by three grid, that means that our output should be\nsix in the long run. So like before, our first step in this tabulation recipe, is to create\na table that is roughly the size of the input. And so here I have two inputs, and they really\nrepresent the number of rows and number of columns. So I can create a 2d array to correspond\nto that. Like before, if I want the indices to match up here, I'm going to have to make\nsure that this two dimensional array has dimensions four by four, right? If I give it a four by\nfour array, that means that the bottom right index is really three comma three, which works\nout nicely, very similar to what we did in that last fib problem. Cool. So I established\nthe dimensions for my table. Now I have to figure out what should I actually begin my\ntable with, right? What are the good seed values to use here? Well, I know this is a\ncounting problem, right? Because they're asking me to count the number of ways to travel through\nthis grid. For these counting problems. Good initial value to choose is usually zero. So\nI'm going to put zero everywhere in this grid. But at that point, I may need to seed another\nvalue in other position in this table, if you recall our previous discussion about this\ngrid traveler problem, we said that it's a really important case that all right grid\ntraveler have a one by one should return one right there is one way to travel the gray\none by one grid. And so I'll go ahead and actually take that information and encode\nit into my table. So I'll make index one one, actually contain the elements of one. And\nI should give me a nice starting point for this algorithm. So at this point, what we\nwant to do is iterate through this table and come up with some logic that combines the\nvalues in this table, right, basically combining different subproblems to solve my larger problem\nat hand. So let's just begin in the top left corner of this grid. In the long run, we can\nreally implement this kind of iterative pattern through a grid using just some nested for\nloops, right. And the key insight is I know if I'm at this position, if I see zero at\nindices, zero comma zero, that means in a zero by zero grid, there's zero ways to move\nthrough it, which makes sense, right? Because if any of your dimensions contains zero, then\nthat must mean that your grid is empty, right? So the game isn't even valid. But if we want\nto have some consistent logic, the move is to use your current position highlighted in\nyellow right now and add it to your neighbors, right, according to the game, I can only move\nto the right or downward. So technically, what I'm doing right now is I'm taking my\ncurrent positions element, and adding it to my down neighbor and my right neighbor. Obviously,\nif I just have a zero in my current position, then really no arithmetic takes place. But\nlet's go ahead and do these iterations just to make sure we have consistent logic, right,\nso they keep adding these zeros to their right and down neighbors, nothing changes for now,\nuntil I get to the next row, right, this first iteration, next row, still just add zero to\nits down and write. But once I'm at this point, I'm going to take this one, I'm going to add\nit to my right and down neighbor. So that means they both turn into a one, I keep following\nthis pattern, right, both of my neighbors turn into a one. And obviously, whenever I\nkind of reached like the bounds of my grid, I need to probably make sure that I don't\ndo any illegal Array Operations. But that's really an implementation detail for the code.\nSo on to our next row, we contribute zero to both of our neighbors. Here, we contribute\none to both of our neighbors. Now we contribute to to both of our neighbors.\nAnd here we contribute three to both of our neighbors. And finally, things get interesting\nin the very, very last row, I contribute zero to my neighbors, I contribute one to my neighbor,\nI contribute three to my neighbor. And at this point, we've kind of finished iterating\nthrough the entire grid. And if you look at this position, it contains a six symbolizing\nthat, hey, how can you actually travel through a three by three grid? Well, there are actually\nsix different ways you could do that. So before we jump into the code for this one, you can\nprobably already foresee the complexity of this. So we know that the complexity is really\ndriven by the dimensions of this table, I know that this table is going to have m rows\nand n columns. So if I need to iterate through this table, it's just going to take m times\nn time. And along with that, what is the space that we need? Well, it's really just a space\nfor this 2d array, which is, of course, still m by n. So overall have m times n time and\nspace. Let's jump into the code for this one. Now. All right back into the code editor.\nLet's work on implementing this grid traveller tabulation strategy. So we'll start by initializing\nour table, which is going to be a little more complex here compared to our last function,\nbecause it needs to be a 2d array. So what I'll do is I'll start by creating, let's say,\nthe correct number of rows. So that will be as simple as calling array. And I want really\ndimensions m plus one, again, I have to adjust for that off by one error, because I want\nthe max index in this table to actually be exactly right. And I know indices start at\nzero, so I'm going to up it by one over here. Cool. So I'll give me the correct number of\nrows. And I want to make sure that the elements inside of this array are also other sub arrays.\nSo a trick I can do for that is we're going to fill this is kind of just a very particular\nJavaScript pattern, I'm going to call fill on this array I just created. And afterwards,\nI'm able to map over it. Cool. So maybe I'll spread this out like this. And when I map over this array, what I want\nto do is make sure that every element of the array is going to be a new array like this,\nthis time of dimensions n plus one though, so I have roughly m rows and n columns. So\nlet's go ahead and just see what the shape of this is. When I print out, let's say the\nthree by two example. So we'll go ahead and run this code. So notice that if I look at\nthe arrays I printed out here, it looks like I have a four by three array, which makes\nsense because again, I increase my initial dimensions by one that looks good to go. However,\nwhat we'll want to do is really understand how what this map is useful for. So a very\ncommon mistake that you might be tempted to do is Can't I just, you know, skip this map\npart, and then do the fill with the array of n plus one. So that will look like it gives\nyou the same thing. So I'll run that code. But if you write it this way, what you're\ndoing is you're filling the entire outer array with a single array instance multiple times,\nright? So the shortcoming of this code is let's say I kind of change only one position\nof the table, let's say I just made an X kind of arbitrarily, that would actually look like\nit changed many positions of the grid, right. And that's because this is technically just\none array that's inserted multiple times into the outer array, whereas I need a really unique\narray references. So that's how we need the map pattern here. I know every time we evaluate\nthe callback function to map, it's actually going to execute this entire function, which\nmeans it's going to give us a new inner array instance. Right. So if I use this map pattern\nI run again, this is really the intended behavior, right? I have a unique array as a sub arrays\nhere. And so let's take out this expert. But that being said, Now that I have the correct\nshape of my table, I need to insert some good starting values, right? So what are the seed\nvalues here, while we're calling in our strategy, we said that basically the entire table could\ncontain mostly zeros. So maybe I'll bake that right into this line. So after I make a new\nsub array, I'll be sure to fill it with some zeros. So if I run that, now, I should have\na nice table, because that's looking pretty good. At this point, I also need to see another\nvalue, right? We talked about it in that we should see table at position one, one with\nexactly one, this is sort of like our base case, when we have a one by one grid, there's\ndefinitely only one way to travel through it. So now we have the elements of one in\nposition. One, one. Nice. So at this point, now I need to iterate through my table and\nfill in other positions. So I'm going to use just nested loops for this. So I'll say let's\ni equal zero. And I want to make sure that I goes up to and including m right, basically\nthe dimensions of the table, and I'll do i plus plus. And very similar for my inner loop\nbeing sure this time to reference j and j is gonna go up to n this time, because we'll\njust have classic nested loops just iterating through this two dimensional array, right?\nSo as I'm iterating through the table, what was the logic we trace through in our drawing?\nWell, I what I needed to do was take my current element that I'm at, so maybe I'll call it,\nlet's say, my current. So my current element would be at table ij. So I need to take this\ncurrent element, and I need to add it into my right neighbor, and my down neighbor, right.\nSo if my row is I and my columns j, that just means I do some arithmetic on i and j. Right.\nSo if I want to increment my, let's say, right neighbor, what I can say is, look at table,\na position i, j plus one, that'd be directly to my right. And I'm going to increase it\nby whatever this current is, if I want to look at my down neighbor, and that'd be i\nplus one, but I keep j the same. Cool. So this will add to my two neighbors that are\nto the right of me and below me. And at this point, what we have to be aware of is like\nwhat happens at our edges of this table, we know that if we're already at like the last\nposition of a row, if I do j plus one, I'm gonna go out of bounds. And so to make sure\nI don't step out of bounds on these increment expressions, I'll need some conditional logic.\nSo I'll say if the right position is inbound, so if j plus one is less than or equal to\nn, then I'll go ahead and increment to the end should be okay. And likewise, if i plus\none is less than or equal to m, then I'll also increment right? Notice that when I checked\nmy like j value, that should be using n, right, because that's the number of columns and then\nI is a number of rows. So it should use M. Cool. So what I have so far as I'm iterating\nthrough every position of my table, and I'm going to take the elements at my current position,\nand I'm going to add it into my right neighbor, as well as my down neighbor, about only if\nthey actually exist. Cool. So once I'm done filling up the table, then my final answer\nshould just be at position m, and right just the very bottom right corner here. So let's\ngive this code a run. So I should get 1336. And then there's a very large number, or run\ngrid traveller. Nice and looks like this solution is totally\nworking. And we are already satisfying our the last example here, right? If you tabulate\noff the bat, you will have a pretty quick solution. And we already traced through the\ncomplexity for this. So take a moment to you know, look at this code, let it sink in, or\nreally try to understand how we took that whiteboard strategy and implemented it in\nsome code, right? We do have to do some like kind of fine implementation details, especially\nwith the bounds checking here. But I think the most important logic, it's about how our\ncurrent position of the table contributes to our immediate neighbors to the right and\ndownward. With that, I think let's head back into the drawing board. Alright, now that\nwe've seen tabulation in two different problems, hopefully we're noticing some patterns right?\nLet's give ourselves some rules we can follow to tackle any dynamic programming problem\nusing a general tabulation strategy. With this tabulation recipe, it's going to be pretty\ndifferent compared to our memoization recipe in that there aren't two main steps when I\ntalked about memorization I said, make sure you implement the brute force first, and then\nadd the memorization app. Towards. Whereas if you just try to tabulate a problem, you're\nreally going to have the most efficient version of your solution all in one swoop. And so\nwhat is our first step for tabulation? Well, of course, you have to visualize it as a table.\nAnd that really begins with a conversation of what you'd like the size or dimensions\nof the table V, that should definitely be correlated based on the size of the input.\nSo in the case of fibonacci of n, we made our table roughly, you know, n elements long,\nsometimes you definitely have to watch out for like an off by one scenario, which we've\nbeen seeing lately. In the case of our grid traveler problem, we saw that because our,\nyou know, problem represents a grid, we had to create a two dimensional table at that.\nSo figure out the size of your table based on the inputs to the problem. Cool. And once\nwe do that, we need to initialize some values within the table. To me, this is always about\nchoosing compatible types. In other words, if your problem asks you to return a number,\nthen it'd be wise to initialize the values of your table with numbers right? On the flip\nside of that, if I was asked to return a Boolean in a problem, Na, consider initializing true\nor false within the table. Cool. And once I have all of the kind of generic values filled\nup in the table, then I choose my very important seed value, right? I know that this seed value\nshould capture the scenario, where I have a trivially small instance of the input where\nI automatically know the answer, right. So in the case of our classic Fibonacci, that\nmeans I just seed the N one and the N two values of my table with one and one respectively.\nAnd in the case of our grid traveller, we were sure to capture the scenario where we\nhad a one by one grid, so you're gonna need to see those values, because that's the basis\nupon which we fill the rest of the table. And then we have the hard part, which is really\niterating through the table. And you have to come up with some logic, right, as you\niterate through the table, you have to design some logic that fills further positions of\nthe table based on the current position. And you really have to, you know, look to the\nproblem to figure out what the logic is. In the case of Fibonacci, it's as simple as if\nI'm at some position of the table, I look one space ahead and two spaces ahead, very\nreminiscent of the pattern Fibonacci, in the case of our grid traveler problem was about\nlooking the unit to the right or the unit downward, effectively shrinking the size of\nour grid. So it's really up to you to figure out the logic, look for it language in the\nproblem. What I always do is focus on what options I have at any point in the problem,\nright? My options are Do I go rightward? Or do I go downward in that grid traveler and\nproblem. So we'll stick to these rules as we tackle our a tabulation problems, and we'll\nutilize them right now. Okay, so let's work on tabulating our can\nsome problem now. So recall that in this problem we want to do is take in a target sum as an\nargument, as well as an array of numbers. And we want to return a Boolean indicating\nwhether or not we could generate the target sum. By adding numbers in the array, we can\nreuse an element of the array as many times as we want, we can also assume that all the\ninput numbers over here are non negative. So we've solved this problem before, right?\nrecursively using memoization. But now we want to use a tabulation point of view. So\nlet's come up with the strategy here. So let's say I gave you this input of seven and an\narray of 534. In the long run, the answer is true because it is possible to generate\nseven, right, you can either do a three plus four or a four plus three, and that would\ngive you your original target. So you know that in the first step for tabulation, all\nwe need to do is create a table. But I guess the question here is, what size table do I\ncreate, I have two inputs, I have the target as well as the array of numbers, which of\nthose actually contribute to my initial table. And so the key insight is to think about,\nyou know, what's going to change throughout the problem. In other words, if we can reuse\nthe numbers of the array as many times as we need, then it's not like we're shrinking\nthe size of that array. However, if we think about the target number of the target, some\nthat were given, we do have a goal of actually reaching that target. So now we're going to\nincrease to it over time. And so I'm going to use that as a basis for my table. That\nis, I want to create an array that is roughly the size of my target sum. So because the\ntarget sum is seven, I want to make sure that the indices lined up perfectly. So I'll actually\nhave to create an array with length eight. And in general, I just be creating an array\nof length target sum plus one, because we have that classic off by one error over here.\nAlright, now that we have the correct size of table, what do I actually want to store\ninside? That is what should the eventual elements of this array be? So a really nice rule of\nthumb you can use for that is to just recognize what type your answer should be. In the long\nrun, right, so here, they're asking for a Boolean answer. So that really tells me that\nI should probably put some boolean data as the elements of this array. So I'm going to\nstart by initializing every element of this array with a false value. And the reasoning\nis right now we're kind of assuming before we check anything, that none of these target\nsums are actually possible to be generated. Cool. But neither think about any particular\nseed values, I need something inherent to this can some problem is we treat the target\nsum of zero very special, right sort of the base that we use. In other words, someone\ngave me a target of zero, I know that that is always possible, no matter what elements\nI have in the array, because to generate zero, I can just take no elements of the array.\nSo that's going to be a really important seed value here. So I'm going to populate index\nzero with the element. True. Cool. So now that we have some good seed value, now we\nwant to think about how we can flesh out the other elements of this array, sort of in a\nlinear fashion, right? So I'm gonna have to iterate through this table. So let's just\nstart at the very first index. So right now I'm looking at index zero. And if I'm situated\nin any position of this array, then the value I'm currently looking at, should basically\nsay, you know, is it possible to generate that index amount? In other words, since I\nhave a true at index zero, then I know that it is possible to generate zero using the\ncoins of the array. But now that I'm at this position, how can I actually transition into\nthe further positions of this table. And so what I want to do now is consider the possible\nnumbers that I can take into my sum. So I'm going to start by looking at this first element\nof five. I know that if it's possible to generate zero, then if I also have a five in the array,\nthen it's also possible to generate five in the context of my array, that means I should\nlook about five spaces ahead from my current position. So I look at this spot, right, exactly\nfive indices ahead. And right, now I should actually replace this false value that's stored\nat index five, with a true and again, the reasoning is, if it's possible to generate\nmy current amount, right, right, I have a true in the zero, it's possible to generate\nmy current amount, and I could take a five, that means that the position of five steps\nlater should also be true, right. And I want to actually continue this process for the\nother values in my numbers array. So I'm just going to look at the next element of three,\nthat's basically telling me that, hey, the next spot three places away should also become\na true, so I'll just go ahead and make that a true. And finally, likewise, for the last\nelement of four, right, the element four spaces ahead, should also be turned to true. Cool. And at this point, I think I finished\nlike my very, very first iteration, that is when my current is at index zero. And at this\npoint, I just want to keep iterating through the array, so I'm just gonna shift my point\nof view, or one space to the right. So now I'm looking at my current as index one. And\nwhat does that over here, my current element is actually false. So what that means is,\nit is not possible to generate one using the numbers of the array, which logically makes\nsense, right, I only have five, three and four. So there's no way you can ever give\nme back a one, right. So if I have a false value at my current position, then I should\nnot modify like my further values by looking ahead. So notice that if I look at my edge\nfor five, look, five spaces ahead, I am not going to make that a true because my current\nposition is not true, right. So I'm going to keep iterating. Same thing happens when\nI'm at index two, because the current value is false, there's nothing to be done here,\nthings get really more interesting on this iteration right? at index three as my current,\nthen I see a true at this position. So that means I need to look ahead to my future positions,\nand actually assign them to be true. Obviously, you'll notice over here, if I look five positions\nahead, when I'm currently at index three, then that would actually be out of bounds.\nSo I don't need to look that far ahead. So we'll kind of drop that connection. But at\nthis point, I should make the space three positions ahead truth, that's almost a space\nfor positions ahead. So that means that indices six and seven are set to true, right? I keep\ndoing this process all the way through the entire table. Notice that as I keep iterating\ntoward the right, these forward looking references kind of stopped being useful because it goes\nout of bounds. But the point is, by the end of all of these iterations, I do have a true\nstored at index seven, which means that it is possible not to generate a quantity of\nseven. And if I do a quick spot check, and I look at just my entire table right now,\nit has very consistent data. In other words, if I notice where all of the true values are\nright there at 03456, and seven, that means that all of those quantities for target are\nactually possible, right? On the flip side, if I look at the only elements and indices\nthat are false, like one and two, that makes sense, because those are the only quantities\nthat are not possible or you can't possibly generate a one and two, using a five, three\nand four as your option. Adding up, right? So we know by the end of this algorithm, the\nelement that is stored at the last position of our table would be the final answer, right?\nSo if it's true, then it's possible if it's false, it is definitely not possible. All\nright, so let's wrap up this sketch by actually talking about the complexity of this, as always,\nwe'll define our terms. So we'll say that n is going to be the target sum, which is\njust a number. And the flip side of that will say that n is going to be the length of the\nnumbers array. And we already have the vibe that, hey, both of these terms definitely\naffect our complexity, right? If you give me a larger target sum, that's probably a\nharder thing to calculate. In the same way, if you give me more numbers to choose from,\nit's even harder to calculate, right. And we can recognize that the algorithm just has\nus flesh out this table. And I know that the table is of size m, so we're going to have\nat least M. However, as I iterate through every position of the table, what I had to\ndo was actually look ahead in the table for every single element of the numbers array.\nSo I know that that's going to be accomplished basically, using some nested loops, where\nI'm going to have a loop to iterate through just the table, and then a nested loop to\niterate through every number of the numbers array. So overall, I'm looking at N, N times\nN, time complexity. And along with that, where does this space here? Well, the space is really\njust the exact size of this table, which is based solely on M. So I have just m space\noverall. Nice. So this is already looking like an efficient implementation, especially\nbecause we're not dabbling with any exponential complexity over here. I think let's work on\nthe code now. So here we are back in the code editor, let's start like we usually do by\ncreating our table. So I'll store this table, and like we discussed in our drawing, we need\nto make it roughly the size of our target sum. So I'll create an array, I need to make\nsure that the indices lineup directly or at one index, that is exactly the target sum.\nSo I'm going to initialize it to target sum plus one, right. So that means if I pass in\ntarget sum is seven, when I create an array of length eight, which means that its very\nlast index is seven, which is perfect. Cool. And while we're here, we'll go ahead and actually\ninitialize this array with all false values. So I'll do that. I need to make sure that\nI seed index zero with a true symbolizing that the target sum is zero, it's always possible\nto be made, even before I look at, you know what's in the numbers array. So I'll just\ngo ahead and say, table at index zero is equal to true. So let's just console dot log, what this table\nlooks like so far. And I'll just run, let's say the second example here. So I should see\nmy array of length beat, up need to go into this tabulation folder. Now I'm going to run\nthis guy. Cool. So it looks like a good table, right? eight elements. And I do have a true\nat index zero. Nice. So at this point, now I want to actually lay out the core algorithm\nby iterating through the table, somebody who's a regular for loop here, let's say let i equals\nzero, go up to I can even include if I wanted to, up to an including the table dot length\nis you could also say a target some here some thing based on target some I'll do i plus\nplus. And here I'm going to choose to iterate using, you know the manual index, because\nI know I have to do some arithmetic to look ahead on the array. But as I iterate through\nevery element of the array, I want to actually check you know if this position is true, so\nI'll check if table at index AI is true. Cool, they know inside of this if statement, I need\nto basically jump ahead or look ahead, based on what's in my numbers array. But I only\nneed to do that if my current position is true, right, I only got to look ahead, if\nit's even possible to get to this current amount, right, the current amount I'm sort\nof tracing through would be at index i. So at this point inside of my if statement, what\nI want to do is now look ahead for each a number of this array, so a nested loop here.\nAnd I just want to look at the elements of this array. So I'll say for, let's say, let\nnum of numbers. So I'm grabbing each element this time. And now for this number element,\nI want to look that many spaces ahead. So I want to look at basically table at index\ni plus the number. Cool. So imagine that I'm on like the first iteration of this, I know\nis going to be zero. So that's the very, very first index of my table. And if my num is\nfive, then I'm going to do zero plus five looking five spaces ahead right just like\nwe did in our trace. And for this position, that is like five spaces ahead. I want to\nassign it to be true, basically saying that, hey, if my current position is reachable,\nand I can take a step of exactly numb then that must mean position. I plus numb is also\nreachable write that entire for loop goes inside of this if statement, right? So this\ncode is looking pretty good. So far, I think the last thing we need is just to return our\nfinal answer. After we're done iterating through the table. So here I'll just return table\nat index targets. Cool. So let's, let's go ahead and run these examples. Maybe we'll\nhave to debug some stuff. Looks like I have a probably an infinite loop. Yeah, my program\ncrashed with some massive error. So let's debug this one together. There's something\nthat I'm not considering in my code. But we did consider when we drew it out. So something\nthat is probably breaking right now is having to do with like the bounds checking. Something\nthat's kind of unfortunate in JavaScript is this characteristic, this may have different\nbehavior, depending on the programming language that you're following along in. But I know\nin JavaScript, I had some array, let's say, array, and I set it equal to just a handful\nof elements, let's say a, b, and c, if you actually do like array, at some out of bounds\nindex, like index, I don't know 10. And I assign it like x, that will actually change\nlike the effective length of this array. So if I take a look at what happens here, so\nI'm just running this kind of offhand example, when we run this, notice that we have about\nseven empty items before we have the X. Basically, when you do this type of weird assignment\nin JavaScript, it's going to like lengthen your array. That way, it makes sure that this\nHey, new element of x is placed at exactly index 10. And so why is that relevant? Well,\nin my code, here, I don't really check if I'm out of bounds, right, and I just assign\nto something that's potentially outside of the current length of my array of my table,\nrather. And if I do that, then this condition is a little suspicious, right? Because if\nI do this assignment on line nine to an out of bounds position, then the length will get\nlonger. And that's sort of like a circular argument, right? I keep iterating, only to\nmake more stuff out of bounds, only to lengthen the table even more. So that's why I ended\nup with like an infinite loop over here. One way I can fix that is to just maybe limit\nthis, so I won't make a table outline that's a little too dynamic. I know, I can basically\nstop once I reach the targets. So that might actually be the better move over here. Pretty,\npretty fair bug though. With that, let's go ahead and run this code\nagain. give that a shot. Here we see true true, false, true and false. And that is the\ncorrect answer over here. Nice. So here's a nice tabulated solution for our khamsum\nproblem. And we already spoke about this code having n m times n, time complexity. Now it's\nreally obvious, right? Because I can see how these exact the loops. And our space complexity\nis simply based off of M right. Cool. With that, let's head back into the drawing board\nfor another problem. All right, now let's work on the house some variation of this problem.\nSo like before, I'm gonna take in the target some as well as an array of numbers. But this\ntime around, what I want to do is return an array containing a combination of elements\nthat actually adds up to the target sum. Right? So here, I want to return exactly one way\nif it's possible. And along with that, let's say that it's actually not possible to return\nthe target sum, then I should just return the null value. And if it's the case that\nthere are actual multiple combinations that can generate the target sum, I can return\nany one of those. So we expect the strategy for this one to be very similar to our last\nproblem. However, we will need some nuanced logic to return the array now, right? Because\nI don't want just boolean data once return an array. So let's sketch this one out. Let's\nsee I'm stepping through this example. Or my target is seven and my array is 534. For\nthis input, a reasonable answer to return would be an array of three comma four, right?\nBecause I can add three plus four to get seven. You can also I guess, switch around the order\nof these elements. So if you also returned four comma three, I think that would also\nbe a valid answer. Point being, I just want to return at least one way that can generate\nthe target. So we know we want to solve this one with tabulation. And so we'll just follow\nour recipe right? And I need to construct an initialize some table, we already know\nthat the size of this table is going to be based on the target sum, so roughly seven\nelements. But we of course, have that classic off by one nature, right? Because I want the\nlast index of this table to align with the actual number argument. And in general, I'm\ngoing to initialize this array with a length that is target sum plus one. Cool. So now\nthat I have the correct shape of table, what do I actually have to initialize as elements\ninside of this table? Previously, like the Boolean version of this problem, we initialized\neverything as false, right. And the reasoning there was, before we actually try all the\npossibilities, we're going to just assume that it's not possible to generate every quantity.\nWe just want to adapt that for this new type of problem. They tell us that if it's not\npossible to generate amounts, then we should just return null.\nSo I think null is actually a great initial value to just put everywhere in your table.\nSo at the start, we're going to assume that none of the values or none of the amounts\nare actually possible to be generated. No is sort of the analog for false in this rendition.\nCool. So now that I have most of the values added to the table, now I need to figure out\nwhat's the appropriate seed value, I need some actual data to begin and get the ball\nrolling on this one. So like we expect, it's about having an amount of zero, right, no\nmatter what if you're given an amount, or a target sum of zero, and no matter what array\nof numbers are given, you can always actually generate that quantity of zero, by just returning\nthe empty array, right, you can take zero elements from the numbers array, and there\nyou have an array whose sum is zero. So of course, that means at index zero of our array,\nwe're going to initialize it with just an empty array. And at this point, what we want\nto do is, of course, iterate through our table and come up with some logic we can use to\nfill out further positions to the table based on our current position. So let's say we begin\nat index zero. So here I am. And I have to figure out which further positions of the\ntable should I be looking at, we've seen this pattern before, I should just base that off\nof what I have as options in my numbers array. So look at my first number of five, that means\nI could look exactly five spaces ahead in the table at this position. And so if I know\nthat my current position is possible, but I see that I have an array and my current\nposition, I know it's possible. If this current position is possible, then a position exactly\nfive steps later would also be possible, right. And so what I'll do is I'm just going to copy\nmy current value into my further value. In other words, I want to put an empty array\nat position five, right. However, I also have to include the number that I'm using right\nnow, right, I took a five to actually get to this position in the first place. So I'm\nalso going to add a five into that array. Cool. If I do a quick spot check, this is\na reasonable thing to do. Because if I look at the state of that index five, it contains\nan array of five, meaning that hey, you can return a sum of five by just taking a single\nfive. And with this, I want to do the same logic for the other numbers of the numbers\narray, right. So if I have the three, I'll look three positions ahead of my current place.\nAnd I'll also start by copying over the array at my current position. So I copy over the\nempty array. And after I copy that array, I actually want to populate it with the number\nthat I took to get to the spot in the first place. So I just go ahead and put a three\nin that array. And the same thing happens for before. So if you go to the next iteration, you see\nthat our current element is null, that means that the amount, right in other words, our\nindex amount, is actually not possible, it's not reachable, meaning we can't get an amount\nof one by adding up any numbers of the given array. So what I should not do is actually\nmanipulate any further values from this position. So I just continue these base iterations.\nSame thing happens when I'm at index two, things get more interesting when I'm at index\nthree, right, I see that the element here is not null. So it is possible to generate\nthree. And so what I want to do is go ahead and look at my my forward values, and for\ncopy my current array over. So I know I don't need to look five spaces ahead, because that\nwould be out of bounds. So I'm going to look at the position exactly three spaces ahead\nin the table and copy over my current array like this, what I also need to do is make\nsure that I include the number that I'm using right now, which is three, right, because\nI'm looking three spaces ahead. So I end up with three comma three, at index six of my\ntable, which is reasonable, right, I also want to do something very similar for the\nposition four spaces ahead. So I'm going to copy over my current array, but then also\ninclude the four that I'm using up right now. So now have three four over here. Cool. At\nthis point, you can kind of see where this is heading right, I've actually already populated\nindex seven of my table, and three comma four is exactly a one way we could create the seven.\nSo we could stop here. However, let's say that you continued the algorithm. So in the\nnext iteration, I know that this space for the indices ahead would be out of bounds,\nso I don't need to look there. But according to our general logic, I would actually manipulate\nthe spot of the table three moves ahead, right. And so what I'll do is if I, you know, follow\nthe same exact logic, I'm being consistent, not really changing any of the rules here,\nI would copy over my current array into that position. So I basically overwrite index seven,\nwith just an array of four. But then at this point, I would also be sure to include the\nnumber that I'm using right now, which is three, right, because I'm looking three spaces\nahead. So I end up with four comma three, which happens to be like another way I can\ngenerate these seven. So it doesn't matter if you actually continued this algorithm,\nright? So if I continued on basically just keep iterating until I hit the very And and\nwhat do I know the element at index seven is exactly an array of four, three. Cool.\nSo the point is you actually don't have to like exit early. As you iterate through the\ntable, you'll be okay to just finish all of your iterations. And you'd still have a valid\nanswer, right? Because in this problem, they just want any way to actually make the target.\nAnd if I take a quick look at my table, I think all of the stored values here make some\nlogical sense. For example, if I look at index two, there's a null, meaning that it's not\npossible to make a two by using elements of the array. In a similar way, if I look at\nindex four, there's a sub array of four, meaning you can just take one four, to make a some\nbefore. Similarly, you can take two threes to make a sum of six. And of course, you can\nmake a seven by doing four and three. So now that we have a plan of attack, let's look\nat the complexity for this. So of course, the M will represent the target sum, and our\nn represent the length of the numbers array. So if we begin with just the time complexity,\nwe know that we're going to at least iterate through the table and the tables of size m,\nright. So I have at least an M in my time complexity. But for every space in the table,\nor in every iteration of that loop, I need to also iterate through all of the numbers\nin my number input array. And so I can multiply by n over here. Nice. But at this point, now,\nlet's say that I actually need to take a valid step here, then what I also did was copy over\nthe array at my current position into that forward looking position, I know that a sub\narray will be at most of length m, remember that m is our target amount, the worst possible\nor largest way we can generate the target sum would be to have an array of exactly m\nones, right. And so we'll say that in the worst case, we have to copy over an array\nof an additional length m, that means our time is really m squared times. And now let's\ncome up with the space complexity for this, we know that the initial size of the table\nis definitely based on M. However, in the long run, we could be storing a sub arrays\nas elements. So this is going to actually be a 2d table. In a sense, I know that the\nsize of any particular sub array here is also going to be m for the same reason we just\nsaid, and so we'd have a m squared space complexity. So overall, we're pretty satisfied with the\ncomplexity of this. Because it's polynomial, right? It's not an exponential quantity. So\nit should run in a reasonable amount of time. All right, I think we're ready to hop into\nthe code for this one. Alright, programmers back in my trusty editor,\ngo ahead and tabulate this one out. So we'll need to create the table to begin, right.\nSo I'll create my table, and it should have roughly targets some positions in it, really,\nI need to increase it by one. So I'll say array, and I'll pass in target sum plus one,\nthat way the final index aligns, I'm going to go ahead and fill this table up with all\nof those nulls. Right, exactly what we did in our drawing. What I also need to be sure\nto do is make sure we populate index zero of our table with an empty array serves as\nsort of like a base case, in that we know that the target sum of zero can always be\ngenerated, right, you can generate the target sum of zero by taking no elements from the\nnumbers array, right? If you took the sum of this array, it would be zero. Nice. This\npoint, we need to iterate through our table. So you've seen this code before. I equals\nzero, go up to and I won't mess this up this time, I go up to an including target some\nI'll do i plus plus. So so far, very similar in shape to our last problem. Now that I'm\niterating through every element of the table, I need to add some conditional logic. If you\nremember, from my drawing, we only did like the heavy logic when our current position\nwas not null, right? Because if it is no, you can't even reach this current position\nin the first place. So I'm going to check if my current amount is attainable. In other\nwords, if table at index i, which is my current amount, if that is not know, if it's not know\nthat I can generate amount I goal. So if I can generate amounts i that i know some other\nthings could also be generated. That is, I want to look forward in my table for every\nnumber in the numbers array. So I'll say let num of numbers, so I'm getting the elements\nof the numbers, right? And I need to look that number of positions ahead right. So if\nI'm at i right now, that means that a forward looking position would be at Table A plus\nnum. Cool, and I need to assign something over here. So I'm going to do is start by\ncopying over the sub array at position I at my current position, right. I know that if\ntable I is not know the only possibility that it could be is an array, right can be array\nof zero elements are going to be an array of many elements. So no matter what that array\nlooks like, I'm just gonna copy over that array. So I'm going to spread out all of the\nelements table I. And so far like this logic is looking pretty good because I'm basing\nmy assignment on table i plus num off of table I, right. But in addition to that, I also\nneed to include this choice of num. So I'm just going to add that into this new array\nas well using some syntax that we've seen previously in the course. Right. So I'm just\ncopying over all the elements of the sub array at table I, and adding on an addition to that\nmy current number. Nice. So this code is looking pretty good. I think at this point, all we\nneed to do is let all these iterations finish, and then wrap up by returning the last entry\nof the table, or really the table at index target some cool, so not that much different\nfrom our last piece of code. Let's give this a shot. So I'll run how some and here I have\na few diverse examples. And notice that some of them should return null because they're\nnot possible. If we check these 32243, no bunch of twos and another No, nice, it looks\nlike this code is totally working. Notice that we already have a very efficient algorithm\nkind of off the bat kind of comes free with tabulation, we definitely have m iterations\nin this for loop, we have n iterations on the inner loop. But then we also have to consider\nthis copying over logic, right copying over an array will be at most m. So it's m times\nn times M, which is just m squared n, exactly how we spoke about it before. It's something\nI really want to emphasize is, you know, in isolation, if someone just asked you to solve\nlike this house on problem, I don't think it's an easy problem. However, it probably\nfeels almost trivial, especially since we just did cancer, right? There's a really,\nreally straightforward progression to these problems. If you compare the house some and\ncan some functions, they're very, very similar, right, really just changing the type that\nwe store inside of our table, as well as the assignment that we do when we transition into\nour further elements of that table. Really just adjusting that logic for the data type\nthat they're asking us for. Right? I had like some array answers here. And here, I have\nsome Boolean answers. All right, so we're smashing through all of these tabulation exercises,\nlet's do one more variation of this target some problem, that way, we'll have a little\nbit of an increase in the difficulty, it's time to revisit the best sum problem.\nSo we're going to take in again, the target sum as well as an array of numbers. But this\ntime we want to do is return an array containing the shortest combination, that adds up to\nthe target sum. And if we have any ties for the shortest combination, we can return any\none of those shortest. So you take a look at an example kind of like we did before,\nwe have eight and an array of 235, there are a few different combinations, I can yield\neight, right, I can do two plus two plus two plus two, or I can do two plus three plus\nthree, or I can do three plus five. And among these options, the shortest one is obviously\nthe three plus five. So that should be the return value over here. Obviously, if you\nreturned five comma three, that would also be a valid answer. Nice. So let's start tackling\nthis with our classic tabulation recipe. So we need to decide on the size of our table,\nlike we usually say it's going to be based on the target sum and not so much the length\nof the numbers array. And like we've been saying recently, it would be nice if the last\nindex of a table aligns with the original target. So although the last index of this\ntable is eight, that doesn't mean that its length would be nine, right? Let's start by\nsetting the proper values here. I always want to begin my my value seed with the type that's\nkind of relevant to this problem. In other words, they want us to always return an array\nif there is at least one valid way to generate the sum. And I know that trivially if I wanted\nto calculate the best sum for zero, no matter what array of numbers, I'm given the answer,\nthere's always an empty array. So I'm going to be sure to store that value at index zero\nof my table. And now for the rest of the values in the array, I can't be sure if I can generate\nthem yet. So I'm going to initialize them as null just like our last problem. At this\npoint, we can begin our general algorithm by iterating through the table. And so what\nI'll do now is look ahead for my current position based on the numbers of the numbers array.\nSo I'm gonna look two spaces ahead. Right now I see that there's a no inside of that\nposition, which means I haven't quite found a way to create two, but I'm actually finding\na way right now, right, I can copy over the array from my current position. But I also\nneed to populate it with how far I'm looking ahead by so just to inside, and do this for\nthe other numbers of the numbers array. So something similar happens for three, as well\nas for the five. Notice that since I just began the algorithm, this is a really the\nfirst time I'm finding any solution for these further values. And so let's keep these iterations\ngoing. I'm going to shift my frame of reference by one since my current position, good things\nand all that kind of entails that one is unreachable, right have no way to generate a sum of one\nit's actually don't do any logic from this current position. So we move ahead to do,\nsince I do have a non null value, right, I have an array over here, that means I should\nlook ahead to my future values. So I start by looking two spaces ahead, I see that at\nindex four, there's a null, which means that I actually need to replace that now. Alright,\nI'm going to copy over my current array. But then I also add the value for how far I'm\nlooking ahead by. So now I have two comma two inside of that index of four. So now I\nlook ahead three spaces, which means I'm analyzing index five, I'll notice that index five already\nhas an array there. And if I actually continue my sort of standard process, I would consider\nthis array, I would copy over my current array in yellow, which is an array of two, then\nI would also add the element I'm looking ahead by which is three. And technically two comma\nthree is one of the ways I can generate five. But it's definitely not the shortest way right,\nI can basically compare the length of these arrays, and notice that the original array\nof just five is definitely shorter, so that one should get the stay in this spot. Cool,\nI'll do something similar for five spaces, I see five spaces ahead for my current position\nyellow, there's a no right at index seven, which means that I can just go ahead and put\nthis new array inside, so I copy over the array of two, then I add the five, right,\nbecause that's how far I'm looking ahead. I keep this process rolling, I'm going to\nmodify two spaces ahead. Notice that this sub array I'm considering\nwould still be longer than what's already stored at index five. So I actually don't\nuse the three comma to write the five gets the same. Now I look three spaces ahead. And\nthis would actually be the first time I found at least a way to generate six. So I copy\nover my current array, and also add my lookahead value. And now if I look five spaces ahead,\nthere's a Knoll currently in that index eight, which means that I'm actually finding the\nfirst way to generate eight, so I copy over my array of three, and then I add my five\nfor my look ahead. Cool. At this point, we've actually already found a way to generate eight.\nAnd you can probably foresee that this would be the shortest way in the long run. However,\nif we kind of continued this algorithm, there would actually be nothing wrong with continuing\nit right, it's not like we're ever going to put something longer in that spot. So if we\ncontinue our algorithm as normal, if I look two spaces ahead for my current position,\nthat would mean I'm considering two comma two comma two, to my array of three, three,\nand obviously, I just maintain the shorter one, so the three comma three gets to stay.\nIf I look three spots ahead, then I would be comparing two comma two comma three to\na two, five. And of course, the two, five is shorter, so it gets to stay. And this process\nreally just continues for the rest of the array. By the end of this algorithm, we do have the\ncorrect sub array stored at index eight. So before we jump into the code, let's look at\nthe complexity of this one. So we'll say that MSR target's m, and n is the length of the\nnumbers array. And so we know that in terms of the time complexity, it's going to be the\nsame as last time, right? Still m squared times n, we don't really add any additional\nlike costly logic, all we're really adding into the mix is just some conditional logic,\nwhich I know is just a very simple if statement. So that's not going to add any additional\ntime. And the same way, our space complexity is still m squared, right, because I have\na table of size m. But I know every element of that table could be an array, really just\na two dimensional array. I think with that, let's hop into the code for this. Back in\nthe editor, let's go ahead and code this one out. So we'll start by creating our table.\nAnd I'll make this table have roughly size of targets. But really target some plus one\nthat way the final index aligns. And when I actually initialize this table, I want to\nactually make sure I have no values inside. So by default, all elements will be no basically\nsymbolizing that, hey, these quantities cannot be generated yet, we have to actually prove\nthat there is some combination that can make them. But the really important seed value\nis to make sure that index zero is an empty array, right? Basically, the one guaranteed\nway I can make zero is by adding no numbers of the array. This point I need to iterate\nthrough every index of my table we always do. I'll go up to the end including why not\nthe target some nice and as I iterate through every position of the table, I only need to\ndo the heavy logic if my current position is not no, right. So if my table and my current\nposition so table I that is not no then I need to do some additional logic. So just\nto review, why do I need to only do the logic if my current position is not know? Well,\nlet's say that it wasn't All right, if my current position is null, then I don't need\nto bother considering any further moves from this position if this position isn't reachable\nin the first place, right? So only if I have a non null position, then I'll actually iterate\nthrough my options in the numbers array, or I'll consider possible moves. So let's say\nlet num of numbers. And as I iterate through these additional numbers, and then I need\nto actually look ahead in the table basically by that number amount. So I need to write\nsome logic about table at index i plus num, right, just looking forward in the table.\nAnd we know based on our previous problem, it can some we ended up doing this logic,\nwe just replaced that position with a new array, where we took all the elements from\nour current position, so table I, we spread out that array. Then we added additionally,\nthis current number that we're using, right, so we have to actually add that into our move\nlist. Cool. However, now we want to actually add some like, min value logic, I want to\nprefer to always keep the combination array that is shorter, right, I want the best way,\nnot just anyway. And so I think the move is or refactor this code a little bit. I'm going\nto actually do this step, maybe separately above. So I'm going to save this to a variable.\nAnd I'll call this my say, combination. This is like my candidate combination, I'm not\nsure if this one is actually the shortest right now. And so if I do the assignment over\nhere, then I'll just use combination. But I only want to do this assignment on line\nnine, if a condition is met, right, so what I want to express is, like, if this current\ncombination is shorter, than what is already stored, right, I only get to replace something\nif it's shorter. That's pretty straightforward to express and an if statement, right? So\nI want to check, hey, if. And my condition needs to be if the thing already there. So\nif the element at index i plus num. If that thing is actually bigger than my current combination,\nso combination, not length, and I also need to be sure to do that element dot length,\nright? If my combination is shorter than my current thing being stored in at that future\nposition, then I'll go ahead and replace it. Nice. So this code is looking pretty good.\nThere's one thing that's kind of missing, but I think we'll just run it and we'll kind\nof debug it together. So let's say at the end, I return my table at index Parkinson.\nCool. So compared to our last code, we only added this conditional logic. So if I run\nthis, something's gonna go awry. And kind of foresee it's very an error. And the error message\nis pretty on the nose over here, it's saying, alright, cannot read property length of null.\nRight. So it's really about, particularly this expression. So we know that our initial\nstate of the table has a bunch of null values. So when I look ahead to a future value, and\nfor the first time, I actually have a way to make it, then I'm going to check the element,\nwhich is no dot length, or I cannot do null dot length. Right. And so I need a way to\nkind of get around that. If ever, I have like a null value in my table, then I can just\ngo ahead and do the assignment, right, because I found at least one way to make that. So\nwhat I'll say is I can put an order here. So I can still do the assignment will say\nnot table, i plus in JavaScript knows a falsie value. So let's say table at index i plus\nnum is no. So this expression is no which is really false. So if I say not false and\nevaluates to true, so I'll go ahead and still assign that combination to that position,\neven if it isn't all, another great reason for using this syntaxes. We know toward like\nthe tail end of our algorithm, we're going to potentially look out of bounds, which means\nthat these elements could be undefined and undefined is also a falsie value. Right? So\nhere I'm saying not false, which triggers as true, which means I would still correctly\nassign those positions. Right. The important thing is I need to be sure to not do this\nexpression. When the element is null or undefined. You can't say no dot length, and you also\ncan't say undefined, not length. So this expression will guard against that. So with that change,\nlet's go ahead and run this. Cool. So 73544 and a bunch of 20 fives nice, especially looking\nat that last example, like 20 fives is obviously the best way to make 100. And just to be super\nSure, should be no different if I even switched around the order of these sort of ways. So\nwhat I put like, one, five in two. That should still give me a bunch of 20 fives, right?\nBecause it's really looking for the best way to generate each some, which would mean the\nsmallest summary. So there we have it a pretty interesting tabulation a problem. However,\nI do want us to recognize how similar it is to our last how some problem, right? So here,\nI have best some on the left and how some on the right, notice how similar the code\nis. Really, the only difference is this if statement, right? For the best some problem,\nI just added this conditional logic. And all this does is prefer to keep the shorter combinations\nover the longer combinations, right, because that's what I want to return in the long run.\nWhereas in houssam, we don't really have any preference in either direction. Awesome. So\nlet's go ahead and go back to the drawing board, I think we'll kind of switch things\nup. Let's switch gears a little bit and revisit those string problems with tabulation. Let's\nbegin with that can construct problem. So we're going to take in a target string as\nwell as an array of words in a word bank. And this version of the problem and I want\nto do is return a Boolean, right, true or false, indicating whether or not I can make\nthe target by concatenating, any number of elements from the word bank array, and I can\nreuse elements in the word bank as many times as I want. So we've seen this problem before.\nBut just to refresh, let's take a look at an example. So let's say my target was abcdef.\nAnd I gave you this array of some different substrings. In this particular scenario, it\nis possible to create abcdef using members of the array. So the answer here is true.\nAnd one way you can actually create your target string is by just doing ABC plus the fright.\nAlright, let's start to apply our tabulation to this one. So I'm going to create a table\nand you probably already recognize that, why I want to base the size of this table off\nof the target string, right, because that's really where I have some problems, I'm going\nto be decreasing the size of my target, or in other words, building up to my original\ntarget over time. And so I know that I'm going to make it about the target string and not\nthe array of words, because I'm never going to remove a word out of the word bank. So\nI'm gonna start with this table. And here the sizing is is kind of particular, because\nwe need a way to have this table or represent information of a string, right. Whereas before\nwith our number problems, it's very straightforward to just use the index as the actual number.\nSo we're going to use a little clever have an encoding here. And so what you'll notice\nis here, I created an array of size seven, right, table dot length is seven right now.\nAnd in general, you'll want to size your table by doing target dot length plus one. So we\nstill have that sort of off by one scenario, that's kind of a very characteristic of these\ntabulation problems. And so what will this table represent? Well,\nif I just think of the characters of my original target string, I know they have corresponding\nindices sort of like this, you're probably wondering, then what's the point of having\nthat extra spot at the very end of the array, right? What I need to store index six, if\nit has no corresponding character. And the reasoning is, we need a way to actually represent\ninformation about the empty string. And so here's the pattern we're going to use. If\nI look at index zero of this table, then I'm actually making a statement about the empty\nstring. So pretend that if you look at a spots of this table, depending on what that index\nis, you're considering the substring, that starts at index zero, and goes up to but not\nincluding your current position. So we'll see how this scales over the rest of the indices\nhere. So imagine that now is at index one, I'm looking at index one, and you're really\njust looking at the A string, for at index two, then you're looking at a B, if you're\nat index three, then you're looking at ABC, for index four, then you're going A through\nD, if you're at index five, you're looking at A through E. And so the really key insight\nhere is if I'm looking at index five of my table, it means I'm making some logical statement\nabout the substring starting from index zero going up to but not including index five,\nright? So if I wanted to make a statement about the entire target string, then I should\nactually look at index six, right? Because imagine you start your substring at index\nzero always, and you go up to but not including your current index. And again, the whole reason\nfor this is I need a way to actually make a statement about the empty string. And so speaking of the empty string, let's\ngo ahead and talk about our C values. We know that a really core you know pattern in this\ncan construct problem is to use the fact that hey, if your target string was empty, no matter\nwhat array of words you were given in your word bank, that is always possible. So it's\nalways true. And so that means at index zero of my table, I can go ahead and seed a boolean\nvalue. How do I know what type to even store as the elements of my table? Well, if the\nproblem is asking me to return a Boolean, then it's probably a good To actually just\nbegin with some boolean data in your table. So if index zero is going to start as true,\nI'm going to initialize the rest to be false, right. So I'm going to consider all of these\nother sub strings or prefixes as not possible until I prove them otherwise. Alright, so\nlet's begin our general algorithm. So we'll begin like we always do by just iterating,\nfrom left to right through our table. And just we have some notation to make it easier\nto kind of translate the information in a table to the statement it makes about our\ntarget string, I'm going to have the characters up top, and I'm going to like them up based\non the substrings that we're really considering here. So if I begin at index zero, like we\nsaid before, that means I'm making a statement about the empty string, right, I see a true\ninside of this position, which entails that the empty string can be constructed using\nthe word bank. Cool. At this point, I have to figure out how I can look ahead to my further\nvalues in the table. And I know that I can do that based on the choice of words in the\nword bank. So let's look at one of our words like a B. So something great about this option\nof a B is it actually is something that begins from my current position, right. In other\nwords, if you look at my current position in yellow, the characters below it start with\na and follows with me. So taking an AB right now would be a totally legal move, right those\ncharacters align. And so what I'll do is, I'll go ahead and look two characters ahead,\nby look two characters ahead in my table, that just means look two indices ahead. So\nnow I know that this position of the table is actually reachable by just taking a B.\nSo I put a true here. And now at this point, I would do this same logic for the other words\nthat have their characters aligned. In other words, ABC is also some matching word. So\nI'll go ahead and make that a true. And ABCD would be the only other one that actually\naligned its characters. So I'll make that one true. Again, how do I know to actually\nput this information in the table, it's really just the length of the word right, my current\nposition right now is at index zero. And I'm looking at a word that is four characters\nlong. So that means I just look for characters ahead to store my Boolean. Cool at this point,\nI'm actually done looking at all the words for this current position. So now I can move\nmy current ahead one. So now I'm at this position. And so what you'll notice is in this current\nposition at index one, we have the value of f, which means that it's false, right? It\nis not possible to actually generate in a write, there's no way you can ever just give\nme back an A, because all of your substrings in the word bank are too long, right? So I\ndon't actually need to do any of my heavy logic from this position. However, on the\nnext iteration, when I have something that's true, then I need to do my heavy logic. And\nif I do a quick spot check, I have a true stored in this position to write if I'm looking\nat the value stored at index two, that means I'm making some statement about indices zero\nup to but not including tomb. So really just the substring AB. And I know that if it's\ntrue, that means it's possible. And looking at the elements of the array, it's definitely\npossible, right? You just took a beat even get to this position. But I need to look ahead.\nSo I'm going to look at any words of the word bank that match starting from my current position.\nReally, the only option here is CD, right. So if you look at my going characters, right\nnow, that means I can take this CD. And so what I'll do is I'll look two characters ahead\nand place a value at that position. That's true. But the value stored at this position\nof the table is already true. So nothing really changes here. And there are no other words\nof the word bank that actually begin with a C. So I'm actually done with this pass.\nSo now I move my current again. And I look for any matching words that begin with like\na D, and potentially other characters after that, really, the only one here that works\nout is D, F. And so looking at my going characters, now I'm basically considering this chunk,\nright ABC followed by TF. So I'm going to look three positions ahead, because the word\nI'm considering right now is three characters, right def is just three characters. If I do\nthat, I'd be looking at this position. And I'd be making this one a true now basically\nsaying that it is possible to construct abcdef colon at this point, I would do the same thing\nfor the rest of the table, we know that nothing else is really going to change within this\ntable. And so by the end of the algorithm, we have\na true start at index six, which means that our entire string is possible to be constructed.\nRight? And so if we do a quick sanity check, if I look at the table at index six, that\nmeans I'm making some statement about the substring that starts at zero and goes up\nto but not including index six, which would really be the entire A through F. I know that\nit's true. So that substring is possible to be generated, right, which was our final answer\nfairly elsewhere. Like maybe at index five, there's a false here, which means that I'm\nmaking some statement about indices zero through four, right, so ABS C, D E. And since there's\na false at this position, that means that it's not possible to generate this string.\nAnd looking at just the elements of the word bank, it's definitely not possible to ever\nget a, b, c, d, e. Cool. So the data within our table a does look consistent with that,\nlet's actually talk about the complexity. So we know that m is going to be our target\nstring, whereas n is going to be the number of words in the word bank. And so we just\nconsider the time complexity right now, we know that we're at least iterating through\nevery element of our table, and our table was roughly size M, right? However, once we\nwere at some current position of a table, we had to look ahead based on all of the words\nin the word bank. And so that would be an N operation for every iteration of m. And\neven still, as always, considering the words coming from my current position. And to make\nsure that their characters aligned, right, I can't just take arbitrary words, from the\nword bank, I have to choose the ones that have their characters matching right now,\nI know that the maximum length of any word or the maximal length of a match, I would\nhave to do would basically just be in terms of M, so give me an additional m term. So\noverall, I'm looking at m squared n for the time complexity of this one. And besides that,\nwe already know that the space complexity comes from the table, which is just a array\nof Boolean, so just m space overall. And so from a bird's eye view, it looks like this\nstrategy would be an efficient one, right, we have a polynomial time complexity, but\nmore importantly, a non exponential complexity. So let's code this one up now. Alright, let's\ncode up this can construct problem. So we'll start by creating our table. And so we'll\nsay create a new array of size target dot length, plus one just like we spoke about\nin our drawing, then from there, I need to give some initial values to my table. So I'm\ngoing to go ahead and fill this one up with all falses. So we're going to assume that\nevery like prefix of our target cannot be constructed until we prove it otherwise, then\nI need to actually also initialize table index zero to be true, symbolizing that the empty\nstring can always be generated, right? Then from there, I need to iterate through every\nindex of my table. So I'll say i equals zero, just go up to the entire table. And here just\nto be safe, I'll say is less than or equal to target dot length. Nice. And as we iterate,\nwe actually need to check our current positions value. Recall that in our strategy, we said\nwe only need to do like the heavy logic, if our current position is reachable, so our\ncurrent position should be true. So I'm gonna go ahead and check Hey, if my table at index\ni is true, then I'll do some additional logic. If I enter this if statement that I need to\nconsider any further choice of words I can use to progress to other spots in the array,\nright? So over here in this if statement, I want to iterate through every word of the\nword bank, right? So I'll say four letter word of word bank. Nice. And so what I want\nto do, as I iterate through all my possible words is I need to make sure that these words\nI iterate through actually match their characters to my current spot that I'm at. In other words,\nif I am at my very first index of a over here, then when I iterate through all the options\nof words, I need to make sure that I only use a valid words that match like a, b, or\nABC, or ABCD. Right? There's no point of me trying to use def right now. Right? I need\nto actually kind of narrow down my words, based on whether or not they match characters,\nright. So to do that, I can check pay if. And what I want to express is, you know, if\nthe word matches the characters, starting at position, I position I goal, it's not going to translate\nthat into some code. Well, checking if a string matches to something straightforward, just\nabout using equality, right? But I have to figure out how can I look at the correct you\nknow, substring of characters within my original target, right? It's pretty straightforward.\nAll I need to do is say target dot slice. I'm going to slice starting at index i. And\nhow far do I want to go? I basically want to go like the length of my word. So the move\nhere is to say go from I up to i plus word dot length. And so let's kind of break down\nthis logic. So what it's trying to do is check if your word matches your characters starting\nat position I. So let's check an easiest scenario. Let's say that my current position is zero,\nright? So right now is zero. That means I'm at this position like this ABCD f example.\nLet's say right now that my word is ABC. So if I look at this slice, it's going to slice\nstarting at index zero, up to and not including zero plus three, right, the length of my word\nis three, zero plus three is just three, that would actually look at this run of ABC. Good.\nAnd let's say we were somewhere further in the string. Let's say we were actually at\nthis D character over here. And so if I'm at this D character, that means my value for\nAI is going to be three Wragge, oh 0123. And the current word I'm considering, let's say\nis this def, the length of this word is three. So this ending index is going to be three\nplus three, which is six. And so I would actually slice starting at this character, three, going\nall the way through the end, right? 345. And I always exclude the ending index of six here.\nSo this logic is good, right? All it does is check if my current word matches the characters\nstarting at index i, goal. So if I enter this if statement, then I have a successful word.\nSo I should actually set a true in that forward looking position. So I can just set table.\nAnd when I look ahead, how far do I need to look? Well, you need to look exactly this\nfar ahead, right, i plus word dot length, matching me we're at index zero of our target\nstring. If I take ABC, then I end up word dot length characters later, three characters\nlater in this example, right. So I'm saying table of i plus word dot length, that should\nbe set to true. Cool, notice how similar This is to our previous number, like our target\nsome problems, except now we have to adapt this four string data. So now I jump ahead\nbased on the length of the word I'm choosing. So this code is looking pretty good. Let's\ngo ahead and do our final return value. So I want to return the table at Target dot length,\nright? Basically, if I'm at the last position, or at Target length, a position of my table,\nthat means I have the information for the entire target range starting at index zero\nall the way through the end of the target. So here are some examples. Let's give this\na run. So I get true, false, true, false. Nice, and there we have a nice working solution.\nSo take a moment to let this code sink. And really the most tedious logic here is probably\nthis particular slice. So really try to make sure you kind of understand how this comment\nis implemented using this code. If you remember our previous recursive immobilization strategy\nfor this problem, we needed to actually have logic to make sure our prefixes match. This\nis sort of the analog for that, right. So we already spoke about the time complexity\nfor this one, but it's already in plain sight, right, we have m iterations here, we have\nn iterations here. And then the additional work we do is this slice, right, I'm slicing\nfrom my target, which is also M. So overall, I have m times n times m, or m squared, N.\nAnd of course, the table just takes up definitely m space. Cool. So with that, let's head back\ninto the drawing board. All right, now let's revisit the count construct problem. So we're\nstill going to take in a target string as well as an array of words in a word bank.\nAnd this time, we want to return a number, right, we want to turn the number of ways\nthat the target can be created by concatenating elements of that word bank, we can reuse elements\nof the word bank as many times as we want. So let's take a look at an example of this.\nSo let's say I had this input, so I have the target of purple, and I have an array with\nsome substrings. The return value here should be two because they are exactly two ways to\ncreate purple. You can do perp plus le, or you can do p plus u r plus p plus le ran,\nthose are two distinct ways. So notice in this problem, we really just want to return\nto the numbers. So we'll just keep that in mind. So let's follow that classic tabulation\nrecipe, we'll initialize our table with roughly the size of the input that changes, which\nis really going to be the target string, right, we want to actually use overlapping subproblems\non the target string. And like we always say, we're going to have\na little off by one scenario here. Although the number of characters in my purple string\nis six, I want to initialize a table of length seven. In general, you want to make sure your\ntable has target dot length plus one a number of elements inside. That way, I have a way\nto represent the empty string, just like our last tabulation. And so we'll start by thinking\nabout what are some proper seed values for this problem. I know that when I have an empty\nstring, empty target strings, my input, no matter what array I'm given, you can always\ngenerate the empty string right by taking no elements of the word bank. So the answer\nfor the target string should be one, right, there's one way to make the target string\nand that is to concatenate nothing together. So I'm going to store the value of one at\nindex zero of my table. Now I have to decide how to initialize the other values in my table.\nWell, I know that it should be number data, right? It's really important that you try\nyour best to make your table contain a consistent data type. If I remember my similar counting\nproblems like Fibonacci, or even the grid traveller of the move here is actually start\nthose other spots in the array at zero, basically saying, you know, at the start, I have zero\nways to generate these different prefixes of purple. And then as to actually find distinct\nways, I'll go ahead and increment those spots in the table. But we'll get to that. So we'll\niterate through our table from left to right, of course, beginning at index zero of the\ntable. And as we do this, I'll also up top show the characters that we're considering\nwithin our table. Remember, the really important pattern here is when I'm at some position\nof my table, that means I'm encoding some information about the substring that starts\nindex zero, up to but not including my current index, right. So if I have some information\nstored at index zero, that information is about the empty string. From my current position.\nNow I need to consider any words of the word bank that I can take right now to give me\nanother spot within the table. In other words, since I'm at index zero, I need words that\nstart with P. So let's say we looked at this first word of perp. And so if I looked at\nthat word, and I took it, that would bring me a somewhere else within the table, right\nhave to look forward like we usually do. So they'll end up at this position index four.\nAgain, notice that we have the kind of off by one scenario here. So although I'm going\nto write information into index four, that informations about the substring, that spans\nfrom zero, up through index three, right, and what I need to do now is take my current\nvalue in yellow, actually add that into my future position. So I just add one into the\nzero. And now index four contains a one, right basically saying that so far, we found a one\nway to construct the string perp. And then from there, I look at any other words that\nthe word bank that match right, so I'll just look at the next word of P. Again, just moving\nleft to right through our word bank, right now, I'm still at my current position. And\nwhat I do if I use this P is I only look one character ahead, right, because p dot length\nis only one. What I do in this future position is of course, just take my current value in\nyellow, and I added into this position, so zero plus one is just a one. There is one\nmore word I can use right now from my current position, that's purple without the E. And\nif I look at that corresponding position, they'll bring me all the way over here. And\nagain, I add the one into that position. Nice, I think that ends are a very first pass. And\nnow we move our current position to the right. So now my current is at index one. So now\nI need to consider words of the word bank that begin with a you and kind of match characters\nthroughout. The only option here is really just you are in the word bank, if I took a\nu r, that would bring me two characters ahead, right, so bring me over here, what I should\ndo like always, is just take my current value and add it into that position. Now I have\na one over here. There are actually no other words of the word bank that match from my\ncurrent location. So I can just move ahead to the next spot in the table. If we're at\nindex two, it looks like we need something that starts with an R, there's actually no\nwords of the word bank that we can use from this position. And what we also notice is\nthere's also a zero at this opposition. So this won't really do anything in our table\nanyway. So we can progress just the next spot in the table. Here's where things start to\nget interesting, right? So right now my current is at index three. So I need to grab words\nfrom the word bank that start with P and potentially have an L enemy. So what I can do here is\njust take this loan p, which will bring me one character ahead. If I look one character\nahead, what I do now is I take my current value, right circled in yellow, and I add\nit into my look at value. So I increment that to two now. Nice. And then from there, I need\nto continue on my logic by just moving rightward in my table, right shift my current point\nof view. At this point, what I do is I again, look\nat any words that start with an le, and there's really only one that matches perfectly, I\nlook two characters head because the length of Le is two. And what I do is I take my current\nvalue in yellow, and add it into that position, right, my logic throughout this entire algorithm\nis very consistent. And there we have a two in the last spot, you can probably already\nforesee that we have our final answer. But if we continue the algorithm as normal, or\nreally, we've noticed that if we move to the next position, there's no word of the word\nthat starts with E. So I don't do anything here. And once we hit the very end, we're\nactually done with our algorithm. Right? And we see that, hey, we have a two in the last\nspot a retailer which is consistent with our expected answer. Something I think is really\nimportant to do is not only recognize that our final answer is in the last position of\nthe table, but really any element of this table should make some logical statement about\nour target string, right? So let's say I look at index for over here. I see that there's\na two in that spot in the array. So what does that really saying? Well, if I am looking\nat the value stored at index four, that means I'm considering the substring That starts\nat zero and goes up to including four. So that really means I'm looking at purp, right.\nAnd if there's a two inside of the spot in the array, that means that there are apparently\ntwo ways to create perp. And if I do a quick check in my word bank, that's exactly true,\nright, you can just take the straight up perk, because that's actually a literal word of\nyour word bank. Or you can do p plus u r plus P. Cool. That's some consistent information.\nAnd then from there, if I actually consider now what I can do from that position at index\nfour, well, you could have taken an le, that's basically what we did when we traced through\nthe algorithm. If you take an le, what are you really doing? Why is that value in the\nindex six, also two? Well, for one, Ellie has a length of two. So that's why I'm looking\njust two spaces ahead in my table. And if I think about what like logical operation\nI'm doing, if I were to take an L e, and add it to all of the ways that I have in blue\nRhino, then I would end up with all of the ways to generate purple right in my last spot,\nliterally just taking the Le as an additional move, right? Pretty elegant logic. Let's talk\nabout the time complexity for this though. So we know that, hey, r m is going to be the\ntarget and n is going to be the number of words in the word bank, this is really going\nto be about the same complexity as our last rendition, right? You can't construct. So\nwe're gonna have m squared times n time, right, we definitely have m time for just iterating\nthrough every spot of the array. And we also have an additional n, because we have to actually\nlook forward for every element of the word bank. And so where does that final m come\nfrom? Like we've been saying lately, it comes from actually performing the match of the\ncheck for matching characters. In a similar way, the space complexity is just going to\nbe m, really just based off of the size of the table, we're only ever storing just some\nnumbers within this table. So our space just stays at linear o of M space. All right, I'm\nfeeling good about this plan, time to code it up. Alright, let's code this one out. Let's\nstart by creating my table, it's gonna begin as an array with roughly target length, size,\nreally target length plus one, that way the index aligns, right, I'm going to fill this\nentire table with zeros for now, because I know in the long run, I'm going to add into\nit. So zero is a great starting value. That being said, I have a really important c value,\nI need to make sure that my table at index zero actually starts as one, right, because\nthere is one way to make the empty string right. Now from here, I can start my core\nalgorithm by just iterating through every position of the table. So set i equal to zero,\ngo up to an including target dot length, and hit every index, right. And so what I'll do\nis iterate through every word of the word bank. So let's word of word bank. And as I iterate through every word, I need\nto check if the word matches my current location right there has aligning characters. So you've\nseen this pattern before, I'll check if target that slice I'm gonna slice some characters\nout of my target. Starting index i right, this is my current position, I need to look\nat the next couple of characters based on the length of my word, I'm going to slice\ni to i plus word dot length. goal. So my current position is I, this will give me the next\nword dot length number of characters starting at position, I will check if that little segment\nis equal to the word I'm considering right now. And if it is equal, then I have a word\nthat I can actually take, I can modify some further position of the table. In particular,\nwhat I should do is need to modify my table at index i plus word dot length. So I'm looking\nto head remember that our current position is I so I'm looking ahead in the table based\non my current words length, what I want to do is actually increase that by some value,\nwant to increase it by the number stored in my current position, right? That's what we\ndid at every point of the algorithm. Nice. A common mistake that I see students make\nis, usually they have a tendency to just increment by one here, right? That's not the move Do\nyou want to do is increment by exactly the number that's in your current position, right.\nNow, at this point, I think all we need to do is just return our final answer, which\nlike we always know, is basically table at Target dot length. Cool, so I have some examples\nbelow. With their expected results, let's give this a shot count construct. So I get\nto 104 and zero, that's that we have a fairly large example, which should return zero, you\ncan't possibly generate this final f here, because your word bank only contains a bunch\nof E's, and it ran fairly quick. So this solution is looking pretty good. Notice how small of\na variation it is from our last problem. Hopefully you're really feeling the progression. So\nlet's kind of quickly just take a look at That that was our can construct problem. So\nlet me split these guys. Very, very trivial difference, right, instead of assigning a\ntrue value. Now I actually just increment because I have numbers within my table. That\nwas short and sweet. Let's head back into the drawing board. Let's do one more problem\ntogether, let's revisit that all construct problem. So we're still taking in our target\nstring, as well as an array of words in a word bank. But this time, you want to return\nall of the ways that you could construct the target by concatenating elements of the word\nbank. So here, you need to return a 2d array, that means a single element of the array represents\na one combination that makes it a target. And like usual, we can reuse elements of the\nword bank as many times as we see fit. So we take a look at an example, let's say I\ngave you the target of abcdef, I gave you this array of words, you actually have many\nways to create the target string, there are four ways over here. So each sub array represents\none combination, where if you concatenate it together, you get the target. And so notice\nthat I want to return every single combination as an element of the outer array over here,\nright. So if there are many ways to create something, then I want to return a 2d array.\nThat being said, there are a few examples that we should keep really in mind having\nto do with our seed values that we kind of foresee. Right. So let's say I gave you this\nexample, where your target is the empty string, and I gave you just some words in the word\nbank. The point is, since your target string is empty, your result should really be a 2d,\nempty array. So recall that the outer array here represents like the collection of multiple\ncombinations. And here, there's only one combination that makes the empty string, right, so the\ninner array represents like that empty combination, we take no words of the word bank. And this\nis a reasonable thing to do, because they'll take give you this example, if your target\nwas birds, and I gave you an array of cat and dog, then the result, there should be\njust a one dimensional empty array, right? The array over here represents the collection\nof combinations. And there are no elements here, right? There are no combinations at\nevery yield of birds. So we'll keep those sort of seed value base case scenarios in\nmind. So let's trace through this example of abcdef. I'll start by initializing our\ntable, we're gonna need a lot of room in this one. And so we know that the size of this\ntable is going to be based on the target string, right, just like we usually do. And then we\nhave to figure out what our seed values are, we kind of just spoke about them, we know\nthat if I have the empty string, then I need to have a 2d empty array. And so we'll initialize\nthat in our table, I know we're going to need a lot of room.\nSo I'm going to spread out these outer brackets. Now for all of the other elements of our table,\nwe want to make them just one dimensional empty arrays. And here's the reason why I\nwrite for these further values in the table, I have to actually check for ways to generate\nthem. So for now, there are no ways that I found right, that's why I just have an array\nwith zero combinations inside, except for index zero, right? index zero has one combination\ninside, that happens to be the empty combination. Cool. So let's start with our general algorithm.\nA lot of this logic will feel very similar to our last few problems. Now we're just adjusting\nit have to generate these combinations, right. So we know that we're going to try to visualize\nhow we look at our string in terms of some prefixes, right. I know that if I'm highlighting\nsome spot in my table, then that grabs the prefix or an index zero all the way up to\nmidnight, including my current index of the table. And I'll light up those characters\nat the top over here. So what I need to do now is since I'm currently at index zero of\nmy table, I consider words of my word bank that have matching characters from this position.\nSo I can look at this a B First, if I took this A B move, then I should look two characters\nahead, right, because a B has a length of two. So that brings me to this position in\nlight blue. And what I should do is take all of the combinations in my current location\nin yellow, and actually copy them over into this future position. But when I do that,\nI also need to be sure to include in those combinations, the move of the word I just\ntook, right, so that would just be adding an AB inside. Right. So again, kind of repeating\nthat step, I copy over the contents of my current position in yellow. But then I have\nto make sure I add my word that I'm consuming right now into each of those combinations\nI just added. Cool. And now we would actually keep our current position here because there\nare still some other words of the word bank that have matching characters, right, I can\ntake an ABC from this position, and something very similar happens write a copy over my\ncurrent array. And then I go ahead and add ABC to it. This happens one more time for\nABCD Awesome. At this point, I've considered all\nof the words that match from this current position. So I can move forward a little bit.\nAt this point, though, I need something that starts with A, B, right? Because my current\nposition has to be on it. And I actually don't find any words of the word bank, that kind\nof match from this position. So I actually moved my current once more. What about this\nposition, I have to consider words of the word bank that have a seat, right, and there\nare a few that can use here, I can use CD, right. And if I do that, I look two characters\nahead or two indices ahead for my current position. So I'm looking at this index. So\nif I look at index four, I have a really interesting situation, right? I already have a some combination\nstored inside of index four. And that represents one way we could make ABCD, right by just\ntaking that loanword ABCD. But what I can also do is, I should take all of the combinations\nfrom my current position and just add them into that index for right, so I'm taking the\nA B from index two, just adding it to index four. But then I also need to add to that\nnew combination of the word I'm using right now, which was CD. Cool. And then from here,\nyou already noticed that, hey, there are so far, two ways to create ABCD, you can just\ntake that loan word ABCD. Or you can do a B plus CD. So this logic is taking some some\nnice shape here. For my current position, there's actually one more word that matches,\nit's really just a single character see, so like I do, I look one character head or one\nindex head in my table just next door, and I copy over the combinations from my current\nlocation in yellow. But then I also append the word I'm consuming, which is just an additional\nC, right. So so far, I have two ways to make ABC. At this point, I can progress my current\nspot and table. And I look for any matching words that start with a D, right? So that\nwould be the D f over here. d f has a length of three. So I look three spots ahead in my\ntable. And I need to add some information here, I copy over my current combinations\nin yellow. And then I have to append at the end of all of them the D F word that I'm using\nright now. So it looks like this. At this point, I can iterate my current position.\nSo now I'm at index four as my current. And I look at any words that start with any, and\nthere's actually just one over here just as EF. And so I look to character's head or to\nindices ahead for my current position. And again, this is a scenario where I need to\nappend new combinations to this existing list, right. So if I look at my current position\nat index four in yellow, I'm going to take all of those combinations and copy them over\ninto my light blue position at index six. And then from there, I also need to make sure\nthat I append to them the word I'm using right now, which is an E, F. So those two combinations\nalso get an F at the end of them. Nice. At this point, you see our final results at the\nlast spot on the table, we continue the general algorithm, we would just move our current\nposition to index five, which is actually a no words of x star with an F over here.\nSo nothing happens on this iteration. And there we have our algorithm, right, that index\nsix of the table contains all of those four ways we described how we can use to create\nour original target string, take a moment to look at this table. And notice how every\nposition of the table should make some logical statement about the target string. Right,\nI can see that if I chose some position, let's say index three, that's giving me some information\nabout the substring ABC, right, that prefix of my original target. And what saying is,\nthere are two ways to make ABC, you can just take ABC, that's actually a word of my word\nbank. Or you can do a B plus C, right? That's the only other way that applies for all positions\nwithin my table. If I look somewhere else, like at index five, that means I'm reading\nsome information about A through E. And if there's no combinations at this position,\nmeans there's no way you can ever generate ABCDE. And if you take a quick glance at the\nwords in the word bank, that is correct, you can't possibly just generate ABCD. Overall,\nthe information in our table and our logic that we did was very consistent. Before we\nhop into the code for this one, let's do the analysis. So we know that m is going to be\nthe length of our target string. And we'll define n to be the number of words in the\nword bank. So like we described, when we did the memorization and recursive solution for\nthis problem, we really can't do better than a sort of brute force, right? Because they're\nasking us to return literally every single way to generate our target string here. So\nreally, the time complexity is going to be the shape of an exponential, right, so about\nn to the M, again, it will have some extra like multiplication terms of M in it. But overall, we're looking at an exponential\ntime complexity. And what's the reason behind that? Well, we know there's going to be an\nexponent The number of actual combinations that we need to return. And I have to actually\nconstruct all of those combinations piece by piece. And so I'm looking at at least exponential\ntime. And really, once something gets exponential, that's really the limiting factor, right.\nAnd similarly, we can say that the space complexity for this is also going to be exponential.\nAgain, roughly, we know that we're going to have at least m space just from the straightforward\nsides of the table. But notice that every element of the table itself is going to be\na 2d array. So in a sense, we're really dealing with like a 3d table in this instance. And\nso we know that at any particular position of our table, we're going to have potentially\nan exponential number of things, right, if you consider the very last spot in our table,\njust the last spot that already has an exponential number of combinations inside of it, but then\nI would actually have that throughout my entire table, so it'd be really a little more than\njust n to the M. But overall, I'll say it's roughly exponential complexity. And you can't\nreally do any better here, right, especially in terms of the time, I'm really asking you\nto just do this in a brute force way, I think we'll actually be able to see that once we\ncreate the solution. Let's hop into it. Alright, for one last time, let's solve this all construct\nproblem. So I'll begin by creating my table. By now we're tabulation masters, this is very,\nvery formulaic. Create my table with roughly target size really target dot length plus\none. And here, I need to initialize the elements of my table as arrays. So here, I need to\nbe very particular and make sure I get a unique array in every spot of the array. So I'm going\nto do a fill using this index before, then I'll map over it that way I can generate a\nnew array for every element here. Cool, let me just style this up. And so this should\ngive me an array as every element of my table, right? Notice that the elements right now\nare just one dimensional empty arrays, right? These arrays represent the collection of combinations.\nAt the start, they're empty, meaning that I have no combinations for most of these elements,\nexcept for one, right, we already spoke about table at index zero, right? That should be\na 2d, empty array. And the reason was, still, the outer array here represents the collection\nof combinations. For the empty string, there is one combination that you can use to make\nit right, that is the empty combination, where you take no words to the word bank. Cool.\nSo now I can begin my general algorithm by just iterating through my target, and you've\ndone this many times before. So I'm iterating through my table. And what I'll also do is\nlook at all of the words, right, so in every iteration, I'm going to consider some words\nof the word bank. So I'll say that word of word bank. And like before I send you to check\nthat, alright, these words better have matching characters based on my current position. So\nI'll use that classic logic, right, seen it many times by now. And I'll slice a segment\nout of my target string, I'll say target dot slice starting index i, and grabbing the next\nword, dot length, number of characters. Cool. I'm going to compare that chunk to the current\nword that I'm iterating through. Nice. So using this statement, I'm sort of filtering\ndown all the words, and only going to do some logic on the words that match based on my\ncurrent position. Nice. And so we've seen you know, this nested for loop an if statement\nbefore, right, we're now we're adding our new logic within this if statement. Cool,\nall I need to do is really understand what types of data I'm dealing with here. All right,\nso let's say I just wrote this expression table at index i, well, that's going to do\nis just reference my current spot in the table. And if I think about what data it's going\nto be, it's definitely gonna be an array, right? It's either going to be like an empty\narray, meaning there are no ways to make this current target. Or it could be a multi dimensional\narray, where every sub array represents one way I can make the current target. So if this\nis all of the combinations that generate my current, then what I'll do is I'm going to\nmap over them. Remember, in our drawing, what we did was kind of copy over all of our current\ncombinations. But then make sure we also add our word that we're using right now to the\nend of each of those combinations. So that's what I'm doing right here, and a map over\nevery summary. And what I'll do is, I'll just copy over the elements of that summary using\nthat spread syntax that we've seen before. And then also be sure to add on at the end\nmy word. Nice. And then that will give me let's say, our new combinations. So I'll just\nsay that to a variable maybe. So new combinations is going to be a 2d array, right where every\nsub array represents some combination. And I want to take these combinations and\nadd them into that further spots inside of my table. So I know I need to kind of look\nat in my table. So I can look at table at index i plus word dot length. I know that\nall positions of the table are going to be arrays, right? So this is going to be an array,\nthere's going to be some data that might already exist at this position, right? So what I don't\nwant to do is just assign you combinations, because then that would overwrite any previous\nexisting combinations that I already found for this position. Instead, I need to make\nsure that I just add these new combinations to that list, right. So what I'll do here\nis I'll push to that array, I'll push all of the elements of my new combinations right\nhere, I can spread this out, I want to spread it out. That way, I don't add any additional\nnesting over here, right. So this is looking pretty good. I think let's go ahead and return\nthe table at Target dot length. Here, I have some examples down below. Let's give this\na shot. Nice. And these answers look correct. Right, notice that these last two examples\nshould return empty arrays because they are impossible to generate. Cool, let's hover\nover this code for a moment. Probably the most tedious logic here would be these two\nlines, right? Really try to understand how like these two lines translate into the logic\nwe did in our drawing. So let's break down these lines again, right? line 11 is going\nto take all of the combinations in my current position in my drawing that was like my yellow\nbox. And it's going to add our current word to each of those combinations. And then we're\ngoing to take each of those new arrays and add them to the list add our further position,\nright being sure not to overwrite, we already spoke about the complexity of this one, it's\ndefinitely going to be exponential, probably a little more than exponential. Right? If\nyou imagine all the work we have to do using these maps and like spreading, we have to\nactually construct our result array, which is going to contain an exponential number\nof things. Right? So when I look at this last example, let's say that I made it a little\nlonger, right? So let's say actually pull up the size of that input. It's going to be\nvery, very slow might even crash, but let's just do it. So let's say I had a bunch of\nA's here, just for fun. So if we try this example. Yeah, it looks like our program still\ncrashes, right? This is going to return a really, really a massive array probably can't\neven fit into memory over here, right? So we'll get like a stack size exceeded, even\nthough this isn't even recursive, right? Just calling functions way too much over here.\nSo no matter what we do, we really expect this problem to sort of demand an exponential\nsolution. With that, let's head back into the drawing board where you can wrap up this\ncourse. Alright, programmers, by now we solve many\ndifferent dynamic programming problems together. And I want to leave us with some final advice.\nSo whenever you're starting to attack any dynamic programming problem, start by really\ntaking a moment and noticing any overlapping subproblems. And then from there really focus\non like the input to the problem, in particular its type. And from there, you shouldn't be\nable to recognize what is the trivial smallest input? So in our string problems, usually\nthat means the empty string in our array problems, it's the empty array, or in our number problems,\nit's usually a number like zero or one, right? Is there some input wherever you don't really\nhave to do any extra work to know the answer? The answer just sort of is what it is. Once\nyou recognize this trivial scenario, or the base case, really, then you'll want to realize\nhow you can relate this base case toward your larger inputs. And then you have two options,\nright? You can either think recursively, and use memorization, or you can think more iteratively\nand build a table using our tabulation formula. I think as you practice dynamic programming\nproblems, I would actually always solve problems in two ways, one using memoization and one\nusing tabulation. And of course, from that point on, it's okay, if you have like a favorite\nstrategy. For me, personally, that's memorization. But that being said, it really helps to have\noptions when you're in an interview. And once you've made that decision on, you know which\nroute you're going to take, definitely, you know, slow it down and draw a strategy first.\nThis is I think, the most important thing about just data structures and algorithms\nin general. Usually, when we draw our pseudocode, or draw our process on the whiteboard, we\ncan recognize all of these edge scenarios. And it's much harder to do when we just write\nlike the code out of the gate. And so I promise if you slow it down and take a moment to draw\na visual, you're gonna find your work a lot more productive, as well as more intuitive\nwhen you explain it to someone else. And of course, through all of that, you're gonna\nhave a lot more fun, you know, dealing with these quite hard topics. Alright, programmers,\nthat's all I got for this course. Hopefully, you had fun, you know, learning this new topic.\nI definitely had fun teaching it to all of you. So what you want to do now is head down\nto the links in description and head to coder byte comm where you can actually practice\nthis new topic. Thanks for watching, and I'll see you in the next one. "
    }
]
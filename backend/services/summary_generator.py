from utils.groq_client import client 

txt = '''
        Hello guys, welcome back to TechDoors and in this video, we will see the tabulation dynamic programming, how to think of writing the tabulation DP. And I will be showing you an example by using the top down approach. And I will be taking 01 knapsack as an example. Now in the previous videos, I had already explained about the recursive as well as the memorization methods. So you should watch those two videos, the link will be presented in the description below and then come back and watch this video. Now let us start. Recursive solution is very important in order to build the DP solution. Recursive code can be converted into the DP code. So earlier in the previous video, I had explained how you can apply just two lines to your recursive code in order to convert it to a memoized code. And this memorization method is also the DP approach. Okay, but the top down approach or the bottom up approach is far superior than the memorization method. But you can also apply either of them. Both are DP approaches. Now if you apply pure recursion, then you will be making function calls. And so you will be building stack memory. If you are applying memorization, then you will be applying recursion calls, which will be using stack memory as well as you will be using a table where you will be remembering the solution for the sub problems so that when that's a problem is encountered again, you will simply return its value without even calculating it. Okay. So in the top down approach, you will not make any function call, you will just be using these cases and you will convert it into a iterative method. And you will just be filling up the table and the last cell will be giving up the result. Okay. So this is generally the case that the bottom right corner cell will be giving you the result. Let's see what is the result in this case. Now we build the DP table in order to remember the solutions for our sub problems as I had explained for the memorization approach. Same goes for the top down as well as for bottom up approaches. Now why tabulation DP is required. Now as I had explained in the memorization approach, we will be using recursion. So recursion will be using stack memory. So if you are making a lot of function calls, then you may encounter stack overflow. So the number of function calls as well as the stack memory will define how many function calls you can make. So this is a limitation for memorization. Obviously, you will be taking table as an extra space in order to store the results for the sub problem. That is the same space you will be using in the tabulation DP approaches. But the only difference is this stack memory. And generally, the heap memory for a code is much larger than the stack memory. When you are reading a code, then you will be mentioned certain stack memory as well as certain heap memory. So the standard is that the stack memory will be around 1 MB and the heap memory will be around 256 MB. Most of the cases this will happen. So it is better that you use heap memory instead of using stack memory. So you should avoid using too many function calls. Otherwise, you will get stack overflow. Now recursion takes more time than the iterative process because for each of the recursion call, you will have to maintain a recursion frame. Okay, so that will take more time. Now stack overflow can occur due to limited stack memory as I had said. Now how to build the DP table. I will take the example of the 01 knapsack problem. First thing you need to do is to you need to identify on how many states and on what states does your solution really depend for a 01 knapsack problem in order to calculate the maximum profit. There are only two states on which your maximum profit depends. That will be the capacity of the bag. Because if you increase the capacity of the bag, then obviously your profit might increase. It will not decrease for sure. And it will depend on the number of items. Because if you have more number of items as choice, then obviously you can choose better items in order to get larger profit. Okay, so these two are the states on which the 01 knapsack maximum profit will depend. Now what will be the table size in this tabular approach, we will be building a 2d matrix. And here we are basically taking the weight of the knapsack that is capacity of the knapsack as well as the number of items. Let us assume that we are taking number of items in x axis and the capacity of the bag on the y axis, you can even take the space on x axis and items on y axis, it won't matter. But the way you think will decide which state to put on what axis. So if you do some problems and you solve some problems, then you will get a better understanding of what to take on what axis, it really doesn't matter. Okay. So in this case, what should be the size of the table. Now it will depend on what is the range of this w and this n. Let's check the range of this w. Now your capacity of the bag can range from zero to w. So how many options are there, it will be from zero to w. So you will be having w plus one options. Okay. And the number of items can be zero to n. So it is again having n plus one options. That is why your table size will be n plus one by w plus one. So the number of rows are n plus one from zero to n number of columns are from zero to w which is w plus one. So the dp will be of size dp of n plus one w plus one. I hope you understand how this db table is formed. Okay. Now let us look at the next step. The next step is to understand about the sub problems. I had already explained about this in the previous video. Now here, if we are taking the zero one knapsack, okay, let's say this is our given input, where we are given three items and the capacity of the knapsack bag is four. Now we have already formed the dp table. And in this case, if you take this s one, then s one is saying that if you are having first two items, that is these two items, one and two, and if your capacity of the bag is one, then what is the maximum profit you can gain the solution for that problem will be filled here. So what will be the solution if you are having first two items of weight one and two, and the capacity of the bag is equals to one. So you can write it as weight is one, two, that is, there are two items, profit will be two and three. These are the corresponding profits and your total capacity is equals to one. Okay. This one. So what can be the maximum profit here? You will obviously be including this one and you will get profit equals to two. So for s one, you will be filling profit equals to two. This will be your maximum profit. Okay. Now, if you look at this sub problem two, then this is saying that if you are having the first one item and the capacity of the bag is three, then your weight will be something like this. First one item is one associated profit will be two and the capacity of the bag is three. This one. So what will the maximum profit since you have only one option and this weight is less than the available capacity, therefore you will include it and the maximum profit will come out to be two. So in this case as well, profit will be two. So this is a sub problem. Sub problems are basically the smaller problems of your entire problem here. The given problem is that if you are having three items, these three items with associated profits and if the capacity of the bag is four, so number of items is three, this one and the capacity of the bag is four. So what will be the maximum profit? This s three will be your maximum profit. So this s three is nothing but your entire problem. Now once you know the solution that is maximum profit for all the sub problems, then you can use them in order to find the solution for this problem. Okay, so dynamic programming says that we need to break down our given problem into sub problems and we will solve this sub problems and use it solution in order to form the solution for the bigger problem. Okay, so this is dynamic programming. Now once you know about the sub problems in this case, let us quickly see the decision diagram. So in this case, if we are at the ith element, then if the ith element is having weight greater than the current capacity of the bag, which is w, then you will obviously be skipping that item. You will not be including it. And if the current item weight is less than equals to the available capacity of the bag, then you can have two options. You can either include the current item or you can exclude the current item. So you will be taking the maximum of these two available options, whichever is giving you the maximum profit. You will take that and you will save it as our answer. Okay, now this is the recursive code which I had shown in the previous video. So in this case, our inputs were the weight array, profit array, and this is our current capacity of the knapsack. And this is the current element to be processed, which is the nth element. So our base case was, if the capacity of the bag is zero, then we won't be able to accommodate any more item. And so our current profit will be zero. Otherwise, if we are having no items, then obviously we cannot take anything into the bag and so our profit will be zero. Okay, this was our base case. Now, in this case, this is according to the choice diagram. If the current weight, the current element is n, this is for nth weight. Okay, so if the nth element is having weight greater than the capacity of the bag, then what we were doing, we were not taking it, we were just skipping that item. So if we skip that item, then we will move on to the next item and we were processing from right to left. So if we are at the nth item, we will go to n minus one items. Okay. So if we go to this n minus one item, then we will be making a call to n minus one. Our weight profit arrays will be the same. And since we have not included the item, our capacity will still remain the same. And if our current weight is actually less than equals to our capacity, then we can either exclude it or we can include it. If we are excluding it, then we will make a call to the previous problem. And if we are including the current item, then we will add the profit of this current item, which is the nth item. And then we will make a call to the previous item. And the available capacity in the bag will obviously decrease with the weight of the current item because we have included that item and we will move on to the previous item. So this was the recursive code which I had shown. Now once you have thought about this recursive code, then you can easily convert it into the top-down approach. In this case, what is the base case here? So this is the base case. If you are having no items, then our profit will be zero. Otherwise, if the capacity is full, that is, we have no capacity in the bag, then profit will be zero. Let us now look at the tabulation DP approach and how to convert the recursive code into our tabulation DP. So I will take the same problem here. We will be given the weight array as well as the corresponding profits. So we are having three items, item zero, item one and item two, and the weight of the knapsack that is its capacity will be equals to four. Now as I had already explained, I will be taking a table which will be of size plus one plus one in terms of rows and columns. Because in this case, if you see, I will be taking items in rows and weight in columns. So the items may be zero or it may be maximum three. So it will range from zero to N. And similarly, the columns will also range from zero to W. Therefore, there will be N plus one rows and W plus one columns. This I had already explained. So this will be our table. And now once we take the table, we will have to fill up all these cells and whatever comes in this last cell will be our answer. So this I had already explained. Now in order to iterate through all the cells, we will be taking two loops. Okay, the first loop will be for row and the second loop will be for column. Now let us see how to convert the recursive code into our tabulation dp. Let us first see the base case. In the base case, if the capacity of the bag is zero, otherwise you are having no items, then your profit will be zero. So how do we write it? Now in this case, it is only possible for this zeroth row and for this zeroth column. Because for the zeroth row, you are having zero number of items. So if you are not having any item, then obviously your profit will be zero. It doesn't depend how much your back capacity really is. And if your back capacity is zero, then it doesn't depend on how many items you have, your profit will be zero. So the first row and first column will be zero. So we will be filling all these values with zero. So let me just fill it. And how do we write the condition here? We will be writing if i equals to zero or j equals to zero. If this is true, then simply we will be filling dp at i, j will be equals to zero. Okay, I hope you are understanding this. This is the base case. Now what about the other cases? So we had two other cases according to the choice diagram. This is if the current weight of the item is greater than the capacity of the bag. If that is true, then we will be skipping the item entirely. So if we are processing the nth item and the weight of the nth item is greater than the capacity of the bag, then we will be skipping this item and we will move to n minus 1 item. So in this case, you can see that this is n minus 1 item, your weight and profit areas will still be the same and your capacity will remain the same because we are not including it. So how do we represent this case in case of iterative approach? Since we are using iterative approach, this first loop was for rows, this will be indicating the items and the second one is for the columns which will be indicating the weight. So we can write it as else if, because if this is not the base case, then we will be checking for the second case, weight at that is the current item. What is the current item? This first loop was for items. So we will be checking weight at i minus 1. Why i minus 1? Because the weight array is starting from zero, but our dp table at zero is indicating that we are having no items, but there is no such case in our weight array. Weight at zero will indicate the weight of the first item. So it is always i minus 1. So if weight at i minus 1 is greater than the current capacity of the bag, and what is the current capacity that will be indicated by j. So if weight at i minus 1 is greater than j, then we will be simply skipping it. And what is skipping means, skipping means that we will be skipping the item and we will move to the previous item. So let's say if we are filling this value, if we are at this value, and if let's say the item with two is greater than the capacity of the bag. So if that was true, in this case, this is not true. But if it was true, then we would have just moved to the previous cell. This would have been i minus 1 itself. So what will we write here, if this is the case, if we want to skip the current item, we will move to the previous item. So dp at i j will be equals to dp at previous item, which will be i minus 1. And the capacity will still remain the same this j is the capacity because we have not included the current item. So this is how we can convert this case into the iterative approach. Okay. So how do we write the third case. Now you can see that there can be only three cases for this problem. The first one was the base case. The second one was for the skipping case. And if these two cases doesn't occur, then obviously we will hit this third case. So we will have to write an else statement here. So we will write else case. So what was there in the else case, actually, when the item weight is less than equals to your capacity of the bag, then this will come this is the third case. In this case, we will try two possibilities. We will try to include the item or we will try to exclude the item. And we will take the maximum of these two values as our answer. Okay. So how do we write that. Now here, as you can see, the first one is the same as the previous statement. So we will write the first one as dp at i j will be equals to maximum of and then a this will be the first case dp at i minus one j. This is when you want to skip the item. Okay. Now, if you don't want to skip the item, then what will you do, we will have to include the current profit and then make a previous function call. So the second option is we will be adding the profit. So profit at i minus one. Again, this is starting from index zero, but our dp table is actually indicating one means the first item, which is a zeroth item. That is why we will be writing i minus one, the same goes for this weight as well. Okay. So we have added the profit. Now this will be adding to the function call. So what function call were we making, we were passing the weight profit as same, but the capacity of the bag here was decreasing. This is decreasing. Okay. And we are making call to the previous function call. So here we will be writing dp at i minus one, which will be indicating the previous item. And then our weight capacity will also decrease because we have included the current item. So the capacity was w. And now, since we are including the current item, which is the it item, it will be decreased by weight at i minus one. Okay. So we will take the maximum of these two values, this value and this yellow part together. We will take the maximum of these two and we'll store in dp at ij. Now this is how we will fill the entire dp table and whatever comes at this last part will indicate if we have three items and if our knapsack capacity is four, then what will be the maximum profit? Okay. So I hope you understood how do we fill the table. Now what will be the time complexity? It will be equals to order of n into w, which is the table size because we are parsing the entire table only once. So I hope you understood the basics about the tabulation dp. If you have any doubt, then feel free to comment below and I'll try to help you as soon as possible. Like and share our video and subscribe to our channel in order to watch more of these programming videos. See you in our next video. Thank you.
    '''

intermediate_summary = ""

for i in range(0,len(txt.split(". ")),50):
    print(i)
    partial_txt = "".join(txt.split(". ")[i:i+50])
    partial_summary = client.chat.completions.create(
        messages=[
            {
                "role": "user",
                "content": f"Summarize the following text in 100 words: {partial_txt}",
            }
        ],
        model="llama3-70b-8192",
    )
    print("api call")
    intermediate_summary+=(partial_summary.choices[0].message.content+" ")

final_summary = client.chat.completions.create(
        messages=[
            {
                "role": "user",
                "content": f"Summarize the following text in 100 words: {intermediate_summary}",
            }
        ],
        model="llama3-70b-8192",
    )

print(final_summary.choices[0].message.content)